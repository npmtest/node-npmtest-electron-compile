{"/home/travis/build/npmtest/node-npmtest-electron-compile/test.js":"/* istanbul instrument in package npmtest_electron_compile */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-electron-compile/lib.npmtest_electron_compile.js":"/* istanbul instrument in package npmtest_electron_compile */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_electron_compile = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_electron_compile = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-electron-compile/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-electron-compile && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_electron_compile */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_electron_compile\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_electron_compile.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_electron_compile.rollup.js'] =\n            local.assetsDict['/assets.npmtest_electron_compile.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_electron_compile.__dirname + '/lib.npmtest_electron_compile.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/index.js":"'use strict';\n\nvar _configParser = require('./config-parser');\n\nvar configParser = _interopRequireWildcard(_configParser);\n\nvar _compilerHost = require('./compiler-host');\n\nvar _compilerHost2 = _interopRequireDefault(_compilerHost);\n\nvar _fileChangeCache = require('./file-change-cache');\n\nvar _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);\n\nvar _compileCache = require('./compile-cache');\n\nvar _compileCache2 = _interopRequireDefault(_compileCache);\n\nvar _protocolHook = require('./protocol-hook');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n//import {enableLiveReload} from './live-reload';\n//import {watchPath} from './pathwatcher-rx';\n\nlet enableLiveReload = null;\nlet watchPath = null;\n\nmodule.exports = Object.assign({\n  // NB: delay-load live-reload so we don't load RxJS in production\n  enableLiveReload: function () {\n    enableLiveReload = enableLiveReload || require('./live-reload').enableLiveReload;\n    return enableLiveReload(...arguments);\n  },\n  watchPath: function () {\n    watchPath = watchPath || require('./pathwatcher-rx').watchPath;\n    return watchPath(...arguments);\n  }\n}, configParser, { CompilerHost: _compilerHost2.default, FileChangedCache: _fileChangeCache2.default, CompileCache: _compileCache2.default, addBypassChecker: _protocolHook.addBypassChecker });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJjb25maWdQYXJzZXIiLCJlbmFibGVMaXZlUmVsb2FkIiwid2F0Y2hQYXRoIiwibW9kdWxlIiwiZXhwb3J0cyIsIk9iamVjdCIsImFzc2lnbiIsInJlcXVpcmUiLCJDb21waWxlckhvc3QiLCJGaWxlQ2hhbmdlZENhY2hlIiwiQ29tcGlsZUNhY2hlIiwiYWRkQnlwYXNzQ2hlY2tlciJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7SUFBWUEsWTs7QUFFWjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBQ0E7QUFDQTs7QUFFQSxJQUFJQyxtQkFBbUIsSUFBdkI7QUFDQSxJQUFJQyxZQUFZLElBQWhCOztBQUVBQyxPQUFPQyxPQUFQLEdBQWlCQyxPQUFPQyxNQUFQLENBQWM7QUFDN0I7QUFDQUwsb0JBQWtCLFlBQWtCO0FBQ2xDQSx1QkFBbUJBLG9CQUFvQk0sUUFBUSxlQUFSLEVBQXlCTixnQkFBaEU7QUFDQSxXQUFPQSxpQkFBaUIsWUFBakIsQ0FBUDtBQUNELEdBTDRCO0FBTTdCQyxhQUFXLFlBQWtCO0FBQzNCQSxnQkFBWUEsYUFBYUssUUFBUSxrQkFBUixFQUE0QkwsU0FBckQ7QUFDQSxXQUFPQSxVQUFVLFlBQVYsQ0FBUDtBQUNEO0FBVDRCLENBQWQsRUFXZkYsWUFYZSxFQVlmLEVBQUVRLG9DQUFGLEVBQWdCQywyQ0FBaEIsRUFBa0NDLG9DQUFsQyxFQUFnREMsZ0RBQWhELEVBWmUsQ0FBakIiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjb25maWdQYXJzZXIgZnJvbSAnLi9jb25maWctcGFyc2VyJztcclxuXHJcbmltcG9ydCBDb21waWxlckhvc3QgZnJvbSAnLi9jb21waWxlci1ob3N0JztcclxuaW1wb3J0IEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSAnLi9maWxlLWNoYW5nZS1jYWNoZSc7XHJcbmltcG9ydCBDb21waWxlQ2FjaGUgZnJvbSAnLi9jb21waWxlLWNhY2hlJztcclxuaW1wb3J0IHthZGRCeXBhc3NDaGVja2VyfSBmcm9tICcuL3Byb3RvY29sLWhvb2snO1xyXG4vL2ltcG9ydCB7ZW5hYmxlTGl2ZVJlbG9hZH0gZnJvbSAnLi9saXZlLXJlbG9hZCc7XHJcbi8vaW1wb3J0IHt3YXRjaFBhdGh9IGZyb20gJy4vcGF0aHdhdGNoZXItcngnO1xyXG5cclxubGV0IGVuYWJsZUxpdmVSZWxvYWQgPSBudWxsO1xyXG5sZXQgd2F0Y2hQYXRoID0gbnVsbDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgLy8gTkI6IGRlbGF5LWxvYWQgbGl2ZS1yZWxvYWQgc28gd2UgZG9uJ3QgbG9hZCBSeEpTIGluIHByb2R1Y3Rpb25cclxuICBlbmFibGVMaXZlUmVsb2FkOiBmdW5jdGlvbiguLi5hcmdzKSB7XHJcbiAgICBlbmFibGVMaXZlUmVsb2FkID0gZW5hYmxlTGl2ZVJlbG9hZCB8fCByZXF1aXJlKCcuL2xpdmUtcmVsb2FkJykuZW5hYmxlTGl2ZVJlbG9hZDtcclxuICAgIHJldHVybiBlbmFibGVMaXZlUmVsb2FkKC4uLmFyZ3MpO1xyXG4gIH0sXHJcbiAgd2F0Y2hQYXRoOiBmdW5jdGlvbiguLi5hcmdzKSB7XHJcbiAgICB3YXRjaFBhdGggPSB3YXRjaFBhdGggfHwgcmVxdWlyZSgnLi9wYXRod2F0Y2hlci1yeCcpLndhdGNoUGF0aDtcclxuICAgIHJldHVybiB3YXRjaFBhdGgoLi4uYXJncyk7XHJcbiAgfSxcclxufSxcclxuICBjb25maWdQYXJzZXIsXHJcbiAgeyBDb21waWxlckhvc3QsIEZpbGVDaGFuZ2VkQ2FjaGUsIENvbXBpbGVDYWNoZSwgYWRkQnlwYXNzQ2hlY2tlciB9XHJcbik7XHJcbiJdfQ==","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/config-parser.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCompilerHostFromProjectRoot = exports.createCompilerHostFromConfigFile = exports.createCompilerHostFromBabelRc = undefined;\n\n/**\r\n * Creates a compiler host from a .babelrc file. This method is usually called\r\n * from {@link createCompilerHostFromProjectRoot} instead of used directly.\r\n *\r\n * @param  {string} file  The path to a .babelrc file\r\n *\r\n * @param  {string} rootCacheDir (optional)  The directory to use as a cache.\r\n *\r\n * @return {Promise<CompilerHost>}  A set-up compiler host\r\n */\nlet createCompilerHostFromBabelRc = exports.createCompilerHostFromBabelRc = (() => {\n  var _ref = _asyncToGenerator(function* (file) {\n    let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    let info = JSON.parse((yield _promise.pfs.readFile(file, 'utf8')));\n\n    // package.json\n    if ('babel' in info) {\n      info = info.babel;\n    }\n\n    if ('env' in info) {\n      let ourEnv = process.env.BABEL_ENV || process.env.NODE_ENV || 'development';\n      info = info.env[ourEnv];\n    }\n\n    // Are we still package.json (i.e. is there no babel info whatsoever?)\n    if ('name' in info && 'version' in info) {\n      let appRoot = _path2.default.dirname(file);\n      return createCompilerHostFromConfiguration({\n        appRoot: appRoot,\n        options: getDefaultConfiguration(appRoot),\n        rootCacheDir,\n        sourceMapPath\n      });\n    }\n\n    return createCompilerHostFromConfiguration({\n      appRoot: _path2.default.dirname(file),\n      options: {\n        'application/javascript': info\n      },\n      rootCacheDir,\n      sourceMapPath\n    });\n  });\n\n  return function createCompilerHostFromBabelRc(_x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\n/**\r\n * Creates a compiler host from a .compilerc file. This method is usually called\r\n * from {@link createCompilerHostFromProjectRoot} instead of used directly.\r\n *\r\n * @param  {string} file  The path to a .compilerc file\r\n *\r\n * @param  {string} rootCacheDir (optional)  The directory to use as a cache.\r\n *\r\n * @return {Promise<CompilerHost>}  A set-up compiler host\r\n */\n\n\nlet createCompilerHostFromConfigFile = exports.createCompilerHostFromConfigFile = (() => {\n  var _ref2 = _asyncToGenerator(function* (file) {\n    let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    let info = JSON.parse((yield _promise.pfs.readFile(file, 'utf8')));\n\n    if ('env' in info) {\n      let ourEnv = process.env.ELECTRON_COMPILE_ENV || process.env.NODE_ENV || 'development';\n      info = info.env[ourEnv];\n    }\n\n    return createCompilerHostFromConfiguration({\n      appRoot: _path2.default.dirname(file),\n      options: info,\n      rootCacheDir,\n      sourceMapPath\n    });\n  });\n\n  return function createCompilerHostFromConfigFile(_x7) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\n/**\r\n * Creates a configured {@link CompilerHost} instance from the project root\r\n * directory. This method first searches for a .compilerc (or .compilerc.json), then falls back to the\r\n * default locations for Babel configuration info. If neither are found, defaults\r\n * to standard settings\r\n *\r\n * @param  {string} rootDir  The root application directory (i.e. the directory\r\n *                           that has the app's package.json)\r\n *\r\n * @param  {string} rootCacheDir (optional)  The directory to use as a cache.\r\n *\r\n * @param {string} sourceMapPath (optional) The directory to store sourcemap separately\r\n *                               if compiler option enabled to emit.\r\n *\r\n * @return {Promise<CompilerHost>}  A set-up compiler host\r\n */\n\n\nlet createCompilerHostFromProjectRoot = exports.createCompilerHostFromProjectRoot = (() => {\n  var _ref3 = _asyncToGenerator(function* (rootDir) {\n    let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    let compilerc = _path2.default.join(rootDir, '.compilerc');\n    if (statSyncNoException(compilerc)) {\n      d(`Found a .compilerc at ${compilerc}, using it`);\n      return yield createCompilerHostFromConfigFile(compilerc, rootCacheDir, sourceMapPath);\n    }\n    compilerc += '.json';\n    if (statSyncNoException(compilerc)) {\n      d(`Found a .compilerc at ${compilerc}, using it`);\n      return yield createCompilerHostFromConfigFile(compilerc, rootCacheDir, sourceMapPath);\n    }\n\n    let babelrc = _path2.default.join(rootDir, '.babelrc');\n    if (statSyncNoException(babelrc)) {\n      d(`Found a .babelrc at ${babelrc}, using it`);\n      return yield createCompilerHostFromBabelRc(babelrc, rootCacheDir, sourceMapPath);\n    }\n\n    d(`Using package.json or default parameters at ${rootDir}`);\n    return yield createCompilerHostFromBabelRc(_path2.default.join(rootDir, 'package.json'), rootCacheDir, sourceMapPath);\n  });\n\n  return function createCompilerHostFromProjectRoot(_x10) {\n    return _ref3.apply(this, arguments);\n  };\n})();\n\nexports.initializeGlobalHooks = initializeGlobalHooks;\nexports.init = init;\nexports.createCompilerHostFromConfiguration = createCompilerHostFromConfiguration;\nexports.createCompilerHostFromBabelRcSync = createCompilerHostFromBabelRcSync;\nexports.createCompilerHostFromConfigFileSync = createCompilerHostFromConfigFileSync;\nexports.createCompilerHostFromProjectRootSync = createCompilerHostFromProjectRootSync;\nexports.calculateDefaultCompileCacheDirectory = calculateDefaultCompileCacheDirectory;\nexports.getDefaultConfiguration = getDefaultConfiguration;\nexports.createCompilers = createCompilers;\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _zlib = require('zlib');\n\nvar _zlib2 = _interopRequireDefault(_zlib);\n\nvar _mkdirp = require('mkdirp');\n\nvar _mkdirp2 = _interopRequireDefault(_mkdirp);\n\nvar _promise = require('./promise');\n\nvar _fileChangeCache = require('./file-change-cache');\n\nvar _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);\n\nvar _compilerHost = require('./compiler-host');\n\nvar _compilerHost2 = _interopRequireDefault(_compilerHost);\n\nvar _requireHook = require('./require-hook');\n\nvar _requireHook2 = _interopRequireDefault(_requireHook);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst d = require('debug')('electron-compile:config-parser');\n\n// NB: We intentionally delay-load this so that in production, you can create\n// cache-only versions of these compilers\nlet allCompilerClasses = null;\n\nfunction statSyncNoException(fsPath) {\n  if ('statSyncNoException' in _fs2.default) {\n    return _fs2.default.statSyncNoException(fsPath);\n  }\n\n  try {\n    return _fs2.default.statSync(fsPath);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\r\n * Initialize the global hooks (protocol hook for file:, node.js hook)\r\n * independent of initializing the compiler. This method is usually called by\r\n * init instead of directly\r\n *\r\n * @param {CompilerHost} compilerHost  The compiler host to use.\r\n *\r\n */\nfunction initializeGlobalHooks(compilerHost) {\n  let globalVar = global || window;\n  globalVar.globalCompilerHost = compilerHost;\n\n  (0, _requireHook2.default)(compilerHost);\n\n  if ('type' in process && process.type === 'browser') {\n    var _require = require('electron');\n\n    const app = _require.app;\n\n    var _require2 = require('./protocol-hook');\n\n    const initializeProtocolHook = _require2.initializeProtocolHook;\n\n\n    let protoify = function () {\n      initializeProtocolHook(compilerHost);\n    };\n    if (app.isReady()) {\n      protoify();\n    } else {\n      app.on('ready', protoify);\n    }\n  }\n}\n\n/**\r\n * Initialize electron-compile and set it up, either for development or\r\n * production use. This is almost always the only method you need to use in order\r\n * to use electron-compile.\r\n *\r\n * @param  {string} appRoot  The top-level directory for your application (i.e.\r\n *                           the one which has your package.json).\r\n *\r\n * @param  {string} mainModule  The module to require in, relative to the module\r\n *                              calling init, that will start your app. Write this\r\n *                              as if you were writing a require call from here.\r\n *\r\n * @param  {bool} productionMode   If explicitly True/False, will set read-only\r\n *                                 mode to be disabled/enabled. If not, we'll\r\n *                                 guess based on the presence of a production\r\n *                                 cache.\r\n *\r\n * @param  {string} cacheDir  If not passed in, read-only will look in\r\n *                            `appRoot/.cache` and dev mode will compile to a\r\n *                            temporary directory. If it is passed in, both modes\r\n *                            will cache to/from `appRoot/{cacheDir}`\r\n *\r\n * @param {string} sourceMapPath (optional) The directory to store sourcemap separately\r\n *                               if compiler option enabled to emit.\r\n *                               Default to cachePath if not specified, will be ignored for read-only mode.\r\n */\nfunction init(appRoot, mainModule) {\n  let productionMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let cacheDir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let sourceMapPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n  let compilerHost = null;\n  let rootCacheDir = _path2.default.join(appRoot, cacheDir || '.cache');\n\n  if (productionMode === null) {\n    productionMode = !!statSyncNoException(rootCacheDir);\n  }\n\n  if (productionMode) {\n    compilerHost = _compilerHost2.default.createReadonlyFromConfigurationSync(rootCacheDir, appRoot);\n  } else {\n    // if cacheDir was passed in, pass it along. Otherwise, default to a tempdir.\n    const cachePath = cacheDir ? rootCacheDir : null;\n    const mapPath = sourceMapPath ? _path2.default.join(appRoot, sourceMapPath) : cachePath;\n    compilerHost = createCompilerHostFromProjectRootSync(appRoot, cachePath, mapPath);\n  }\n\n  initializeGlobalHooks(compilerHost);\n  require.main.require(mainModule);\n}\n\n/**\r\n * Creates a {@link CompilerHost} with the given information. This method is\r\n * usually called by {@link createCompilerHostFromProjectRoot}.\r\n *\r\n * @private\r\n */\nfunction createCompilerHostFromConfiguration(info) {\n  let compilers = createCompilers();\n  let rootCacheDir = info.rootCacheDir || calculateDefaultCompileCacheDirectory();\n  const sourceMapPath = info.sourceMapPath || info.rootCacheDir;\n\n  if (info.sourceMapPath) {\n    createSourceMapDirectory(sourceMapPath);\n  }\n\n  d(`Creating CompilerHost: ${JSON.stringify(info)}, rootCacheDir = ${rootCacheDir}, sourceMapPath = ${sourceMapPath}`);\n  let fileChangeCache = new _fileChangeCache2.default(info.appRoot);\n\n  let compilerInfo = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');\n  if (_fs2.default.existsSync(compilerInfo)) {\n    let buf = _fs2.default.readFileSync(compilerInfo);\n    let json = JSON.parse(_zlib2.default.gunzipSync(buf));\n    fileChangeCache = _fileChangeCache2.default.loadFromData(json.fileChangeCache, info.appRoot, false);\n  }\n\n  Object.keys(info.options || {}).forEach(x => {\n    let opts = info.options[x];\n    if (!(x in compilers)) {\n      throw new Error(`Found compiler settings for missing compiler: ${x}`);\n    }\n\n    // NB: Let's hope this isn't a valid compiler option...\n    if (opts.passthrough) {\n      compilers[x] = compilers['text/plain'];\n      delete opts.passthrough;\n    }\n\n    d(`Setting options for ${x}: ${JSON.stringify(opts)}`);\n    compilers[x].compilerOptions = opts;\n  });\n\n  let ret = new _compilerHost2.default(rootCacheDir, compilers, fileChangeCache, false, compilers['text/plain']);\n\n  // NB: It's super important that we guarantee that the configuration is saved\n  // out, because we'll need to re-read it in the renderer process\n  d(`Created compiler host with options: ${JSON.stringify(info)}`);\n  ret.saveConfigurationSync();\n  return ret;\n}function createCompilerHostFromBabelRcSync(file) {\n  let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  let info = JSON.parse(_fs2.default.readFileSync(file, 'utf8'));\n\n  // package.json\n  if ('babel' in info) {\n    info = info.babel;\n  }\n\n  if ('env' in info) {\n    let ourEnv = process.env.BABEL_ENV || process.env.NODE_ENV || 'development';\n    info = info.env[ourEnv];\n  }\n\n  // Are we still package.json (i.e. is there no babel info whatsoever?)\n  if ('name' in info && 'version' in info) {\n    let appRoot = _path2.default.dirname(file);\n    return createCompilerHostFromConfiguration({\n      appRoot: appRoot,\n      options: getDefaultConfiguration(appRoot),\n      rootCacheDir,\n      sourceMapPath\n    });\n  }\n\n  return createCompilerHostFromConfiguration({\n    appRoot: _path2.default.dirname(file),\n    options: {\n      'application/javascript': info\n    },\n    rootCacheDir,\n    sourceMapPath\n  });\n}\n\nfunction createCompilerHostFromConfigFileSync(file) {\n  let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  let info = JSON.parse(_fs2.default.readFileSync(file, 'utf8'));\n\n  if ('env' in info) {\n    let ourEnv = process.env.ELECTRON_COMPILE_ENV || process.env.NODE_ENV || 'development';\n    info = info.env[ourEnv];\n  }\n\n  return createCompilerHostFromConfiguration({\n    appRoot: _path2.default.dirname(file),\n    options: info,\n    rootCacheDir,\n    sourceMapPath\n  });\n}\n\nfunction createCompilerHostFromProjectRootSync(rootDir) {\n  let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  let compilerc = _path2.default.join(rootDir, '.compilerc');\n  if (statSyncNoException(compilerc)) {\n    d(`Found a .compilerc at ${compilerc}, using it`);\n    return createCompilerHostFromConfigFileSync(compilerc, rootCacheDir, sourceMapPath);\n  }\n\n  let babelrc = _path2.default.join(rootDir, '.babelrc');\n  if (statSyncNoException(babelrc)) {\n    d(`Found a .babelrc at ${babelrc}, using it`);\n    return createCompilerHostFromBabelRcSync(babelrc, rootCacheDir, sourceMapPath);\n  }\n\n  d(`Using package.json or default parameters at ${rootDir}`);\n  return createCompilerHostFromBabelRcSync(_path2.default.join(rootDir, 'package.json'), rootCacheDir, sourceMapPath);\n}\n\n/**\r\n * Returns what electron-compile would use as a default rootCacheDir. Usually only\r\n * used for debugging purposes\r\n *\r\n * @return {string}  A path that may or may not exist where electron-compile would\r\n *                   set up a development mode cache.\r\n */\nfunction calculateDefaultCompileCacheDirectory() {\n  let tmpDir = process.env.TEMP || process.env.TMPDIR || '/tmp';\n  let hash = require('crypto').createHash('md5').update(process.execPath).digest('hex');\n\n  let cacheDir = _path2.default.join(tmpDir, `compileCache_${hash}`);\n  _mkdirp2.default.sync(cacheDir);\n\n  d(`Using default cache directory: ${cacheDir}`);\n  return cacheDir;\n}\n\nfunction createSourceMapDirectory(sourceMapPath) {\n  _mkdirp2.default.sync(sourceMapPath);\n  d(`Using separate sourcemap path at ${sourceMapPath}`);\n}\n\nfunction versionToFloat(ver) {\n  return parseFloat(ver.replace(/^([^\\.]\\.[^\\.])\\..*$/, '$1'));\n}\n\nfunction getElectronVersion(rootDir) {\n  if (process.versions.electron) {\n    return versionToFloat(process.versions.electron);\n  }\n\n  let ourPkgJson = require(_path2.default.join(rootDir, 'package.json'));\n\n  let version = ['electron-prebuilt-compile', 'electron'].map(mod => {\n    if (ourPkgJson.devDependencies && ourPkgJson.devDependencies[mod]) {\n      // NB: lol this code\n      let verRange = ourPkgJson.devDependencies[mod];\n      let m = verRange.match(/(\\d+\\.\\d+\\.\\d+)/);\n      if (m && m[1]) return m[1];\n    }\n\n    try {\n      return process.mainModule.require(`${mod}/package.json`).version;\n    } catch (e) {\n      // NB: This usually doesn't work, but sometimes maybe?\n    }\n\n    try {\n      let p = _path2.default.join(rootDir, mod, 'package.json');\n      return require(p).version;\n    } catch (e) {\n      return null;\n    }\n  }).find(x => !!x);\n\n  if (!version) {\n    throw new Error(\"Can't automatically discover the version of Electron, you probably need a .compilerc file\");\n  }\n\n  return versionToFloat(version);\n}\n\n/**\r\n * Returns the default .configrc if no configuration information can be found.\r\n *\r\n * @return {Object}  A list of default config settings for electron-compiler.\r\n */\nfunction getDefaultConfiguration(rootDir) {\n  return {\n    'application/javascript': {\n      \"presets\": [[\"env\", {\n        \"targets\": {\n          \"electron\": getElectronVersion(rootDir)\n        }\n      }], \"react\"],\n      \"sourceMaps\": \"inline\"\n    }\n  };\n}\n\n/**\r\n * Allows you to create new instances of all compilers that are supported by\r\n * electron-compile and use them directly. Currently supports Babel, CoffeeScript,\r\n * TypeScript, Less, and Jade.\r\n *\r\n * @return {Object}  An Object whose Keys are MIME types, and whose values\r\n * are instances of @{link CompilerBase}.\r\n */\nfunction createCompilers() {\n  if (!allCompilerClasses) {\n    // First we want to see if electron-compilers itself has been installed with\n    // devDependencies. If that's not the case, check to see if\n    // electron-compilers is installed as a peer dependency (probably as a\n    // devDependency of the root project).\n    const locations = ['electron-compilers', '../../electron-compilers'];\n\n    for (let location of locations) {\n      try {\n        allCompilerClasses = require(location);\n      } catch (e) {\n        // Yolo\n      }\n    }\n\n    if (!allCompilerClasses) {\n      throw new Error(\"Electron compilers not found but were requested to be loaded\");\n    }\n  }\n\n  // NB: Note that this code is carefully set up so that InlineHtmlCompiler\n  // (i.e. classes with `createFromCompilers`) initially get an empty object,\n  // but will have a reference to the final result of what we return, which\n  // resolves the circular dependency we'd otherwise have here.\n  let ret = {};\n  let instantiatedClasses = allCompilerClasses.map(Klass => {\n    if ('createFromCompilers' in Klass) {\n      return Klass.createFromCompilers(ret);\n    } else {\n      return new Klass();\n    }\n  });\n\n  instantiatedClasses.reduce((acc, x) => {\n    let Klass = Object.getPrototypeOf(x).constructor;\n\n    for (let type of Klass.getInputMimeTypes()) {\n      acc[type] = x;\n    }\n    return acc;\n  }, ret);\n\n  return ret;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb25maWctcGFyc2VyLmpzIl0sIm5hbWVzIjpbImZpbGUiLCJyb290Q2FjaGVEaXIiLCJzb3VyY2VNYXBQYXRoIiwiaW5mbyIsIkpTT04iLCJwYXJzZSIsInJlYWRGaWxlIiwiYmFiZWwiLCJvdXJFbnYiLCJwcm9jZXNzIiwiZW52IiwiQkFCRUxfRU5WIiwiTk9ERV9FTlYiLCJhcHBSb290IiwiZGlybmFtZSIsImNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uIiwib3B0aW9ucyIsImdldERlZmF1bHRDb25maWd1cmF0aW9uIiwiY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmMiLCJFTEVDVFJPTl9DT01QSUxFX0VOViIsImNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlIiwicm9vdERpciIsImNvbXBpbGVyYyIsImpvaW4iLCJzdGF0U3luY05vRXhjZXB0aW9uIiwiZCIsImJhYmVscmMiLCJjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3QiLCJpbml0aWFsaXplR2xvYmFsSG9va3MiLCJpbml0IiwiY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmNTeW5jIiwiY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ0ZpbGVTeW5jIiwiY3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290U3luYyIsImNhbGN1bGF0ZURlZmF1bHRDb21waWxlQ2FjaGVEaXJlY3RvcnkiLCJjcmVhdGVDb21waWxlcnMiLCJyZXF1aXJlIiwiYWxsQ29tcGlsZXJDbGFzc2VzIiwiZnNQYXRoIiwic3RhdFN5bmMiLCJlIiwiY29tcGlsZXJIb3N0IiwiZ2xvYmFsVmFyIiwiZ2xvYmFsIiwid2luZG93IiwiZ2xvYmFsQ29tcGlsZXJIb3N0IiwidHlwZSIsImFwcCIsImluaXRpYWxpemVQcm90b2NvbEhvb2siLCJwcm90b2lmeSIsImlzUmVhZHkiLCJvbiIsIm1haW5Nb2R1bGUiLCJwcm9kdWN0aW9uTW9kZSIsImNhY2hlRGlyIiwiY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvblN5bmMiLCJjYWNoZVBhdGgiLCJtYXBQYXRoIiwibWFpbiIsImNvbXBpbGVycyIsImNyZWF0ZVNvdXJjZU1hcERpcmVjdG9yeSIsInN0cmluZ2lmeSIsImZpbGVDaGFuZ2VDYWNoZSIsImNvbXBpbGVySW5mbyIsImV4aXN0c1N5bmMiLCJidWYiLCJyZWFkRmlsZVN5bmMiLCJqc29uIiwiZ3VuemlwU3luYyIsImxvYWRGcm9tRGF0YSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwieCIsIm9wdHMiLCJFcnJvciIsInBhc3N0aHJvdWdoIiwiY29tcGlsZXJPcHRpb25zIiwicmV0Iiwic2F2ZUNvbmZpZ3VyYXRpb25TeW5jIiwidG1wRGlyIiwiVEVNUCIsIlRNUERJUiIsImhhc2giLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZXhlY1BhdGgiLCJkaWdlc3QiLCJzeW5jIiwidmVyc2lvblRvRmxvYXQiLCJ2ZXIiLCJwYXJzZUZsb2F0IiwicmVwbGFjZSIsImdldEVsZWN0cm9uVmVyc2lvbiIsInZlcnNpb25zIiwiZWxlY3Ryb24iLCJvdXJQa2dKc29uIiwidmVyc2lvbiIsIm1hcCIsIm1vZCIsImRldkRlcGVuZGVuY2llcyIsInZlclJhbmdlIiwibSIsIm1hdGNoIiwicCIsImZpbmQiLCJsb2NhdGlvbnMiLCJsb2NhdGlvbiIsImluc3RhbnRpYXRlZENsYXNzZXMiLCJLbGFzcyIsImNyZWF0ZUZyb21Db21waWxlcnMiLCJyZWR1Y2UiLCJhY2MiLCJnZXRQcm90b3R5cGVPZiIsImNvbnN0cnVjdG9yIiwiZ2V0SW5wdXRNaW1lVHlwZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUEySkE7Ozs7Ozs7Ozs7OytCQVVPLFdBQTZDQSxJQUE3QyxFQUE0RjtBQUFBLFFBQXpDQyxZQUF5Qyx1RUFBNUIsSUFBNEI7QUFBQSxRQUF0QkMsYUFBc0IsdUVBQU4sSUFBTTs7QUFDakcsUUFBSUMsT0FBT0MsS0FBS0MsS0FBTCxFQUFXLE1BQU0sYUFBSUMsUUFBSixD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QU1DLG1CQUFOLENBQTBCaEMsR0FBMUIsQ0FBUDtBQUNELEtBRkQsTUFFTztBQUNMLGFBQU8sSUFBSStCLEtBQUosRUFBUDtBQUNEO0FBQ0YsR0FOeUIsQ0FBMUI7O0FBUUFELHNCQUFvQkcsTUFBcEIsQ0FBMkIsQ0FBQ0MsR0FBRCxFQUFLdkMsQ0FBTCxLQUFXO0FBQ3BDLFFBQUlvQyxRQUFRdkMsT0FBTzJDLGNBQVAsQ0FBc0J4QyxDQUF0QixFQUF5QnlDLFdBQXJDOztBQUVBLFNBQUssSUFBSXBFLElBQVQsSUFBaUIrRCxNQUFNTSxpQkFBTixFQUFqQixFQUE0QztBQUFFSCxVQUFJbEUsSUFBSixJQUFZMkIsQ0FBWjtBQUFnQjtBQUM5RCxXQUFPdUMsR0FBUDtBQUNELEdBTEQsRUFLR2xDLEdBTEg7O0FBT0EsU0FBT0EsR0FBUDtBQUNEIiwiZmlsZSI6ImNvbmZpZy1wYXJzZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XHJcbmltcG9ydCBta2RpcnAgZnJvbSAnbWtkaXJwJztcclxuaW1wb3J0IHtwZnN9IGZyb20gJy4vcHJvbWlzZSc7XHJcblxyXG5pbXBvcnQgRmlsZUNoYW5nZWRDYWNoZSBmcm9tICcuL2ZpbGUtY2hhbmdlLWNhY2hlJztcclxuaW1wb3J0IENvbXBpbGVySG9zdCBmcm9tICcuL2NvbXBpbGVyLWhvc3QnO1xyXG5pbXBvcnQgcmVnaXN0ZXJSZXF1aXJlRXh0ZW5zaW9uIGZyb20gJy4vcmVxdWlyZS1ob29rJztcclxuXHJcbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOmNvbmZpZy1wYXJzZXInKTtcclxuXHJcbi8vIE5COiBXZSBpbnRlbnRpb25hbGx5IGRlbGF5LWxvYWQgdGhpcyBzbyB0aGF0IGluIHByb2R1Y3Rpb24sIHlvdSBjYW4gY3JlYXRlXHJcbi8vIGNhY2hlLW9ubHkgdmVyc2lvbnMgb2YgdGhlc2UgY29tcGlsZXJzXHJcbmxldCBhbGxDb21waWxlckNsYXNzZXMgPSBudWxsO1xyXG5cclxuZnVuY3Rpb24gc3RhdFN5bmNOb0V4Y2VwdGlvbihmc1BhdGgpIHtcclxuICBpZiAoJ3N0YXRTeW5jTm9FeGNlcHRpb24nIGluIGZzKSB7XHJcbiAgICByZXR1cm4gZnMuc3RhdFN5bmNOb0V4Y2VwdGlvbihmc1BhdGgpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBmcy5zdGF0U3luYyhmc1BhdGgpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIHRoZSBnbG9iYWwgaG9va3MgKHByb3RvY29sIGhvb2sgZm9yIGZpbGU6LCBub2RlLmpzIGhvb2spXHJcbiAqIGluZGVwZW5kZW50IG9mIGluaXRpYWxpemluZyB0aGUgY29tcGlsZXIuIFRoaXMgbWV0aG9kIGlzIHVzdWFsbHkgY2FsbGVkIGJ5XHJcbiAqIGluaXQgaW5zdGVhZCBvZiBkaXJlY3RseVxyXG4gKlxyXG4gKiBAcGFyYW0ge0NvbXBpbGVySG9zdH0gY29tcGlsZXJIb3N0ICBUaGUgY29tcGlsZXIgaG9zdCB0byB1c2UuXHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUdsb2JhbEhvb2tzKGNvbXBpbGVySG9zdCkge1xyXG4gIGxldCBnbG9iYWxWYXIgPSAoZ2xvYmFsIHx8IHdpbmRvdyk7XHJcbiAgZ2xvYmFsVmFyLmdsb2JhbENvbXBpbGVySG9zdCA9IGNvbXBpbGVySG9zdDtcclxuXHJcbiAgcmVnaXN0ZXJSZXF1aXJlRXh0ZW5zaW9uKGNvbXBpbGVySG9zdCk7XHJcblxyXG4gIGlmICgndHlwZScgaW4gcHJvY2VzcyAmJiBwcm9jZXNzLnR5cGUgPT09ICdicm93c2VyJykge1xyXG4gICAgY29uc3QgeyBhcHAgfSA9IHJlcXVpcmUoJ2VsZWN0cm9uJyk7XHJcbiAgICBjb25zdCB7IGluaXRpYWxpemVQcm90b2NvbEhvb2sgfSA9IHJlcXVpcmUoJy4vcHJvdG9jb2wtaG9vaycpO1xyXG5cclxuICAgIGxldCBwcm90b2lmeSA9IGZ1bmN0aW9uKCkgeyBpbml0aWFsaXplUHJvdG9jb2xIb29rKGNvbXBpbGVySG9zdCk7IH07XHJcbiAgICBpZiAoYXBwLmlzUmVhZHkoKSkge1xyXG4gICAgICBwcm90b2lmeSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXBwLm9uKCdyZWFkeScsIHByb3RvaWZ5KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBlbGVjdHJvbi1jb21waWxlIGFuZCBzZXQgaXQgdXAsIGVpdGhlciBmb3IgZGV2ZWxvcG1lbnQgb3JcclxuICogcHJvZHVjdGlvbiB1c2UuIFRoaXMgaXMgYWxtb3N0IGFsd2F5cyB0aGUgb25seSBtZXRob2QgeW91IG5lZWQgdG8gdXNlIGluIG9yZGVyXHJcbiAqIHRvIHVzZSBlbGVjdHJvbi1jb21waWxlLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGFwcFJvb3QgIFRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IGZvciB5b3VyIGFwcGxpY2F0aW9uIChpLmUuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1haW5Nb2R1bGUgIFRoZSBtb2R1bGUgdG8gcmVxdWlyZSBpbiwgcmVsYXRpdmUgdG8gdGhlIG1vZHVsZVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxpbmcgaW5pdCwgdGhhdCB3aWxsIHN0YXJ0IHlvdXIgYXBwLiBXcml0ZSB0aGlzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgaWYgeW91IHdlcmUgd3JpdGluZyBhIHJlcXVpcmUgY2FsbCBmcm9tIGhlcmUuXHJcbiAqXHJcbiAqIEBwYXJhbSAge2Jvb2x9IHByb2R1Y3Rpb25Nb2RlICAgSWYgZXhwbGljaXRseSBUcnVlL0ZhbHNlLCB3aWxsIHNldCByZWFkLW9ubHlcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlIHRvIGJlIGRpc2FibGVkL2VuYWJsZWQuIElmIG5vdCwgd2UnbGxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWVzcyBiYXNlZCBvbiB0aGUgcHJlc2VuY2Ugb2YgYSBwcm9kdWN0aW9uXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gY2FjaGVEaXIgIElmIG5vdCBwYXNzZWQgaW4sIHJlYWQtb25seSB3aWxsIGxvb2sgaW5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFwcFJvb3QvLmNhY2hlYCBhbmQgZGV2IG1vZGUgd2lsbCBjb21waWxlIHRvIGFcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcG9yYXJ5IGRpcmVjdG9yeS4gSWYgaXQgaXMgcGFzc2VkIGluLCBib3RoIG1vZGVzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgY2FjaGUgdG8vZnJvbSBgYXBwUm9vdC97Y2FjaGVEaXJ9YFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlTWFwUGF0aCAob3B0aW9uYWwpIFRoZSBkaXJlY3RvcnkgdG8gc3RvcmUgc291cmNlbWFwIHNlcGFyYXRlbHlcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgY29tcGlsZXIgb3B0aW9uIGVuYWJsZWQgdG8gZW1pdC5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB0byBjYWNoZVBhdGggaWYgbm90IHNwZWNpZmllZCwgd2lsbCBiZSBpZ25vcmVkIGZvciByZWFkLW9ubHkgbW9kZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0KGFwcFJvb3QsIG1haW5Nb2R1bGUsIHByb2R1Y3Rpb25Nb2RlID0gbnVsbCwgY2FjaGVEaXIgPSBudWxsLCBzb3VyY2VNYXBQYXRoID0gbnVsbCkge1xyXG4gIGxldCBjb21waWxlckhvc3QgPSBudWxsO1xyXG4gIGxldCByb290Q2FjaGVEaXIgPSBwYXRoLmpvaW4oYXBwUm9vdCwgY2FjaGVEaXIgfHwgJy5jYWNoZScpO1xyXG5cclxuICBpZiAocHJvZHVjdGlvbk1vZGUgPT09IG51bGwpIHtcclxuICAgIHByb2R1Y3Rpb25Nb2RlID0gISFzdGF0U3luY05vRXhjZXB0aW9uKHJvb3RDYWNoZURpcik7XHJcbiAgfVxyXG5cclxuICBpZiAocHJvZHVjdGlvbk1vZGUpIHtcclxuICAgIGNvbXBpbGVySG9zdCA9IENvbXBpbGVySG9zdC5jcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9uU3luYyhyb290Q2FjaGVEaXIsIGFwcFJvb3QpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBpZiBjYWNoZURpciB3YXMgcGFzc2VkIGluLCBwYXNzIGl0IGFsb25nLiBPdGhlcndpc2UsIGRlZmF1bHQgdG8gYSB0ZW1wZGlyLlxyXG4gICAgY29uc3QgY2FjaGVQYXRoID0gY2FjaGVEaXIgPyByb290Q2FjaGVEaXIgOiBudWxsO1xyXG4gICAgY29uc3QgbWFwUGF0aCA9IHNvdXJjZU1hcFBhdGggPyBwYXRoLmpvaW4oYXBwUm9vdCwgc291cmNlTWFwUGF0aCkgOiBjYWNoZVBhdGg7XHJcbiAgICBjb21waWxlckhvc3QgPSBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3RTeW5jKGFwcFJvb3QsIGNhY2hlUGF0aCwgbWFwUGF0aCk7XHJcbiAgfVxyXG5cclxuICBpbml0aWFsaXplR2xvYmFsSG9va3MoY29tcGlsZXJIb3N0KTtcclxuICByZXF1aXJlLm1haW4ucmVxdWlyZShtYWluTW9kdWxlKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEge0BsaW5rIENvbXBpbGVySG9zdH0gd2l0aCB0aGUgZ2l2ZW4gaW5mb3JtYXRpb24uIFRoaXMgbWV0aG9kIGlzXHJcbiAqIHVzdWFsbHkgY2FsbGVkIGJ5IHtAbGluayBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3R9LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKGluZm8pIHtcclxuICBsZXQgY29tcGlsZXJzID0gY3JlYXRlQ29tcGlsZXJzKCk7XHJcbiAgbGV0IHJvb3RDYWNoZURpciA9IGluZm8ucm9vdENhY2hlRGlyIHx8IGNhbGN1bGF0ZURlZmF1bHRDb21waWxlQ2FjaGVEaXJlY3RvcnkoKTtcclxuICBjb25zdCBzb3VyY2VNYXBQYXRoID0gaW5mby5zb3VyY2VNYXBQYXRoIHx8IGluZm8ucm9vdENhY2hlRGlyO1xyXG5cclxuICBpZiAoaW5mby5zb3VyY2VNYXBQYXRoKSB7XHJcbiAgICBjcmVhdGVTb3VyY2VNYXBEaXJlY3Rvcnkoc291cmNlTWFwUGF0aCk7XHJcbiAgfVxyXG5cclxuICBkKGBDcmVhdGluZyBDb21waWxlckhvc3Q6ICR7SlNPTi5zdHJpbmdpZnkoaW5mbyl9LCByb290Q2FjaGVEaXIgPSAke3Jvb3RDYWNoZURpcn0sIHNvdXJjZU1hcFBhdGggPSAke3NvdXJjZU1hcFBhdGh9YCk7XHJcbiAgbGV0IGZpbGVDaGFuZ2VDYWNoZSA9IG5ldyBGaWxlQ2hhbmdlZENhY2hlKGluZm8uYXBwUm9vdCk7XHJcblxyXG4gIGxldCBjb21waWxlckluZm8gPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XHJcbiAgaWYgKGZzLmV4aXN0c1N5bmMoY29tcGlsZXJJbmZvKSkge1xyXG4gICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyhjb21waWxlckluZm8pO1xyXG4gICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKHpsaWIuZ3VuemlwU3luYyhidWYpKTtcclxuICAgIGZpbGVDaGFuZ2VDYWNoZSA9IEZpbGVDaGFuZ2VkQ2FjaGUubG9hZEZyb21EYXRhKGpzb24uZmlsZUNoYW5nZUNhY2hlLCBpbmZvLmFwcFJvb3QsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIE9iamVjdC5rZXlzKGluZm8ub3B0aW9ucyB8fCB7fSkuZm9yRWFjaCgoeCkgPT4ge1xyXG4gICAgbGV0IG9wdHMgPSBpbmZvLm9wdGlvbnNbeF07XHJcbiAgICBpZiAoISh4IGluIGNvbXBpbGVycykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBjb21waWxlciBzZXR0aW5ncyBmb3IgbWlzc2luZyBjb21waWxlcjogJHt4fWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5COiBMZXQncyBob3BlIHRoaXMgaXNuJ3QgYSB2YWxpZCBjb21waWxlciBvcHRpb24uLi5cclxuICAgIGlmIChvcHRzLnBhc3N0aHJvdWdoKSB7XHJcbiAgICAgIGNvbXBpbGVyc1t4XSA9IGNvbXBpbGVyc1sndGV4dC9wbGFpbiddO1xyXG4gICAgICBkZWxldGUgb3B0cy5wYXNzdGhyb3VnaDtcclxuICAgIH1cclxuXHJcbiAgICBkKGBTZXR0aW5nIG9wdGlvbnMgZm9yICR7eH06ICR7SlNPTi5zdHJpbmdpZnkob3B0cyl9YCk7XHJcbiAgICBjb21waWxlcnNbeF0uY29tcGlsZXJPcHRpb25zID0gb3B0cztcclxuICB9KTtcclxuXHJcbiAgbGV0IHJldCA9IG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnMsIGZpbGVDaGFuZ2VDYWNoZSwgZmFsc2UsIGNvbXBpbGVyc1sndGV4dC9wbGFpbiddKTtcclxuXHJcbiAgLy8gTkI6IEl0J3Mgc3VwZXIgaW1wb3J0YW50IHRoYXQgd2UgZ3VhcmFudGVlIHRoYXQgdGhlIGNvbmZpZ3VyYXRpb24gaXMgc2F2ZWRcclxuICAvLyBvdXQsIGJlY2F1c2Ugd2UnbGwgbmVlZCB0byByZS1yZWFkIGl0IGluIHRoZSByZW5kZXJlciBwcm9jZXNzXHJcbiAgZChgQ3JlYXRlZCBjb21waWxlciBob3N0IHdpdGggb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeShpbmZvKX1gKTtcclxuICByZXQuc2F2ZUNvbmZpZ3VyYXRpb25TeW5jKCk7XHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBjb21waWxlciBob3N0IGZyb20gYSAuYmFiZWxyYyBmaWxlLiBUaGlzIG1ldGhvZCBpcyB1c3VhbGx5IGNhbGxlZFxyXG4gKiBmcm9tIHtAbGluayBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3R9IGluc3RlYWQgb2YgdXNlZCBkaXJlY3RseS5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlICBUaGUgcGF0aCB0byBhIC5iYWJlbHJjIGZpbGVcclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgKG9wdGlvbmFsKSAgVGhlIGRpcmVjdG9yeSB0byB1c2UgYXMgYSBjYWNoZS5cclxuICpcclxuICogQHJldHVybiB7UHJvbWlzZTxDb21waWxlckhvc3Q+fSAgQSBzZXQtdXAgY29tcGlsZXIgaG9zdFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21CYWJlbFJjKGZpbGUsIHJvb3RDYWNoZURpcj1udWxsLCBzb3VyY2VNYXBQYXRoID0gbnVsbCkge1xyXG4gIGxldCBpbmZvID0gSlNPTi5wYXJzZShhd2FpdCBwZnMucmVhZEZpbGUoZmlsZSwgJ3V0ZjgnKSk7XHJcblxyXG4gIC8vIHBhY2thZ2UuanNvblxyXG4gIGlmICgnYmFiZWwnIGluIGluZm8pIHtcclxuICAgIGluZm8gPSBpbmZvLmJhYmVsO1xyXG4gIH1cclxuXHJcbiAgaWYgKCdlbnYnIGluIGluZm8pIHtcclxuICAgIGxldCBvdXJFbnYgPSBwcm9jZXNzLmVudi5CQUJFTF9FTlYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50JztcclxuICAgIGluZm8gPSBpbmZvLmVudltvdXJFbnZdO1xyXG4gIH1cclxuXHJcbiAgLy8gQXJlIHdlIHN0aWxsIHBhY2thZ2UuanNvbiAoaS5lLiBpcyB0aGVyZSBubyBiYWJlbCBpbmZvIHdoYXRzb2V2ZXI/KVxyXG4gIGlmICgnbmFtZScgaW4gaW5mbyAmJiAndmVyc2lvbicgaW4gaW5mbykge1xyXG4gICAgbGV0IGFwcFJvb3QgPSBwYXRoLmRpcm5hbWUoZmlsZSk7XHJcbiAgICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xyXG4gICAgICBhcHBSb290OiBhcHBSb290LFxyXG4gICAgICBvcHRpb25zOiBnZXREZWZhdWx0Q29uZmlndXJhdGlvbihhcHBSb290KSxcclxuICAgICAgcm9vdENhY2hlRGlyLFxyXG4gICAgICBzb3VyY2VNYXBQYXRoXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlndXJhdGlvbih7XHJcbiAgICBhcHBSb290OiBwYXRoLmRpcm5hbWUoZmlsZSksXHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JzogaW5mb1xyXG4gICAgfSxcclxuICAgIHJvb3RDYWNoZURpcixcclxuICAgIHNvdXJjZU1hcFBhdGhcclxuICB9KTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY29tcGlsZXIgaG9zdCBmcm9tIGEgLmNvbXBpbGVyYyBmaWxlLiBUaGlzIG1ldGhvZCBpcyB1c3VhbGx5IGNhbGxlZFxyXG4gKiBmcm9tIHtAbGluayBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3R9IGluc3RlYWQgb2YgdXNlZCBkaXJlY3RseS5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlICBUaGUgcGF0aCB0byBhIC5jb21waWxlcmMgZmlsZVxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAob3B0aW9uYWwpICBUaGUgZGlyZWN0b3J5IHRvIHVzZSBhcyBhIGNhY2hlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtQcm9taXNlPENvbXBpbGVySG9zdD59ICBBIHNldC11cCBjb21waWxlciBob3N0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ0ZpbGUoZmlsZSwgcm9vdENhY2hlRGlyPW51bGwsIHNvdXJjZU1hcFBhdGggPSBudWxsKSB7XHJcbiAgbGV0IGluZm8gPSBKU09OLnBhcnNlKGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlLCAndXRmOCcpKTtcclxuXHJcbiAgaWYgKCdlbnYnIGluIGluZm8pIHtcclxuICAgIGxldCBvdXJFbnYgPSBwcm9jZXNzLmVudi5FTEVDVFJPTl9DT01QSUxFX0VOViB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnO1xyXG4gICAgaW5mbyA9IGluZm8uZW52W291ckVudl07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xyXG4gICAgYXBwUm9vdDogcGF0aC5kaXJuYW1lKGZpbGUpLFxyXG4gICAgb3B0aW9uczogaW5mbyxcclxuICAgIHJvb3RDYWNoZURpcixcclxuICAgIHNvdXJjZU1hcFBhdGhcclxuICB9KTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY29uZmlndXJlZCB7QGxpbmsgQ29tcGlsZXJIb3N0fSBpbnN0YW5jZSBmcm9tIHRoZSBwcm9qZWN0IHJvb3RcclxuICogZGlyZWN0b3J5LiBUaGlzIG1ldGhvZCBmaXJzdCBzZWFyY2hlcyBmb3IgYSAuY29tcGlsZXJjIChvciAuY29tcGlsZXJjLmpzb24pLCB0aGVuIGZhbGxzIGJhY2sgdG8gdGhlXHJcbiAqIGRlZmF1bHQgbG9jYXRpb25zIGZvciBCYWJlbCBjb25maWd1cmF0aW9uIGluZm8uIElmIG5laXRoZXIgYXJlIGZvdW5kLCBkZWZhdWx0c1xyXG4gKiB0byBzdGFuZGFyZCBzZXR0aW5nc1xyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3REaXIgIFRoZSByb290IGFwcGxpY2F0aW9uIGRpcmVjdG9yeSAoaS5lLiB0aGUgZGlyZWN0b3J5XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBoYXMgdGhlIGFwcCdzIHBhY2thZ2UuanNvbilcclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgKG9wdGlvbmFsKSAgVGhlIGRpcmVjdG9yeSB0byB1c2UgYXMgYSBjYWNoZS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZU1hcFBhdGggKG9wdGlvbmFsKSBUaGUgZGlyZWN0b3J5IHRvIHN0b3JlIHNvdXJjZW1hcCBzZXBhcmF0ZWx5XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGNvbXBpbGVyIG9wdGlvbiBlbmFibGVkIHRvIGVtaXQuXHJcbiAqXHJcbiAqIEByZXR1cm4ge1Byb21pc2U8Q29tcGlsZXJIb3N0Pn0gIEEgc2V0LXVwIGNvbXBpbGVyIGhvc3RcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3Qocm9vdERpciwgcm9vdENhY2hlRGlyID0gbnVsbCwgc291cmNlTWFwUGF0aCA9IG51bGwpIHtcclxuICBsZXQgY29tcGlsZXJjID0gcGF0aC5qb2luKHJvb3REaXIsICcuY29tcGlsZXJjJyk7XHJcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oY29tcGlsZXJjKSkge1xyXG4gICAgZChgRm91bmQgYSAuY29tcGlsZXJjIGF0ICR7Y29tcGlsZXJjfSwgdXNpbmcgaXRgKTtcclxuICAgIHJldHVybiBhd2FpdCBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlnRmlsZShjb21waWxlcmMsIHJvb3RDYWNoZURpciwgc291cmNlTWFwUGF0aCk7XHJcbiAgfVxyXG4gIGNvbXBpbGVyYyArPSAnLmpzb24nO1xyXG4gIGlmIChzdGF0U3luY05vRXhjZXB0aW9uKGNvbXBpbGVyYykpIHtcclxuICAgIGQoYEZvdW5kIGEgLmNvbXBpbGVyYyBhdCAke2NvbXBpbGVyY30sIHVzaW5nIGl0YCk7XHJcbiAgICByZXR1cm4gYXdhaXQgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ0ZpbGUoY29tcGlsZXJjLCByb290Q2FjaGVEaXIsIHNvdXJjZU1hcFBhdGgpO1xyXG4gIH1cclxuXHJcbiAgbGV0IGJhYmVscmMgPSBwYXRoLmpvaW4ocm9vdERpciwgJy5iYWJlbHJjJyk7XHJcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oYmFiZWxyYykpIHtcclxuICAgIGQoYEZvdW5kIGEgLmJhYmVscmMgYXQgJHtiYWJlbHJjfSwgdXNpbmcgaXRgKTtcclxuICAgIHJldHVybiBhd2FpdCBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSYyhiYWJlbHJjLCByb290Q2FjaGVEaXIsIHNvdXJjZU1hcFBhdGgpO1xyXG4gIH1cclxuXHJcbiAgZChgVXNpbmcgcGFja2FnZS5qc29uIG9yIGRlZmF1bHQgcGFyYW1ldGVycyBhdCAke3Jvb3REaXJ9YCk7XHJcbiAgcmV0dXJuIGF3YWl0IGNyZWF0ZUNvbXBpbGVySG9zdEZyb21CYWJlbFJjKHBhdGguam9pbihyb290RGlyLCAncGFja2FnZS5qc29uJyksIHJvb3RDYWNoZURpciwgc291cmNlTWFwUGF0aCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSY1N5bmMoZmlsZSwgcm9vdENhY2hlRGlyPW51bGwsIHNvdXJjZU1hcFBhdGggPSBudWxsKSB7XHJcbiAgbGV0IGluZm8gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpKTtcclxuXHJcbiAgLy8gcGFja2FnZS5qc29uXHJcbiAgaWYgKCdiYWJlbCcgaW4gaW5mbykge1xyXG4gICAgaW5mbyA9IGluZm8uYmFiZWw7XHJcbiAgfVxyXG5cclxuICBpZiAoJ2VudicgaW4gaW5mbykge1xyXG4gICAgbGV0IG91ckVudiA9IHByb2Nlc3MuZW52LkJBQkVMX0VOViB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnO1xyXG4gICAgaW5mbyA9IGluZm8uZW52W291ckVudl07XHJcbiAgfVxyXG5cclxuICAvLyBBcmUgd2Ugc3RpbGwgcGFja2FnZS5qc29uIChpLmUuIGlzIHRoZXJlIG5vIGJhYmVsIGluZm8gd2hhdHNvZXZlcj8pXHJcbiAgaWYgKCduYW1lJyBpbiBpbmZvICYmICd2ZXJzaW9uJyBpbiBpbmZvKSB7XHJcbiAgICBsZXQgYXBwUm9vdCA9IHBhdGguZGlybmFtZShmaWxlKVxyXG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKHtcclxuICAgICAgYXBwUm9vdDogYXBwUm9vdCxcclxuICAgICAgb3B0aW9uczogZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oYXBwUm9vdCksXHJcbiAgICAgIHJvb3RDYWNoZURpcixcclxuICAgICAgc291cmNlTWFwUGF0aFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xyXG4gICAgYXBwUm9vdDogcGF0aC5kaXJuYW1lKGZpbGUpLFxyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6IGluZm9cclxuICAgIH0sXHJcbiAgICByb290Q2FjaGVEaXIsXHJcbiAgICBzb3VyY2VNYXBQYXRoXHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlnRmlsZVN5bmMoZmlsZSwgcm9vdENhY2hlRGlyPW51bGwsIHNvdXJjZU1hcFBhdGggPSBudWxsKSB7XHJcbiAgbGV0IGluZm8gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpKTtcclxuXHJcbiAgaWYgKCdlbnYnIGluIGluZm8pIHtcclxuICAgIGxldCBvdXJFbnYgPSBwcm9jZXNzLmVudi5FTEVDVFJPTl9DT01QSUxFX0VOViB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnO1xyXG4gICAgaW5mbyA9IGluZm8uZW52W291ckVudl07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xyXG4gICAgYXBwUm9vdDogcGF0aC5kaXJuYW1lKGZpbGUpLFxyXG4gICAgb3B0aW9uczogaW5mbyxcclxuICAgIHJvb3RDYWNoZURpcixcclxuICAgIHNvdXJjZU1hcFBhdGhcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Qcm9qZWN0Um9vdFN5bmMocm9vdERpciwgcm9vdENhY2hlRGlyID0gbnVsbCwgc291cmNlTWFwUGF0aCA9IG51bGwpIHtcclxuICBsZXQgY29tcGlsZXJjID0gcGF0aC5qb2luKHJvb3REaXIsICcuY29tcGlsZXJjJyk7XHJcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oY29tcGlsZXJjKSkge1xyXG4gICAgZChgRm91bmQgYSAuY29tcGlsZXJjIGF0ICR7Y29tcGlsZXJjfSwgdXNpbmcgaXRgKTtcclxuICAgIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlnRmlsZVN5bmMoY29tcGlsZXJjLCByb290Q2FjaGVEaXIsIHNvdXJjZU1hcFBhdGgpO1xyXG4gIH1cclxuXHJcbiAgbGV0IGJhYmVscmMgPSBwYXRoLmpvaW4ocm9vdERpciwgJy5iYWJlbHJjJyk7XHJcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oYmFiZWxyYykpIHtcclxuICAgIGQoYEZvdW5kIGEgLmJhYmVscmMgYXQgJHtiYWJlbHJjfSwgdXNpbmcgaXRgKTtcclxuICAgIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSY1N5bmMoYmFiZWxyYywgcm9vdENhY2hlRGlyLCBzb3VyY2VNYXBQYXRoKTtcclxuICB9XHJcblxyXG4gIGQoYFVzaW5nIHBhY2thZ2UuanNvbiBvciBkZWZhdWx0IHBhcmFtZXRlcnMgYXQgJHtyb290RGlyfWApO1xyXG4gIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSY1N5bmMocGF0aC5qb2luKHJvb3REaXIsICdwYWNrYWdlLmpzb24nKSwgcm9vdENhY2hlRGlyLCBzb3VyY2VNYXBQYXRoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgd2hhdCBlbGVjdHJvbi1jb21waWxlIHdvdWxkIHVzZSBhcyBhIGRlZmF1bHQgcm9vdENhY2hlRGlyLiBVc3VhbGx5IG9ubHlcclxuICogdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXHJcbiAqXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gIEEgcGF0aCB0aGF0IG1heSBvciBtYXkgbm90IGV4aXN0IHdoZXJlIGVsZWN0cm9uLWNvbXBpbGUgd291bGRcclxuICogICAgICAgICAgICAgICAgICAgc2V0IHVwIGEgZGV2ZWxvcG1lbnQgbW9kZSBjYWNoZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEZWZhdWx0Q29tcGlsZUNhY2hlRGlyZWN0b3J5KCkge1xyXG4gIGxldCB0bXBEaXIgPSBwcm9jZXNzLmVudi5URU1QIHx8IHByb2Nlc3MuZW52LlRNUERJUiB8fCAnL3RtcCc7XHJcbiAgbGV0IGhhc2ggPSByZXF1aXJlKCdjcnlwdG8nKS5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUocHJvY2Vzcy5leGVjUGF0aCkuZGlnZXN0KCdoZXgnKTtcclxuXHJcbiAgbGV0IGNhY2hlRGlyID0gcGF0aC5qb2luKHRtcERpciwgYGNvbXBpbGVDYWNoZV8ke2hhc2h9YCk7XHJcbiAgbWtkaXJwLnN5bmMoY2FjaGVEaXIpO1xyXG5cclxuICBkKGBVc2luZyBkZWZhdWx0IGNhY2hlIGRpcmVjdG9yeTogJHtjYWNoZURpcn1gKTtcclxuICByZXR1cm4gY2FjaGVEaXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVNvdXJjZU1hcERpcmVjdG9yeShzb3VyY2VNYXBQYXRoKSB7XHJcbiAgbWtkaXJwLnN5bmMoc291cmNlTWFwUGF0aCk7XHJcbiAgZChgVXNpbmcgc2VwYXJhdGUgc291cmNlbWFwIHBhdGggYXQgJHtzb3VyY2VNYXBQYXRofWApO1xyXG59XHJcblxyXG5mdW5jdGlvbiB2ZXJzaW9uVG9GbG9hdCh2ZXIpIHtcclxuICByZXR1cm4gcGFyc2VGbG9hdCh2ZXIucmVwbGFjZSgvXihbXlxcLl1cXC5bXlxcLl0pXFwuLiokLywgJyQxJykpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFbGVjdHJvblZlcnNpb24ocm9vdERpcikge1xyXG4gIGlmIChwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uKSB7XHJcbiAgICByZXR1cm4gdmVyc2lvblRvRmxvYXQocHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbik7XHJcbiAgfVxyXG5cclxuICBsZXQgb3VyUGtnSnNvbiA9IHJlcXVpcmUocGF0aC5qb2luKHJvb3REaXIsICdwYWNrYWdlLmpzb24nKSk7XHJcblxyXG4gIGxldCB2ZXJzaW9uID0gWydlbGVjdHJvbi1wcmVidWlsdC1jb21waWxlJywgJ2VsZWN0cm9uJ10ubWFwKG1vZCA9PiB7XHJcbiAgICBpZiAob3VyUGtnSnNvbi5kZXZEZXBlbmRlbmNpZXMgJiYgb3VyUGtnSnNvbi5kZXZEZXBlbmRlbmNpZXNbbW9kXSkge1xyXG4gICAgICAvLyBOQjogbG9sIHRoaXMgY29kZVxyXG4gICAgICBsZXQgdmVyUmFuZ2UgPSBvdXJQa2dKc29uLmRldkRlcGVuZGVuY2llc1ttb2RdO1xyXG4gICAgICBsZXQgbSA9IHZlclJhbmdlLm1hdGNoKC8oXFxkK1xcLlxcZCtcXC5cXGQrKS8pO1xyXG4gICAgICBpZiAobSAmJiBtWzFdKSByZXR1cm4gbVsxXTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gcHJvY2Vzcy5tYWluTW9kdWxlLnJlcXVpcmUoYCR7bW9kfS9wYWNrYWdlLmpzb25gKS52ZXJzaW9uO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBOQjogVGhpcyB1c3VhbGx5IGRvZXNuJ3Qgd29yaywgYnV0IHNvbWV0aW1lcyBtYXliZT9cclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBsZXQgcCA9IHBhdGguam9pbihyb290RGlyLCBtb2QsICdwYWNrYWdlLmpzb24nKTtcclxuICAgICAgcmV0dXJuIHJlcXVpcmUocCkudmVyc2lvbjtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfSkuZmluZCh4ID0+ICEheCk7XHJcblxyXG4gIGlmICghdmVyc2lvbikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXV0b21hdGljYWxseSBkaXNjb3ZlciB0aGUgdmVyc2lvbiBvZiBFbGVjdHJvbiwgeW91IHByb2JhYmx5IG5lZWQgYSAuY29tcGlsZXJjIGZpbGVcIik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdmVyc2lvblRvRmxvYXQodmVyc2lvbik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IC5jb25maWdyYyBpZiBubyBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZC5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAgQSBsaXN0IG9mIGRlZmF1bHQgY29uZmlnIHNldHRpbmdzIGZvciBlbGVjdHJvbi1jb21waWxlci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0Q29uZmlndXJhdGlvbihyb290RGlyKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0Jzoge1xyXG4gICAgICBcInByZXNldHNcIjogW1xyXG4gICAgICAgIFtcImVudlwiLCB7XHJcbiAgICAgICAgICBcInRhcmdldHNcIjoge1xyXG4gICAgICAgICAgICBcImVsZWN0cm9uXCI6IGdldEVsZWN0cm9uVmVyc2lvbihyb290RGlyKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1dLFxyXG4gICAgICAgIFwicmVhY3RcIlxyXG4gICAgICBdLFxyXG4gICAgICBcInNvdXJjZU1hcHNcIjogXCJpbmxpbmVcIlxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgeW91IHRvIGNyZWF0ZSBuZXcgaW5zdGFuY2VzIG9mIGFsbCBjb21waWxlcnMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5XHJcbiAqIGVsZWN0cm9uLWNvbXBpbGUgYW5kIHVzZSB0aGVtIGRpcmVjdGx5LiBDdXJyZW50bHkgc3VwcG9ydHMgQmFiZWwsIENvZmZlZVNjcmlwdCxcclxuICogVHlwZVNjcmlwdCwgTGVzcywgYW5kIEphZGUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gIEFuIE9iamVjdCB3aG9zZSBLZXlzIGFyZSBNSU1FIHR5cGVzLCBhbmQgd2hvc2UgdmFsdWVzXHJcbiAqIGFyZSBpbnN0YW5jZXMgb2YgQHtsaW5rIENvbXBpbGVyQmFzZX0uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJzKCkge1xyXG4gIGlmICghYWxsQ29tcGlsZXJDbGFzc2VzKSB7XHJcbiAgICAvLyBGaXJzdCB3ZSB3YW50IHRvIHNlZSBpZiBlbGVjdHJvbi1jb21waWxlcnMgaXRzZWxmIGhhcyBiZWVuIGluc3RhbGxlZCB3aXRoXHJcbiAgICAvLyBkZXZEZXBlbmRlbmNpZXMuIElmIHRoYXQncyBub3QgdGhlIGNhc2UsIGNoZWNrIHRvIHNlZSBpZlxyXG4gICAgLy8gZWxlY3Ryb24tY29tcGlsZXJzIGlzIGluc3RhbGxlZCBhcyBhIHBlZXIgZGVwZW5kZW5jeSAocHJvYmFibHkgYXMgYVxyXG4gICAgLy8gZGV2RGVwZW5kZW5jeSBvZiB0aGUgcm9vdCBwcm9qZWN0KS5cclxuICAgIGNvbnN0IGxvY2F0aW9ucyA9IFsnZWxlY3Ryb24tY29tcGlsZXJzJywgJy4uLy4uL2VsZWN0cm9uLWNvbXBpbGVycyddO1xyXG5cclxuICAgIGZvciAobGV0IGxvY2F0aW9uIG9mIGxvY2F0aW9ucykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGFsbENvbXBpbGVyQ2xhc3NlcyA9IHJlcXVpcmUobG9jYXRpb24pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gWW9sb1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFhbGxDb21waWxlckNsYXNzZXMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlY3Ryb24gY29tcGlsZXJzIG5vdCBmb3VuZCBidXQgd2VyZSByZXF1ZXN0ZWQgdG8gYmUgbG9hZGVkXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTkI6IE5vdGUgdGhhdCB0aGlzIGNvZGUgaXMgY2FyZWZ1bGx5IHNldCB1cCBzbyB0aGF0IElubGluZUh0bWxDb21waWxlclxyXG4gIC8vIChpLmUuIGNsYXNzZXMgd2l0aCBgY3JlYXRlRnJvbUNvbXBpbGVyc2ApIGluaXRpYWxseSBnZXQgYW4gZW1wdHkgb2JqZWN0LFxyXG4gIC8vIGJ1dCB3aWxsIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGZpbmFsIHJlc3VsdCBvZiB3aGF0IHdlIHJldHVybiwgd2hpY2hcclxuICAvLyByZXNvbHZlcyB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeSB3ZSdkIG90aGVyd2lzZSBoYXZlIGhlcmUuXHJcbiAgbGV0IHJldCA9IHt9O1xyXG4gIGxldCBpbnN0YW50aWF0ZWRDbGFzc2VzID0gYWxsQ29tcGlsZXJDbGFzc2VzLm1hcCgoS2xhc3MpID0+IHtcclxuICAgIGlmICgnY3JlYXRlRnJvbUNvbXBpbGVycycgaW4gS2xhc3MpIHtcclxuICAgICAgcmV0dXJuIEtsYXNzLmNyZWF0ZUZyb21Db21waWxlcnMocmV0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBuZXcgS2xhc3MoKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgaW5zdGFudGlhdGVkQ2xhc3Nlcy5yZWR1Y2UoKGFjYyx4KSA9PiB7XHJcbiAgICBsZXQgS2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkuY29uc3RydWN0b3I7XHJcblxyXG4gICAgZm9yIChsZXQgdHlwZSBvZiBLbGFzcy5nZXRJbnB1dE1pbWVUeXBlcygpKSB7IGFjY1t0eXBlXSA9IHg7IH1cclxuICAgIHJldHVybiBhY2M7XHJcbiAgfSwgcmV0KTtcclxuXHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG4iXX0=","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/promise.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pzlib = exports.pfs = undefined;\n\nvar _pify = require('pify');\n\nvar _pify2 = _interopRequireDefault(_pify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// NB: We do this so that every module doesn't have to run pify\n// on fs and zlib\n\n\n/**\r\n * @private\r\n */\nconst pfs = exports.pfs = (0, _pify2.default)(require('fs'));\n\n/**\r\n * @private\r\n */\nconst pzlib = exports.pzlib = (0, _pify2.default)(require('zlib'));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm9taXNlLmpzIl0sIm5hbWVzIjpbInBmcyIsInJlcXVpcmUiLCJwemxpYiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7QUFFQTtBQUNBOzs7QUFHQTs7O0FBR08sTUFBTUEsb0JBQU0sb0JBQUtDLFFBQVEsSUFBUixDQUFMLENBQVo7O0FBRVA7OztBQUdPLE1BQU1DLHdCQUFRLG9CQUFLRCxRQUFRLE1BQVIsQ0FBTCxDQUFkIiwiZmlsZSI6InByb21pc2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGlmeSBmcm9tICdwaWZ5JztcclxuXHJcbi8vIE5COiBXZSBkbyB0aGlzIHNvIHRoYXQgZXZlcnkgbW9kdWxlIGRvZXNuJ3QgaGF2ZSB0byBydW4gcGlmeVxyXG4vLyBvbiBmcyBhbmQgemxpYlxyXG5cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi8gXHJcbmV4cG9ydCBjb25zdCBwZnMgPSBwaWZ5KHJlcXVpcmUoJ2ZzJykpO1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqLyBcclxuZXhwb3J0IGNvbnN0IHB6bGliID0gcGlmeShyZXF1aXJlKCd6bGliJykpO1xyXG4iXX0=","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/file-change-cache.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _zlib = require('zlib');\n\nvar _zlib2 = _interopRequireDefault(_zlib);\n\nvar _crypto = require('crypto');\n\nvar _crypto2 = _interopRequireDefault(_crypto);\n\nvar _promise = require('./promise');\n\nvar _sanitizePaths = require('./sanitize-paths');\n\nvar _sanitizePaths2 = _interopRequireDefault(_sanitizePaths);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst d = require('debug')('electron-compile:file-change-cache');\n\n/**\n * This class caches information about files and determines whether they have\n * changed contents or not. Most importantly, this class caches the hash of seen\n * files so that at development time, we don't have to recalculate them constantly.\n *\n * This class is also the core of how electron-compile runs quickly in production\n * mode - after precompilation, the cache is serialized along with the rest of the\n * data in {@link CompilerHost}, so that when we load the app in production mode,\n * we don't end up calculating hashes of file content at all, only using the contents\n * of this cache.\n */\nclass FileChangedCache {\n  constructor(appRoot) {\n    let failOnCacheMiss = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    this.appRoot = (0, _sanitizePaths2.default)(appRoot);\n\n    this.failOnCacheMiss = failOnCacheMiss;\n    this.changeCache = {};\n  }\n\n  static removePrefix(needle, haystack) {\n    let idx = haystack.toLowerCase().indexOf(needle.toLowerCase());\n    if (idx < 0) return haystack;\n\n    return haystack.substring(idx + needle.length);\n  }\n\n  /**\n   * Allows you to create a FileChangedCache from serialized data saved from\n   * {@link getSavedData}.\n   *\n   * @param  {Object} data  Saved data from getSavedData.\n   *\n   * @param  {string} appRoot  The top-level directory for your application (i.e.\n   *                           the one which has your package.json).\n   *\n   * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.\n   *\n   * @return {FileChangedCache}\n   */\n  static loadFromData(data, appRoot) {\n    let failOnCacheMiss = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    let ret = new FileChangedCache(appRoot, failOnCacheMiss);\n    ret.changeCache = data.changeCache;\n    ret.originalAppRoot = data.appRoot;\n\n    return ret;\n  }\n\n  /**\n   * Allows you to create a FileChangedCache from serialized data saved from\n   * {@link save}.\n   *\n   * @param  {string} file  Saved data from save.\n   *\n   * @param  {string} appRoot  The top-level directory for your application (i.e.\n   *                           the one which has your package.json).\n   *\n   * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.\n   *\n   * @return {Promise<FileChangedCache>}\n   */\n  static loadFromFile(file, appRoot) {\n    let failOnCacheMiss = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return _asyncToGenerator(function* () {\n      d(`Loading canned FileChangedCache from ${file}`);\n\n      let buf = yield _promise.pfs.readFile(file);\n      return FileChangedCache.loadFromData(JSON.parse((yield _promise.pzlib.gunzip(buf))), appRoot, failOnCacheMiss);\n    })();\n  }\n\n  /**\n   * Returns information about a given file, including its hash. This method is\n   * the main method for this cache.\n   *\n   * @param  {string} absoluteFilePath  The path to a file to retrieve info on.\n   *\n   * @return {Promise<Object>}\n   *\n   * @property {string} hash  The SHA1 hash of the file\n   * @property {boolean} isMinified  True if the file is minified\n   * @property {boolean} isInNodeModules  True if the file is in a library directory\n   * @property {boolean} hasSourceMap  True if the file has a source map\n   * @property {boolean} isFileBinary  True if the file is not a text file\n   * @property {Buffer} binaryData (optional)  The buffer that was read if the file\n   *                                           was binary and there was a cache miss.\n   * @property {string} code (optional)  The string that was read if the file\n   *                                     was text and there was a cache miss\n   */\n  getHashForPath(absoluteFilePath) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _getCacheEntryForPath = _this.getCacheEntryForPath(absoluteFilePath);\n\n      let cacheEntry = _getCacheEntryForPath.cacheEntry,\n          cacheKey = _getCacheEntryForPath.cacheKey;\n\n\n      if (_this.failOnCacheMiss) {\n        return cacheEntry.info;\n      }\n\n      var _ref = yield _this.getInfoForCacheEntry(absoluteFilePath);\n\n      let ctime = _ref.ctime,\n          size = _ref.size;\n\n\n      if (cacheEntry) {\n        let fileHasChanged = yield _this.hasFileChanged(absoluteFilePath, cacheEntry, { ctime, size });\n\n        if (!fileHasChanged) {\n          return cacheEntry.info;\n        }\n\n        d(`Invalidating cache entry: ${cacheEntry.ctime} === ${ctime} && ${cacheEntry.size} === ${size}`);\n        delete _this.changeCache.cacheEntry;\n      }\n\n      var _ref2 = yield _this.calculateHashForFile(absoluteFilePath);\n\n      let digest = _ref2.digest,\n          sourceCode = _ref2.sourceCode,\n          binaryData = _ref2.binaryData;\n\n\n      let info = {\n        hash: digest,\n        isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),\n        isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),\n        hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),\n        isFileBinary: !!binaryData\n      };\n\n      _this.changeCache[cacheKey] = { ctime, size, info };\n      d(`Cache entry for ${cacheKey}: ${JSON.stringify(_this.changeCache[cacheKey])}`);\n\n      if (binaryData) {\n        return Object.assign({ binaryData }, info);\n      } else {\n        return Object.assign({ sourceCode }, info);\n      }\n    })();\n  }\n\n  getInfoForCacheEntry(absoluteFilePath) {\n    return _asyncToGenerator(function* () {\n      let stat = yield _promise.pfs.stat(absoluteFilePath);\n      if (!stat || !stat.isFile()) throw new Error(`Can't stat ${absoluteFilePath}`);\n\n      return {\n        stat,\n        ctime: stat.ctime.getTime(),\n        size: stat.size\n      };\n    })();\n  }\n\n  /**\n   * Gets the cached data for a file path, if it exists.\n   *\n   * @param  {string} absoluteFilePath  The path to a file to retrieve info on.\n   *\n   * @return {Object}\n   */\n  getCacheEntryForPath(absoluteFilePath) {\n    let cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);\n    if (this.appRoot) {\n      cacheKey = cacheKey.replace(this.appRoot, '');\n    }\n\n    // NB: We do this because x-require will include an absolute path from the\n    // original built app and we need to still grok it\n    if (this.originalAppRoot) {\n      cacheKey = cacheKey.replace(this.originalAppRoot, '');\n    }\n\n    let cacheEntry = this.changeCache[cacheKey];\n\n    if (this.failOnCacheMiss) {\n      if (!cacheEntry) {\n        d(`Tried to read file cache entry for ${absoluteFilePath}`);\n        d(`cacheKey: ${cacheKey}, appRoot: ${this.appRoot}, originalAppRoot: ${this.originalAppRoot}`);\n        throw new Error(`Asked for ${absoluteFilePath} but it was not precompiled!`);\n      }\n    }\n\n    return { cacheEntry, cacheKey };\n  }\n\n  /**\n   * Checks the file cache to see if a file has changed.\n   *\n   * @param  {string} absoluteFilePath  The path to a file to retrieve info on.\n   * @param  {Object} cacheEntry  Cache data from {@link getCacheEntryForPath}\n   *\n   * @return {boolean}\n   */\n  hasFileChanged(absoluteFilePath) {\n    var _this2 = this;\n\n    let cacheEntry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let fileHashInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return _asyncToGenerator(function* () {\n      cacheEntry = cacheEntry || _this2.getCacheEntryForPath(absoluteFilePath).cacheEntry;\n      fileHashInfo = fileHashInfo || (yield _this2.getInfoForCacheEntry(absoluteFilePath));\n\n      if (cacheEntry) {\n        return !(cacheEntry.ctime >= fileHashInfo.ctime && cacheEntry.size === fileHashInfo.size);\n      }\n\n      return false;\n    })();\n  }\n\n  /**\n   * Returns data that can passed to {@link loadFromData} to rehydrate this cache.\n   *\n   * @return {Object}\n   */\n  getSavedData() {\n    return { changeCache: this.changeCache, appRoot: this.appRoot };\n  }\n\n  /**\n   * Serializes this object's data to a file.\n   *\n   * @param {string} filePath  The path to save data to.\n   *\n   * @return {Promise} Completion.\n   */\n  save(filePath) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let toSave = _this3.getSavedData();\n\n      let buf = yield _promise.pzlib.gzip(new Buffer(JSON.stringify(toSave)));\n      yield _promise.pfs.writeFile(filePath, buf);\n    })();\n  }\n\n  calculateHashForFile(absoluteFilePath) {\n    return _asyncToGenerator(function* () {\n      let buf = yield _promise.pfs.readFile(absoluteFilePath);\n      let encoding = FileChangedCache.detectFileEncoding(buf);\n\n      if (!encoding) {\n        let digest = _crypto2.default.createHash('sha1').update(buf).digest('hex');\n        return { sourceCode: null, digest, binaryData: buf };\n      }\n\n      let sourceCode = yield _promise.pfs.readFile(absoluteFilePath, encoding);\n      let digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');\n\n      return { sourceCode, digest, binaryData: null };\n    })();\n  }\n\n  getHashForPathSync(absoluteFilePath) {\n    let cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);\n\n    if (this.appRoot) {\n      cacheKey = FileChangedCache.removePrefix(this.appRoot, cacheKey);\n    }\n\n    // NB: We do this because x-require will include an absolute path from the\n    // original built app and we need to still grok it\n    if (this.originalAppRoot) {\n      cacheKey = FileChangedCache.removePrefix(this.originalAppRoot, cacheKey);\n    }\n\n    let cacheEntry = this.changeCache[cacheKey];\n\n    if (this.failOnCacheMiss) {\n      if (!cacheEntry) {\n        d(`Tried to read file cache entry for ${absoluteFilePath}`);\n        d(`cacheKey: ${cacheKey}, appRoot: ${this.appRoot}, originalAppRoot: ${this.originalAppRoot}`);\n        throw new Error(`Asked for ${absoluteFilePath} but it was not precompiled!`);\n      }\n\n      return cacheEntry.info;\n    }\n\n    let stat = _fs2.default.statSync(absoluteFilePath);\n    let ctime = stat.ctime.getTime();\n    let size = stat.size;\n    if (!stat || !stat.isFile()) throw new Error(`Can't stat ${absoluteFilePath}`);\n\n    if (cacheEntry) {\n      if (cacheEntry.ctime >= ctime && cacheEntry.size === size) {\n        return cacheEntry.info;\n      }\n\n      d(`Invalidating cache entry: ${cacheEntry.ctime} === ${ctime} && ${cacheEntry.size} === ${size}`);\n      delete this.changeCache.cacheEntry;\n    }\n\n    var _calculateHashForFile = this.calculateHashForFileSync(absoluteFilePath);\n\n    let digest = _calculateHashForFile.digest,\n        sourceCode = _calculateHashForFile.sourceCode,\n        binaryData = _calculateHashForFile.binaryData;\n\n\n    let info = {\n      hash: digest,\n      isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),\n      isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),\n      hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),\n      isFileBinary: !!binaryData\n    };\n\n    this.changeCache[cacheKey] = { ctime, size, info };\n    d(`Cache entry for ${cacheKey}: ${JSON.stringify(this.changeCache[cacheKey])}`);\n\n    if (binaryData) {\n      return Object.assign({ binaryData }, info);\n    } else {\n      return Object.assign({ sourceCode }, info);\n    }\n  }\n\n  saveSync(filePath) {\n    let toSave = this.getSavedData();\n\n    let buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify(toSave)));\n    _fs2.default.writeFileSync(filePath, buf);\n  }\n\n  calculateHashForFileSync(absoluteFilePath) {\n    let buf = _fs2.default.readFileSync(absoluteFilePath);\n    let encoding = FileChangedCache.detectFileEncoding(buf);\n\n    if (!encoding) {\n      let digest = _crypto2.default.createHash('sha1').update(buf).digest('hex');\n      return { sourceCode: null, digest, binaryData: buf };\n    }\n\n    let sourceCode = _fs2.default.readFileSync(absoluteFilePath, encoding);\n    let digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');\n\n    return { sourceCode, digest, binaryData: null };\n  }\n\n  /**\n   * Determines via some statistics whether a file is likely to be minified.\n   *\n   * @private\n   */\n  static contentsAreMinified(source) {\n    let length = source.length;\n    if (length > 1024) length = 1024;\n\n    let newlineCount = 0;\n\n    // Roll through the characters and determine the average line length\n    for (let i = 0; i < source.length; i++) {\n      if (source[i] === '\\n') newlineCount++;\n    }\n\n    // No Newlines? Any file other than a super small one is minified\n    if (newlineCount === 0) {\n      return length > 80;\n    }\n\n    let avgLineLength = length / newlineCount;\n    return avgLineLength > 80;\n  }\n\n  /**\n   * Determines whether a path is in node_modules or the Electron init code\n   *\n   * @private\n   */\n  static isInNodeModules(filePath) {\n    return !!(filePath.match(/(node_modules|bower_components)[\\\\\\/]/i) || filePath.match(/(atom|electron)\\.asar/));\n  }\n\n  /**\n   * Returns whether a file has an inline source map\n   *\n   * @private\n   */\n  static hasSourceMap(sourceCode) {\n    const trimmed = sourceCode.trim();\n    return trimmed.lastIndexOf('//# sourceMap') > trimmed.lastIndexOf('\\n');\n  }\n\n  /**\n   * Determines the encoding of a file from the two most common encodings by trying\n   * to decode it then looking for encoding errors\n   *\n   * @private\n   */\n  static detectFileEncoding(buffer) {\n    if (buffer.length < 1) return false;\n    let buf = buffer.length < 4096 ? buffer : buffer.slice(0, 4096);\n\n    const encodings = ['utf8', 'utf16le'];\n\n    let encoding;\n    if (buffer.length <= 128) {\n      encoding = encodings.find(x => Buffer.compare(new Buffer(buffer.toString(), x), buffer) === 0);\n    } else {\n      encoding = encodings.find(x => !FileChangedCache.containsControlCharacters(buf.toString(x)));\n    }\n\n    return encoding;\n  }\n\n  /**\n   * Determines whether a string is likely to be poorly encoded by looking for\n   * control characters above a certain threshold\n   *\n   * @private\n   */\n  static containsControlCharacters(str) {\n    let controlCount = 0;\n    let spaceCount = 0;\n    let threshold = 2;\n    if (str.length > 64) threshold = 4;\n    if (str.length > 512) threshold = 8;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charCodeAt(i);\n      if (c === 65536 || c < 8) controlCount++;\n      if (c > 14 && c < 32) controlCount++;\n      if (c === 32) spaceCount++;\n\n      if (controlCount > threshold) return true;\n    }\n\n    if (spaceCount < threshold) return true;\n\n    if (controlCount === 0) return false;\n    return controlCount / str.length < 0.02;\n  }\n}\nexports.default = FileChangedCache;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maWxlLWNoYW5nZS1jYWNoZS5qcyJdLCJuYW1lcyI6WyJkIiwicmVxdWlyZSIsIkZpbGVDaGFuZ2VkQ2FjaGUiLCJjb25zdHJ1Y3RvciIsImFwcFJvb3QiLCJmYWlsT25DYWNoZU1pc3MiLCJjaGFuZ2VDYWNoZSIsInJlbW92ZVByZWZpeCIsIm5lZWRsZSIsImhheXN0YWNrIiwiaWR4IiwidG9Mb3dlckNhc2UiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwibG9hZEZyb21EYXRhIiwiZGF0YSIsInJldCIsIm9yaWdpbmFsQXBwUm9vdCIsImxvYWRGcm9tRmlsZSIsImZpbGUiLCJidWYiLCJyZWFkRmlsZSIsIkpTT04iLCJwYXJzZSIsImd1bnppcCIsImdldEhhc2hGb3JQYXRoIiwiYWJzb2x1dGVGaWxlUGF0aCIsImdldENhY2hlRW50cnlGb3JQYXRoIiwiY2FjaGVFbnRyeSIsImNhY2hlS2V5IiwiaW5mbyIsImdldEluZm9Gb3JDYWNoZUVudHJ5IiwiY3RpbWUiLCJzaXplIiwiZmlsZUhhc0NoYW5nZWQiLCJoYXNGaWxlQ2hhbmdlZCIsImNhbGN1bGF0ZUhhc2hGb3JGaWxlIiwiZGlnZXN0Iiwic291cmNlQ29kZSIsImJpbmFyeURhdGEiLCJoYXNoIiwiaXNNaW5pZmllZCIsImNvbnRlbnRzQXJlTWluaWZpZWQiLCJpc0luTm9kZU1vZHVsZXMiLCJoYXNTb3VyY2VNYXAiLCJpc0ZpbGVCaW5hcnkiLCJzdHJpbmdpZnkiLCJPYmplY3QiLCJhc3NpZ24iLCJzdGF0IiwiaXNGaWxlIiwiRXJyb3IiLCJnZXRUaW1lIiwicmVwbGFjZSIsImZpbGVIYXNoSW5mbyIsImdldFNhdmVkRGF0YSIsInNhdmUiLCJmaWxlUGF0aCIsInRvU2F2ZSIsImd6aXAiLCJCdWZmZXIiLCJ3cml0ZUZpbGUiLCJlbmNvZGluZyIsImRldGVjdEZpbGVFbmNvZGluZyIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJnZXRIYXNoRm9yUGF0aFN5bmMiLCJzdGF0U3luYyIsImNhbGN1bGF0ZUhhc2hGb3JGaWxlU3luYyIsInNhdmVTeW5jIiwiZ3ppcFN5bmMiLCJ3cml0ZUZpbGVTeW5jIiwicmVhZEZpbGVTeW5jIiwic291cmNlIiwibmV3bGluZUNvdW50IiwiaSIsImF2Z0xpbmVMZW5ndGgiLCJtYXRjaCIsInRyaW1tZWQiLCJ0cmltIiwibGFzdEluZGV4T2YiLCJidWZmZXIiLCJzbGljZSIsImVuY29kaW5ncyIsImZpbmQiLCJ4IiwiY29tcGFyZSIsInRvU3RyaW5nIiwiY29udGFpbnNDb250cm9sQ2hhcmFjdGVycyIsInN0ciIsImNvbnRyb2xDb3VudCIsInNwYWNlQ291bnQiLCJ0aHJlc2hvbGQiLCJjIiwiY2hhckNvZGVBdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBRUEsTUFBTUEsSUFBSUMsUUFBUSxPQUFSLEVBQWlCLG9DQUFqQixDQUFWOztBQUVBOzs7Ozs7Ozs7OztBQVdlLE1BQU1DLGdCQUFOLENBQXVCO0FBQ3BDQyxjQUFZQyxPQUFaLEVBQTRDO0FBQUEsUUFBdkJDLGVBQXVCLHVFQUFQLEtBQU87O0FBQzFDLFNBQUtELE9BQUwsR0FBZSw2QkFBaUJBLE9BQWpCLENBQWY7O0FBRUEsU0FBS0MsZUFBTCxHQUF1QkEsZUFBdkI7QUFDQSxTQUFLQyxXQUFMLEdBQW1CLEVBQW5CO0FBQ0Q7O0FBRUQsU0FBT0MsWUFBUCxDQUFvQkMsTUFBcEIsRUFBNEJDLFFBQTVCLEVBQXNDO0FBQ3BDLFFBQUlDLE1BQU1ELFNBQVNFLFdBQVQsR0FBdUJDLE9BQXZCLENBQStCSixPQUFPRyxXQUFQLEVBQS9CLENBQVY7QUFDQSxRQUFJRCxNQUFNLENBQVYsRUFBYSxPQUFPRCxRQUFQOztBQUViLFdBQU9BLFNBQVNJLFNBQVQsQ0FBbUJILE1BQU1GLE9BQU9NLE1BQWhDLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7OztBQWFBLFNBQU9DLFlBQVAsQ0FBb0JDLElBQXBCLEVBQTBCWixPQUExQixFQUF5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R0FBakIsRUFBc0IrRSxZQUFZLENBQVo7O0FBRXRCLFNBQUssSUFBSWpCLElBQUUsQ0FBWCxFQUFjQSxJQUFJYyxJQUFJNUUsTUFBdEIsRUFBOEI4RCxHQUE5QixFQUFtQztBQUNqQyxVQUFJa0IsSUFBSUosSUFBSUssVUFBSixDQUFlbkIsQ0FBZixDQUFSO0FBQ0EsVUFBSWtCLE1BQU0sS0FBTixJQUFlQSxJQUFJLENBQXZCLEVBQTBCSDtBQUMxQixVQUFJRyxJQUFJLEVBQUosSUFBVUEsSUFBSSxFQUFsQixFQUFzQkg7QUFDdEIsVUFBSUcsTUFBTSxFQUFWLEVBQWNGOztBQUVkLFVBQUlELGVBQWVFLFNBQW5CLEVBQThCLE9BQU8sSUFBUDtBQUMvQjs7QUFFRCxRQUFJRCxhQUFhQyxTQUFqQixFQUE0QixPQUFPLElBQVA7O0FBRTVCLFFBQUlGLGlCQUFpQixDQUFyQixFQUF3QixPQUFPLEtBQVA7QUFDeEIsV0FBUUEsZUFBZUQsSUFBSTVFLE1BQXBCLEdBQThCLElBQXJDO0FBQ0Q7QUExWW1DO2tCQUFqQlosZ0IiLCJmaWxlIjoiZmlsZS1jaGFuZ2UtY2FjaGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQge3BmcywgcHpsaWJ9IGZyb20gJy4vcHJvbWlzZSc7XG5pbXBvcnQgc2FuaXRpemVGaWxlUGF0aCBmcm9tICcuL3Nhbml0aXplLXBhdGhzJztcblxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6ZmlsZS1jaGFuZ2UtY2FjaGUnKTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGNhY2hlcyBpbmZvcm1hdGlvbiBhYm91dCBmaWxlcyBhbmQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZXkgaGF2ZVxuICogY2hhbmdlZCBjb250ZW50cyBvciBub3QuIE1vc3QgaW1wb3J0YW50bHksIHRoaXMgY2xhc3MgY2FjaGVzIHRoZSBoYXNoIG9mIHNlZW5cbiAqIGZpbGVzIHNvIHRoYXQgYXQgZGV2ZWxvcG1lbnQgdGltZSwgd2UgZG9uJ3QgaGF2ZSB0byByZWNhbGN1bGF0ZSB0aGVtIGNvbnN0YW50bHkuXG4gKlxuICogVGhpcyBjbGFzcyBpcyBhbHNvIHRoZSBjb3JlIG9mIGhvdyBlbGVjdHJvbi1jb21waWxlIHJ1bnMgcXVpY2tseSBpbiBwcm9kdWN0aW9uXG4gKiBtb2RlIC0gYWZ0ZXIgcHJlY29tcGlsYXRpb24sIHRoZSBjYWNoZSBpcyBzZXJpYWxpemVkIGFsb25nIHdpdGggdGhlIHJlc3Qgb2YgdGhlXG4gKiBkYXRhIGluIHtAbGluayBDb21waWxlckhvc3R9LCBzbyB0aGF0IHdoZW4gd2UgbG9hZCB0aGUgYXBwIGluIHByb2R1Y3Rpb24gbW9kZSxcbiAqIHdlIGRvbid0IGVuZCB1cCBjYWxjdWxhdGluZyBoYXNoZXMgb2YgZmlsZSBjb250ZW50IGF0IGFsbCwgb25seSB1c2luZyB0aGUgY29udGVudHNcbiAqIG9mIHRoaXMgY2FjaGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbGVDaGFuZ2VkQ2FjaGUge1xuICBjb25zdHJ1Y3RvcihhcHBSb290LCBmYWlsT25DYWNoZU1pc3M9ZmFsc2UpIHtcbiAgICB0aGlzLmFwcFJvb3QgPSBzYW5pdGl6ZUZpbGVQYXRoKGFwcFJvb3QpO1xuXG4gICAgdGhpcy5mYWlsT25DYWNoZU1pc3MgPSBmYWlsT25DYWNoZU1pc3M7XG4gICAgdGhpcy5jaGFuZ2VDYWNoZSA9IHt9O1xuICB9XG5cbiAgc3RhdGljIHJlbW92ZVByZWZpeChuZWVkbGUsIGhheXN0YWNrKSB7XG4gICAgbGV0IGlkeCA9IGhheXN0YWNrLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihuZWVkbGUudG9Mb3dlckNhc2UoKSk7XG4gICAgaWYgKGlkeCA8IDApIHJldHVybiBoYXlzdGFjaztcblxuICAgIHJldHVybiBoYXlzdGFjay5zdWJzdHJpbmcoaWR4ICsgbmVlZGxlLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHlvdSB0byBjcmVhdGUgYSBGaWxlQ2hhbmdlZENhY2hlIGZyb20gc2VyaWFsaXplZCBkYXRhIHNhdmVkIGZyb21cbiAgICoge0BsaW5rIGdldFNhdmVkRGF0YX0uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSAgU2F2ZWQgZGF0YSBmcm9tIGdldFNhdmVkRGF0YS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBvbmUgd2hpY2ggaGFzIHlvdXIgcGFja2FnZS5qc29uKS5cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZmFpbE9uQ2FjaGVNaXNzIChvcHRpb25hbCkgIElmIFRydWUsIGNhY2hlIG1pc3NlcyB3aWxsIHRocm93LlxuICAgKlxuICAgKiBAcmV0dXJuIHtGaWxlQ2hhbmdlZENhY2hlfVxuICAgKi9cbiAgc3RhdGljIGxvYWRGcm9tRGF0YShkYXRhLCBhcHBSb290LCBmYWlsT25DYWNoZU1pc3M9dHJ1ZSkge1xuICAgIGxldCByZXQgPSBuZXcgRmlsZUNoYW5nZWRDYWNoZShhcHBSb290LCBmYWlsT25DYWNoZU1pc3MpO1xuICAgIHJldC5jaGFuZ2VDYWNoZSA9IGRhdGEuY2hhbmdlQ2FjaGU7XG4gICAgcmV0Lm9yaWdpbmFsQXBwUm9vdCA9IGRhdGEuYXBwUm9vdDtcblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBbGxvd3MgeW91IHRvIGNyZWF0ZSBhIEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSBzZXJpYWxpemVkIGRhdGEgc2F2ZWQgZnJvbVxuICAgKiB7QGxpbmsgc2F2ZX0uXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZSAgU2F2ZWQgZGF0YSBmcm9tIHNhdmUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYXBwUm9vdCAgVGhlIHRvcC1sZXZlbCBkaXJlY3RvcnkgZm9yIHlvdXIgYXBwbGljYXRpb24gKGkuZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb25lIHdoaWNoIGhhcyB5b3VyIHBhY2thZ2UuanNvbikuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGZhaWxPbkNhY2hlTWlzcyAob3B0aW9uYWwpICBJZiBUcnVlLCBjYWNoZSBtaXNzZXMgd2lsbCB0aHJvdy5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxGaWxlQ2hhbmdlZENhY2hlPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBsb2FkRnJvbUZpbGUoZmlsZSwgYXBwUm9vdCwgZmFpbE9uQ2FjaGVNaXNzPXRydWUpIHtcbiAgICBkKGBMb2FkaW5nIGNhbm5lZCBGaWxlQ2hhbmdlZENhY2hlIGZyb20gJHtmaWxlfWApO1xuXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlKTtcbiAgICByZXR1cm4gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoSlNPTi5wYXJzZShhd2FpdCBwemxpYi5ndW56aXAoYnVmKSksIGFwcFJvb3QsIGZhaWxPbkNhY2hlTWlzcyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IGEgZ2l2ZW4gZmlsZSwgaW5jbHVkaW5nIGl0cyBoYXNoLiBUaGlzIG1ldGhvZCBpc1xuICAgKiB0aGUgbWFpbiBtZXRob2QgZm9yIHRoaXMgY2FjaGUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYWJzb2x1dGVGaWxlUGF0aCAgVGhlIHBhdGggdG8gYSBmaWxlIHRvIHJldHJpZXZlIGluZm8gb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn1cbiAgICpcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGhhc2ggIFRoZSBTSEExIGhhc2ggb2YgdGhlIGZpbGVcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBpc01pbmlmaWVkICBUcnVlIGlmIHRoZSBmaWxlIGlzIG1pbmlmaWVkXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNJbk5vZGVNb2R1bGVzICBUcnVlIGlmIHRoZSBmaWxlIGlzIGluIGEgbGlicmFyeSBkaXJlY3RvcnlcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBoYXNTb3VyY2VNYXAgIFRydWUgaWYgdGhlIGZpbGUgaGFzIGEgc291cmNlIG1hcFxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzRmlsZUJpbmFyeSAgVHJ1ZSBpZiB0aGUgZmlsZSBpcyBub3QgYSB0ZXh0IGZpbGVcbiAgICogQHByb3BlcnR5IHtCdWZmZXJ9IGJpbmFyeURhdGEgKG9wdGlvbmFsKSAgVGhlIGJ1ZmZlciB0aGF0IHdhcyByZWFkIGlmIHRoZSBmaWxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcyBiaW5hcnkgYW5kIHRoZXJlIHdhcyBhIGNhY2hlIG1pc3MuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2RlIChvcHRpb25hbCkgIFRoZSBzdHJpbmcgdGhhdCB3YXMgcmVhZCBpZiB0aGUgZmlsZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXMgdGV4dCBhbmQgdGhlcmUgd2FzIGEgY2FjaGUgbWlzc1xuICAgKi9cbiAgYXN5bmMgZ2V0SGFzaEZvclBhdGgoYWJzb2x1dGVGaWxlUGF0aCkge1xuICAgIGxldCB7Y2FjaGVFbnRyeSwgY2FjaGVLZXl9ID0gdGhpcy5nZXRDYWNoZUVudHJ5Rm9yUGF0aChhYnNvbHV0ZUZpbGVQYXRoKTtcblxuICAgIGlmICh0aGlzLmZhaWxPbkNhY2hlTWlzcykge1xuICAgICAgcmV0dXJuIGNhY2hlRW50cnkuaW5mbztcbiAgICB9XG5cbiAgICBsZXQge2N0aW1lLCBzaXplfSA9IGF3YWl0IHRoaXMuZ2V0SW5mb0ZvckNhY2hlRW50cnkoYWJzb2x1dGVGaWxlUGF0aCk7XG5cbiAgICBpZiAoY2FjaGVFbnRyeSkge1xuICAgICAgbGV0IGZpbGVIYXNDaGFuZ2VkID0gYXdhaXQgdGhpcy5oYXNGaWxlQ2hhbmdlZChhYnNvbHV0ZUZpbGVQYXRoLCBjYWNoZUVudHJ5LCB7Y3RpbWUsIHNpemV9KTtcblxuICAgICAgaWYgKCFmaWxlSGFzQ2hhbmdlZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVFbnRyeS5pbmZvO1xuICAgICAgfVxuXG4gICAgICBkKGBJbnZhbGlkYXRpbmcgY2FjaGUgZW50cnk6ICR7Y2FjaGVFbnRyeS5jdGltZX0gPT09ICR7Y3RpbWV9ICYmICR7Y2FjaGVFbnRyeS5zaXplfSA9PT0gJHtzaXplfWApO1xuICAgICAgZGVsZXRlIHRoaXMuY2hhbmdlQ2FjaGUuY2FjaGVFbnRyeTtcbiAgICB9XG5cbiAgICBsZXQge2RpZ2VzdCwgc291cmNlQ29kZSwgYmluYXJ5RGF0YX0gPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUhhc2hGb3JGaWxlKGFic29sdXRlRmlsZVBhdGgpO1xuXG4gICAgbGV0IGluZm8gPSB7XG4gICAgICBoYXNoOiBkaWdlc3QsXG4gICAgICBpc01pbmlmaWVkOiBGaWxlQ2hhbmdlZENhY2hlLmNvbnRlbnRzQXJlTWluaWZpZWQoc291cmNlQ29kZSB8fCAnJyksXG4gICAgICBpc0luTm9kZU1vZHVsZXM6IEZpbGVDaGFuZ2VkQ2FjaGUuaXNJbk5vZGVNb2R1bGVzKGFic29sdXRlRmlsZVBhdGgpLFxuICAgICAgaGFzU291cmNlTWFwOiBGaWxlQ2hhbmdlZENhY2hlLmhhc1NvdXJjZU1hcChzb3VyY2VDb2RlIHx8ICcnKSxcbiAgICAgIGlzRmlsZUJpbmFyeTogISFiaW5hcnlEYXRhXG4gICAgfTtcblxuICAgIHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldID0geyBjdGltZSwgc2l6ZSwgaW5mbyB9O1xuICAgIGQoYENhY2hlIGVudHJ5IGZvciAke2NhY2hlS2V5fTogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmNoYW5nZUNhY2hlW2NhY2hlS2V5XSl9YCk7XG5cbiAgICBpZiAoYmluYXJ5RGF0YSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2JpbmFyeURhdGF9LCBpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe3NvdXJjZUNvZGV9LCBpbmZvKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRJbmZvRm9yQ2FjaGVFbnRyeShhYnNvbHV0ZUZpbGVQYXRoKSB7XG4gICAgbGV0IHN0YXQgPSBhd2FpdCBwZnMuc3RhdChhYnNvbHV0ZUZpbGVQYXRoKTtcbiAgICBpZiAoIXN0YXQgfHwgIXN0YXQuaXNGaWxlKCkpIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc3RhdCAke2Fic29sdXRlRmlsZVBhdGh9YCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdCxcbiAgICAgIGN0aW1lOiBzdGF0LmN0aW1lLmdldFRpbWUoKSxcbiAgICAgIHNpemU6IHN0YXQuc2l6ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY2FjaGVkIGRhdGEgZm9yIGEgZmlsZSBwYXRoLCBpZiBpdCBleGlzdHMuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYWJzb2x1dGVGaWxlUGF0aCAgVGhlIHBhdGggdG8gYSBmaWxlIHRvIHJldHJpZXZlIGluZm8gb24uXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldENhY2hlRW50cnlGb3JQYXRoKGFic29sdXRlRmlsZVBhdGgpIHtcbiAgICBsZXQgY2FjaGVLZXkgPSBzYW5pdGl6ZUZpbGVQYXRoKGFic29sdXRlRmlsZVBhdGgpO1xuICAgIGlmICh0aGlzLmFwcFJvb3QpIHtcbiAgICAgIGNhY2hlS2V5ID0gY2FjaGVLZXkucmVwbGFjZSh0aGlzLmFwcFJvb3QsICcnKTtcbiAgICB9XG5cbiAgICAvLyBOQjogV2UgZG8gdGhpcyBiZWNhdXNlIHgtcmVxdWlyZSB3aWxsIGluY2x1ZGUgYW4gYWJzb2x1dGUgcGF0aCBmcm9tIHRoZVxuICAgIC8vIG9yaWdpbmFsIGJ1aWx0IGFwcCBhbmQgd2UgbmVlZCB0byBzdGlsbCBncm9rIGl0XG4gICAgaWYgKHRoaXMub3JpZ2luYWxBcHBSb290KSB7XG4gICAgICBjYWNoZUtleSA9IGNhY2hlS2V5LnJlcGxhY2UodGhpcy5vcmlnaW5hbEFwcFJvb3QsICcnKTtcbiAgICB9XG5cbiAgICBsZXQgY2FjaGVFbnRyeSA9IHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldO1xuXG4gICAgaWYgKHRoaXMuZmFpbE9uQ2FjaGVNaXNzKSB7XG4gICAgICBpZiAoIWNhY2hlRW50cnkpIHtcbiAgICAgICAgZChgVHJpZWQgdG8gcmVhZCBmaWxlIGNhY2hlIGVudHJ5IGZvciAke2Fic29sdXRlRmlsZVBhdGh9YCk7XG4gICAgICAgIGQoYGNhY2hlS2V5OiAke2NhY2hlS2V5fSwgYXBwUm9vdDogJHt0aGlzLmFwcFJvb3R9LCBvcmlnaW5hbEFwcFJvb3Q6ICR7dGhpcy5vcmlnaW5hbEFwcFJvb3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgZm9yICR7YWJzb2x1dGVGaWxlUGF0aH0gYnV0IGl0IHdhcyBub3QgcHJlY29tcGlsZWQhYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtjYWNoZUVudHJ5LCBjYWNoZUtleX07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBmaWxlIGNhY2hlIHRvIHNlZSBpZiBhIGZpbGUgaGFzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYWJzb2x1dGVGaWxlUGF0aCAgVGhlIHBhdGggdG8gYSBmaWxlIHRvIHJldHJpZXZlIGluZm8gb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gY2FjaGVFbnRyeSAgQ2FjaGUgZGF0YSBmcm9tIHtAbGluayBnZXRDYWNoZUVudHJ5Rm9yUGF0aH1cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGFzeW5jIGhhc0ZpbGVDaGFuZ2VkKGFic29sdXRlRmlsZVBhdGgsIGNhY2hlRW50cnk9bnVsbCwgZmlsZUhhc2hJbmZvPW51bGwpIHtcbiAgICBjYWNoZUVudHJ5ID0gY2FjaGVFbnRyeSB8fCB0aGlzLmdldENhY2hlRW50cnlGb3JQYXRoKGFic29sdXRlRmlsZVBhdGgpLmNhY2hlRW50cnk7XG4gICAgZmlsZUhhc2hJbmZvID0gZmlsZUhhc2hJbmZvIHx8IGF3YWl0IHRoaXMuZ2V0SW5mb0ZvckNhY2hlRW50cnkoYWJzb2x1dGVGaWxlUGF0aCk7XG5cbiAgICBpZiAoY2FjaGVFbnRyeSkge1xuICAgICAgcmV0dXJuICEoY2FjaGVFbnRyeS5jdGltZSA+PSBmaWxlSGFzaEluZm8uY3RpbWUgJiYgY2FjaGVFbnRyeS5zaXplID09PSBmaWxlSGFzaEluZm8uc2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZGF0YSB0aGF0IGNhbiBwYXNzZWQgdG8ge0BsaW5rIGxvYWRGcm9tRGF0YX0gdG8gcmVoeWRyYXRlIHRoaXMgY2FjaGUuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldFNhdmVkRGF0YSgpIHtcbiAgICByZXR1cm4geyBjaGFuZ2VDYWNoZTogdGhpcy5jaGFuZ2VDYWNoZSwgYXBwUm9vdDogdGhpcy5hcHBSb290IH07XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGlzIG9iamVjdCdzIGRhdGEgdG8gYSBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGggIFRoZSBwYXRoIHRvIHNhdmUgZGF0YSB0by5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX0gQ29tcGxldGlvbi5cbiAgICovXG4gIGFzeW5jIHNhdmUoZmlsZVBhdGgpIHtcbiAgICBsZXQgdG9TYXZlID0gdGhpcy5nZXRTYXZlZERhdGEoKTtcblxuICAgIGxldCBidWYgPSBhd2FpdCBwemxpYi5nemlwKG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkodG9TYXZlKSkpO1xuICAgIGF3YWl0IHBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIGJ1Zik7XG4gIH1cblxuICBhc3luYyBjYWxjdWxhdGVIYXNoRm9yRmlsZShhYnNvbHV0ZUZpbGVQYXRoKSB7XG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHBmcy5yZWFkRmlsZShhYnNvbHV0ZUZpbGVQYXRoKTtcbiAgICBsZXQgZW5jb2RpbmcgPSBGaWxlQ2hhbmdlZENhY2hlLmRldGVjdEZpbGVFbmNvZGluZyhidWYpO1xuXG4gICAgaWYgKCFlbmNvZGluZykge1xuICAgICAgbGV0IGRpZ2VzdCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGJ1ZikuZGlnZXN0KCdoZXgnKTtcbiAgICAgIHJldHVybiB7IHNvdXJjZUNvZGU6IG51bGwsIGRpZ2VzdCwgYmluYXJ5RGF0YTogYnVmIH07XG4gICAgfVxuXG4gICAgbGV0IHNvdXJjZUNvZGUgPSBhd2FpdCBwZnMucmVhZEZpbGUoYWJzb2x1dGVGaWxlUGF0aCwgZW5jb2RpbmcpO1xuICAgIGxldCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShzb3VyY2VDb2RlLCAndXRmOCcpLmRpZ2VzdCgnaGV4Jyk7XG5cbiAgICByZXR1cm4ge3NvdXJjZUNvZGUsIGRpZ2VzdCwgYmluYXJ5RGF0YTogbnVsbCB9O1xuICB9XG5cbiAgZ2V0SGFzaEZvclBhdGhTeW5jKGFic29sdXRlRmlsZVBhdGgpIHtcbiAgICBsZXQgY2FjaGVLZXkgPSBzYW5pdGl6ZUZpbGVQYXRoKGFic29sdXRlRmlsZVBhdGgpO1xuXG4gICAgaWYgKHRoaXMuYXBwUm9vdCkge1xuICAgICAgY2FjaGVLZXkgPSBGaWxlQ2hhbmdlZENhY2hlLnJlbW92ZVByZWZpeCh0aGlzLmFwcFJvb3QsIGNhY2hlS2V5KTtcbiAgICB9XG5cbiAgICAvLyBOQjogV2UgZG8gdGhpcyBiZWNhdXNlIHgtcmVxdWlyZSB3aWxsIGluY2x1ZGUgYW4gYWJzb2x1dGUgcGF0aCBmcm9tIHRoZVxuICAgIC8vIG9yaWdpbmFsIGJ1aWx0IGFwcCBhbmQgd2UgbmVlZCB0byBzdGlsbCBncm9rIGl0XG4gICAgaWYgKHRoaXMub3JpZ2luYWxBcHBSb290KSB7XG4gICAgICBjYWNoZUtleSA9IEZpbGVDaGFuZ2VkQ2FjaGUucmVtb3ZlUHJlZml4KHRoaXMub3JpZ2luYWxBcHBSb290LCBjYWNoZUtleSk7XG4gICAgfVxuXG4gICAgbGV0IGNhY2hlRW50cnkgPSB0aGlzLmNoYW5nZUNhY2hlW2NhY2hlS2V5XTtcblxuICAgIGlmICh0aGlzLmZhaWxPbkNhY2hlTWlzcykge1xuICAgICAgaWYgKCFjYWNoZUVudHJ5KSB7XG4gICAgICAgIGQoYFRyaWVkIHRvIHJlYWQgZmlsZSBjYWNoZSBlbnRyeSBmb3IgJHthYnNvbHV0ZUZpbGVQYXRofWApO1xuICAgICAgICBkKGBjYWNoZUtleTogJHtjYWNoZUtleX0sIGFwcFJvb3Q6ICR7dGhpcy5hcHBSb290fSwgb3JpZ2luYWxBcHBSb290OiAke3RoaXMub3JpZ2luYWxBcHBSb290fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFza2VkIGZvciAke2Fic29sdXRlRmlsZVBhdGh9IGJ1dCBpdCB3YXMgbm90IHByZWNvbXBpbGVkIWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FjaGVFbnRyeS5pbmZvO1xuICAgIH1cblxuICAgIGxldCBzdGF0ID0gZnMuc3RhdFN5bmMoYWJzb2x1dGVGaWxlUGF0aCk7XG4gICAgbGV0IGN0aW1lID0gc3RhdC5jdGltZS5nZXRUaW1lKCk7XG4gICAgbGV0IHNpemUgPSBzdGF0LnNpemU7XG4gICAgaWYgKCFzdGF0IHx8ICFzdGF0LmlzRmlsZSgpKSB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHN0YXQgJHthYnNvbHV0ZUZpbGVQYXRofWApO1xuXG4gICAgaWYgKGNhY2hlRW50cnkpIHtcbiAgICAgIGlmIChjYWNoZUVudHJ5LmN0aW1lID49IGN0aW1lICYmIGNhY2hlRW50cnkuc2l6ZSA9PT0gc2l6ZSkge1xuICAgICAgICByZXR1cm4gY2FjaGVFbnRyeS5pbmZvO1xuICAgICAgfVxuXG4gICAgICBkKGBJbnZhbGlkYXRpbmcgY2FjaGUgZW50cnk6ICR7Y2FjaGVFbnRyeS5jdGltZX0gPT09ICR7Y3RpbWV9ICYmICR7Y2FjaGVFbnRyeS5zaXplfSA9PT0gJHtzaXplfWApO1xuICAgICAgZGVsZXRlIHRoaXMuY2hhbmdlQ2FjaGUuY2FjaGVFbnRyeTtcbiAgICB9XG5cbiAgICBsZXQge2RpZ2VzdCwgc291cmNlQ29kZSwgYmluYXJ5RGF0YX0gPSB0aGlzLmNhbGN1bGF0ZUhhc2hGb3JGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoKTtcblxuICAgIGxldCBpbmZvID0ge1xuICAgICAgaGFzaDogZGlnZXN0LFxuICAgICAgaXNNaW5pZmllZDogRmlsZUNoYW5nZWRDYWNoZS5jb250ZW50c0FyZU1pbmlmaWVkKHNvdXJjZUNvZGUgfHwgJycpLFxuICAgICAgaXNJbk5vZGVNb2R1bGVzOiBGaWxlQ2hhbmdlZENhY2hlLmlzSW5Ob2RlTW9kdWxlcyhhYnNvbHV0ZUZpbGVQYXRoKSxcbiAgICAgIGhhc1NvdXJjZU1hcDogRmlsZUNoYW5nZWRDYWNoZS5oYXNTb3VyY2VNYXAoc291cmNlQ29kZSB8fCAnJyksXG4gICAgICBpc0ZpbGVCaW5hcnk6ICEhYmluYXJ5RGF0YVxuICAgIH07XG5cbiAgICB0aGlzLmNoYW5nZUNhY2hlW2NhY2hlS2V5XSA9IHsgY3RpbWUsIHNpemUsIGluZm8gfTtcbiAgICBkKGBDYWNoZSBlbnRyeSBmb3IgJHtjYWNoZUtleX06ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV0pfWApO1xuXG4gICAgaWYgKGJpbmFyeURhdGEpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtiaW5hcnlEYXRhfSwgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtzb3VyY2VDb2RlfSwgaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgc2F2ZVN5bmMoZmlsZVBhdGgpIHtcbiAgICBsZXQgdG9TYXZlID0gdGhpcy5nZXRTYXZlZERhdGEoKTtcblxuICAgIGxldCBidWYgPSB6bGliLmd6aXBTeW5jKG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkodG9TYXZlKSkpO1xuICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGJ1Zik7XG4gIH1cblxuICBjYWxjdWxhdGVIYXNoRm9yRmlsZVN5bmMoYWJzb2x1dGVGaWxlUGF0aCkge1xuICAgIGxldCBidWYgPSBmcy5yZWFkRmlsZVN5bmMoYWJzb2x1dGVGaWxlUGF0aCk7XG4gICAgbGV0IGVuY29kaW5nID0gRmlsZUNoYW5nZWRDYWNoZS5kZXRlY3RGaWxlRW5jb2RpbmcoYnVmKTtcblxuICAgIGlmICghZW5jb2RpbmcpIHtcbiAgICAgIGxldCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShidWYpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICByZXR1cm4geyBzb3VyY2VDb2RlOiBudWxsLCBkaWdlc3QsIGJpbmFyeURhdGE6IGJ1Zn07XG4gICAgfVxuXG4gICAgbGV0IHNvdXJjZUNvZGUgPSBmcy5yZWFkRmlsZVN5bmMoYWJzb2x1dGVGaWxlUGF0aCwgZW5jb2RpbmcpO1xuICAgIGxldCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShzb3VyY2VDb2RlLCAndXRmOCcpLmRpZ2VzdCgnaGV4Jyk7XG5cbiAgICByZXR1cm4ge3NvdXJjZUNvZGUsIGRpZ2VzdCwgYmluYXJ5RGF0YTogbnVsbH07XG4gIH1cblxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHZpYSBzb21lIHN0YXRpc3RpY3Mgd2hldGhlciBhIGZpbGUgaXMgbGlrZWx5IHRvIGJlIG1pbmlmaWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGNvbnRlbnRzQXJlTWluaWZpZWQoc291cmNlKSB7XG4gICAgbGV0IGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IDEwMjQpIGxlbmd0aCA9IDEwMjQ7XG5cbiAgICBsZXQgbmV3bGluZUNvdW50ID0gMDtcblxuICAgIC8vIFJvbGwgdGhyb3VnaCB0aGUgY2hhcmFjdGVycyBhbmQgZGV0ZXJtaW5lIHRoZSBhdmVyYWdlIGxpbmUgbGVuZ3RoXG4gICAgZm9yKGxldCBpPTA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzb3VyY2VbaV0gPT09ICdcXG4nKSBuZXdsaW5lQ291bnQrKztcbiAgICB9XG5cbiAgICAvLyBObyBOZXdsaW5lcz8gQW55IGZpbGUgb3RoZXIgdGhhbiBhIHN1cGVyIHNtYWxsIG9uZSBpcyBtaW5pZmllZFxuICAgIGlmIChuZXdsaW5lQ291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiAobGVuZ3RoID4gODApO1xuICAgIH1cblxuICAgIGxldCBhdmdMaW5lTGVuZ3RoID0gbGVuZ3RoIC8gbmV3bGluZUNvdW50O1xuICAgIHJldHVybiAoYXZnTGluZUxlbmd0aCA+IDgwKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIHBhdGggaXMgaW4gbm9kZV9tb2R1bGVzIG9yIHRoZSBFbGVjdHJvbiBpbml0IGNvZGVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBpc0luTm9kZU1vZHVsZXMoZmlsZVBhdGgpIHtcbiAgICByZXR1cm4gISEoZmlsZVBhdGgubWF0Y2goLyhub2RlX21vZHVsZXN8Ym93ZXJfY29tcG9uZW50cylbXFxcXFxcL10vaSkgfHwgZmlsZVBhdGgubWF0Y2goLyhhdG9tfGVsZWN0cm9uKVxcLmFzYXIvKSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBmaWxlIGhhcyBhbiBpbmxpbmUgc291cmNlIG1hcFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGhhc1NvdXJjZU1hcChzb3VyY2VDb2RlKSB7XG4gICAgY29uc3QgdHJpbW1lZCA9IHNvdXJjZUNvZGUudHJpbSgpO1xuICAgIHJldHVybiB0cmltbWVkLmxhc3RJbmRleE9mKCcvLyMgc291cmNlTWFwJykgPiB0cmltbWVkLmxhc3RJbmRleE9mKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBlbmNvZGluZyBvZiBhIGZpbGUgZnJvbSB0aGUgdHdvIG1vc3QgY29tbW9uIGVuY29kaW5ncyBieSB0cnlpbmdcbiAgICogdG8gZGVjb2RlIGl0IHRoZW4gbG9va2luZyBmb3IgZW5jb2RpbmcgZXJyb3JzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZGV0ZWN0RmlsZUVuY29kaW5nKGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgMSkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBidWYgPSAoYnVmZmVyLmxlbmd0aCA8IDQwOTYgPyBidWZmZXIgOiBidWZmZXIuc2xpY2UoMCwgNDA5NikpO1xuXG4gICAgY29uc3QgZW5jb2RpbmdzID0gWyd1dGY4JywgJ3V0ZjE2bGUnXTtcblxuICAgIGxldCBlbmNvZGluZztcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA8PSAxMjgpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmdzLmZpbmQoeCA9PlxuICAgICAgICBCdWZmZXIuY29tcGFyZShuZXcgQnVmZmVyKGJ1ZmZlci50b1N0cmluZygpLCB4KSwgYnVmZmVyKSA9PT0gMFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZ3MuZmluZCh4ID0+ICFGaWxlQ2hhbmdlZENhY2hlLmNvbnRhaW5zQ29udHJvbENoYXJhY3RlcnMoYnVmLnRvU3RyaW5nKHgpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBpcyBsaWtlbHkgdG8gYmUgcG9vcmx5IGVuY29kZWQgYnkgbG9va2luZyBmb3JcbiAgICogY29udHJvbCBjaGFyYWN0ZXJzIGFib3ZlIGEgY2VydGFpbiB0aHJlc2hvbGRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBjb250YWluc0NvbnRyb2xDaGFyYWN0ZXJzKHN0cikge1xuICAgIGxldCBjb250cm9sQ291bnQgPSAwO1xuICAgIGxldCBzcGFjZUNvdW50ID0gMDtcbiAgICBsZXQgdGhyZXNob2xkID0gMjtcbiAgICBpZiAoc3RyLmxlbmd0aCA+IDY0KSB0aHJlc2hvbGQgPSA0O1xuICAgIGlmIChzdHIubGVuZ3RoID4gNTEyKSB0aHJlc2hvbGQgPSA4O1xuXG4gICAgZm9yIChsZXQgaT0wOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGMgPT09IDY1NTM2IHx8IGMgPCA4KSBjb250cm9sQ291bnQrKztcbiAgICAgIGlmIChjID4gMTQgJiYgYyA8IDMyKSBjb250cm9sQ291bnQrKztcbiAgICAgIGlmIChjID09PSAzMikgc3BhY2VDb3VudCsrO1xuXG4gICAgICBpZiAoY29udHJvbENvdW50ID4gdGhyZXNob2xkKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc3BhY2VDb3VudCA8IHRocmVzaG9sZCkgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAoY29udHJvbENvdW50ID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIChjb250cm9sQ291bnQgLyBzdHIubGVuZ3RoKSA8IDAuMDI7XG4gIH1cbn1cbiJdfQ==","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/sanitize-paths.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = sanitizeFilePath;\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _lruCache = require('lru-cache');\n\nvar _lruCache2 = _interopRequireDefault(_lruCache);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst d = require('debug')('electron-compile:sanitize-paths');\nconst realpathCache = (0, _lruCache2.default)({ max: 32 });\n\nfunction cachedRealpath(p) {\n  let ret = realpathCache.get(p);\n  if (ret) return ret;\n\n  ret = _fs2.default.realpathSync(p);\n  d(`Cache miss for cachedRealpath: '${p}' => '${ret}'`);\n\n  realpathCache.set(p, ret);\n  return ret;\n}\n\n/**\n * Electron will sometimes hand us paths that don't match the platform if they\n * were derived from a URL (i.e. 'C:/Users/Paul/...'), whereas the cache will have\n * saved paths with backslashes.\n *\n * @private\n */\nfunction sanitizeFilePath(file) {\n  if (!file) return file;\n\n  // NB: Some people add symlinks into system directories. node.js will internally\n  // call realpath on paths that it finds, which will break our cache resolution.\n  // We need to catch this scenario and fix it up. The tricky part is, some parts\n  // of Electron will give us the pre-resolved paths, and others will give us the\n  // post-resolved one. We need to handle both.\n\n  let realFile = null;\n  let parts = file.split(/[\\\\\\/]app.asar[\\\\\\/]/);\n  if (!parts[1]) {\n    // Not using an ASAR archive\n    realFile = cachedRealpath(file);\n  } else {\n    // We do all this silliness to work around\n    // https://github.com/atom/electron/issues/4610\n    realFile = `${cachedRealpath(parts[0])}/app.asar/${parts[1]}`;\n  }\n\n  return realFile.replace(/[\\\\\\/]/g, '/');\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zYW5pdGl6ZS1wYXRocy5qcyJdLCJuYW1lcyI6WyJzYW5pdGl6ZUZpbGVQYXRoIiwiZCIsInJlcXVpcmUiLCJyZWFscGF0aENhY2hlIiwibWF4IiwiY2FjaGVkUmVhbHBhdGgiLCJwIiwicmV0IiwiZ2V0IiwicmVhbHBhdGhTeW5jIiwic2V0IiwiZmlsZSIsInJlYWxGaWxlIiwicGFydHMiLCJzcGxpdCIsInJlcGxhY2UiXSwibWFwcGluZ3MiOiI7Ozs7O2tCQXdCd0JBLGdCOztBQXhCeEI7Ozs7QUFDQTs7Ozs7O0FBRUEsTUFBTUMsSUFBSUMsUUFBUSxPQUFSLEVBQWlCLGlDQUFqQixDQUFWO0FBQ0EsTUFBTUMsZ0JBQWdCLHdCQUFTLEVBQUVDLEtBQUssRUFBUCxFQUFULENBQXRCOztBQUVBLFNBQVNDLGNBQVQsQ0FBd0JDLENBQXhCLEVBQTJCO0FBQ3pCLE1BQUlDLE1BQU1KLGNBQWNLLEdBQWQsQ0FBa0JGLENBQWxCLENBQVY7QUFDQSxNQUFJQyxHQUFKLEVBQVMsT0FBT0EsR0FBUDs7QUFFVEEsUUFBTSxhQUFHRSxZQUFILENBQWdCSCxDQUFoQixDQUFOO0FBQ0FMLElBQUcsbUNBQWtDSyxDQUFFLFNBQVFDLEdBQUksR0FBbkQ7O0FBRUFKLGdCQUFjTyxHQUFkLENBQWtCSixDQUFsQixFQUFxQkMsR0FBckI7QUFDQSxTQUFPQSxHQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPZSxTQUFTUCxnQkFBVCxDQUEwQlcsSUFBMUIsRUFBZ0M7QUFDN0MsTUFBSSxDQUFDQSxJQUFMLEVBQVcsT0FBT0EsSUFBUDs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUlDLFdBQVcsSUFBZjtBQUNBLE1BQUlDLFFBQVFGLEtBQUtHLEtBQUwsQ0FBVyxzQkFBWCxDQUFaO0FBQ0EsTUFBSSxDQUFDRCxNQUFNLENBQU4sQ0FBTCxFQUFlO0FBQ2I7QUFDQUQsZUFBV1AsZUFBZU0sSUFBZixDQUFYO0FBQ0QsR0FIRCxNQUdPO0FBQ0w7QUFDQTtBQUNBQyxlQUFZLEdBQUVQLGVBQWVRLE1BQU0sQ0FBTixDQUFmLENBQXlCLGFBQVlBLE1BQU0sQ0FBTixDQUFTLEVBQTVEO0FBQ0Q7O0FBRUQsU0FBT0QsU0FBU0csT0FBVCxDQUFpQixTQUFqQixFQUE0QixHQUE1QixDQUFQO0FBQ0QiLCJmaWxlIjoic2FuaXRpemUtcGF0aHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IExSVUNhY2hlIGZyb20gJ2xydS1jYWNoZSc7XG5cbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOnNhbml0aXplLXBhdGhzJyk7XG5jb25zdCByZWFscGF0aENhY2hlID0gTFJVQ2FjaGUoeyBtYXg6IDMyIH0pO1xuXG5mdW5jdGlvbiBjYWNoZWRSZWFscGF0aChwKSB7XG4gIGxldCByZXQgPSByZWFscGF0aENhY2hlLmdldChwKTtcbiAgaWYgKHJldCkgcmV0dXJuIHJldDtcblxuICByZXQgPSBmcy5yZWFscGF0aFN5bmMocCk7XG4gIGQoYENhY2hlIG1pc3MgZm9yIGNhY2hlZFJlYWxwYXRoOiAnJHtwfScgPT4gJyR7cmV0fSdgKTtcblxuICByZWFscGF0aENhY2hlLnNldChwLCByZXQpO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEVsZWN0cm9uIHdpbGwgc29tZXRpbWVzIGhhbmQgdXMgcGF0aHMgdGhhdCBkb24ndCBtYXRjaCB0aGUgcGxhdGZvcm0gaWYgdGhleVxuICogd2VyZSBkZXJpdmVkIGZyb20gYSBVUkwgKGkuZS4gJ0M6L1VzZXJzL1BhdWwvLi4uJyksIHdoZXJlYXMgdGhlIGNhY2hlIHdpbGwgaGF2ZVxuICogc2F2ZWQgcGF0aHMgd2l0aCBiYWNrc2xhc2hlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzYW5pdGl6ZUZpbGVQYXRoKGZpbGUpIHtcbiAgaWYgKCFmaWxlKSByZXR1cm4gZmlsZTtcblxuICAvLyBOQjogU29tZSBwZW9wbGUgYWRkIHN5bWxpbmtzIGludG8gc3lzdGVtIGRpcmVjdG9yaWVzLiBub2RlLmpzIHdpbGwgaW50ZXJuYWxseVxuICAvLyBjYWxsIHJlYWxwYXRoIG9uIHBhdGhzIHRoYXQgaXQgZmluZHMsIHdoaWNoIHdpbGwgYnJlYWsgb3VyIGNhY2hlIHJlc29sdXRpb24uXG4gIC8vIFdlIG5lZWQgdG8gY2F0Y2ggdGhpcyBzY2VuYXJpbyBhbmQgZml4IGl0IHVwLiBUaGUgdHJpY2t5IHBhcnQgaXMsIHNvbWUgcGFydHNcbiAgLy8gb2YgRWxlY3Ryb24gd2lsbCBnaXZlIHVzIHRoZSBwcmUtcmVzb2x2ZWQgcGF0aHMsIGFuZCBvdGhlcnMgd2lsbCBnaXZlIHVzIHRoZVxuICAvLyBwb3N0LXJlc29sdmVkIG9uZS4gV2UgbmVlZCB0byBoYW5kbGUgYm90aC5cblxuICBsZXQgcmVhbEZpbGUgPSBudWxsO1xuICBsZXQgcGFydHMgPSBmaWxlLnNwbGl0KC9bXFxcXFxcL11hcHAuYXNhcltcXFxcXFwvXS8pO1xuICBpZiAoIXBhcnRzWzFdKSB7XG4gICAgLy8gTm90IHVzaW5nIGFuIEFTQVIgYXJjaGl2ZVxuICAgIHJlYWxGaWxlID0gY2FjaGVkUmVhbHBhdGgoZmlsZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgZG8gYWxsIHRoaXMgc2lsbGluZXNzIHRvIHdvcmsgYXJvdW5kXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F0b20vZWxlY3Ryb24vaXNzdWVzLzQ2MTBcbiAgICByZWFsRmlsZSA9IGAke2NhY2hlZFJlYWxwYXRoKHBhcnRzWzBdKX0vYXBwLmFzYXIvJHtwYXJ0c1sxXX1gO1xuICB9XG5cbiAgcmV0dXJuIHJlYWxGaWxlLnJlcGxhY2UoL1tcXFxcXFwvXS9nLCAnLycpO1xufVxuIl19","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/compiler-host.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _mimeTypes = require('@paulcbetts/mime-types');\n\nvar _mimeTypes2 = _interopRequireDefault(_mimeTypes);\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _zlib = require('zlib');\n\nvar _zlib2 = _interopRequireDefault(_zlib);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _promise = require('./promise');\n\nvar _forAllFiles = require('./for-all-files');\n\nvar _compileCache = require('./compile-cache');\n\nvar _compileCache2 = _interopRequireDefault(_compileCache);\n\nvar _fileChangeCache = require('./file-change-cache');\n\nvar _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);\n\nvar _readOnlyCompiler = require('./read-only-compiler');\n\nvar _readOnlyCompiler2 = _interopRequireDefault(_readOnlyCompiler);\n\nvar _browserSignal = require('./browser-signal');\n\nrequire('rxjs/add/operator/map');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst d = require('debug')('electron-compile:compiler-host');\n\nrequire('./rig-mime-types').init();\n\n// This isn't even my\nconst finalForms = {\n  'text/javascript': true,\n  'application/javascript': true,\n  'text/html': true,\n  'text/css': true,\n  'image/svg+xml': true,\n  'application/json': true\n};\n\n/**\r\n * This class is the top-level class that encapsulates all of the logic of\r\n * compiling and caching application code. If you're looking for a \"Main class\",\r\n * this is it.\r\n *\r\n * This class can be created directly but it is usually created via the methods\r\n * in config-parser, which will among other things, set up the compiler options\r\n * given a project root.\r\n *\r\n * CompilerHost is also the top-level class that knows how to serialize all of the\r\n * information necessary to recreate itself, either as a development host (i.e.\r\n * will allow cache misses and actual compilation), or as a read-only version of\r\n * itself for production.\r\n */\nclass CompilerHost {\n  /**\r\n   * Creates an instance of CompilerHost. You probably want to use the methods\r\n   * in config-parser for development, or {@link createReadonlyFromConfiguration}\r\n   * for production instead.\r\n   *\r\n   * @param  {string} rootCacheDir  The root directory to use for the cache\r\n   *\r\n   * @param  {Object} compilers  an Object whose keys are input MIME types and\r\n   *                             whose values are instances of CompilerBase. Create\r\n   *                             this via the {@link createCompilers} method in\r\n   *                             config-parser.\r\n   *\r\n   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is\r\n   *                                             optionally pre-loaded.\r\n   *\r\n   * @param  {boolean} readOnlyMode  If True, cache misses will fail and\r\n   *                                 compilation will not be attempted.\r\n   *\r\n   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled\r\n   *                                         which doesn't have a matching compiler,\r\n   *                                         this compiler will be used instead. If\r\n   *                                         null, will fail compilation. A good\r\n   *                                         alternate fallback is the compiler for\r\n   *                                         'text/plain', which is guaranteed to be\r\n   *                                         present.\r\n   *\r\n   * @param {string} sourceMapPath (optional) The directory to store sourcemap separately\r\n   *                               if compiler option enabled to emit.\r\n   *                               Default to cachePath if not specified.\r\n   */\n  constructor(rootCacheDir, compilers, fileChangeCache, readOnlyMode) {\n    let fallbackCompiler = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    let sourceMapPath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n\n    let compilersByMimeType = Object.assign({}, compilers);\n    Object.assign(this, { rootCacheDir, compilersByMimeType, fileChangeCache, readOnlyMode, fallbackCompiler });\n    this.appRoot = this.fileChangeCache.appRoot;\n\n    this.cachesForCompilers = Object.keys(compilersByMimeType).reduce((acc, x) => {\n      let compiler = compilersByMimeType[x];\n      if (acc.has(compiler)) return acc;\n\n      acc.set(compiler, _compileCache2.default.createFromCompiler(rootCacheDir, compiler, fileChangeCache, readOnlyMode, sourceMapPath));\n      return acc;\n    }, new Map());\n  }\n\n  /**\r\n   * Creates a production-mode CompilerHost from the previously saved\r\n   * configuration\r\n   *\r\n   * @param  {string} rootCacheDir  The root directory to use for the cache. This\r\n   *                                cache must have cache information saved via\r\n   *                                {@link saveConfiguration}\r\n   *\r\n   * @param  {string} appRoot  The top-level directory for your application (i.e.\r\n   *                           the one which has your package.json).\r\n   *\r\n   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled\r\n   *                                         which doesn't have a matching compiler,\r\n   *                                         this compiler will be used instead. If\r\n   *                                         null, will fail compilation. A good\r\n   *                                         alternate fallback is the compiler for\r\n   *                                         'text/plain', which is guaranteed to be\r\n   *                                         present.\r\n   *\r\n   * @return {Promise<CompilerHost>}  A read-only CompilerHost\r\n   */\n  static createReadonlyFromConfiguration(rootCacheDir, appRoot) {\n    let fallbackCompiler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return _asyncToGenerator(function* () {\n      let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');\n      let buf = yield _promise.pfs.readFile(target);\n      let info = JSON.parse((yield _promise.pzlib.gunzip(buf)));\n\n      let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);\n\n      let compilers = Object.keys(info.compilers).reduce(function (acc, x) {\n        let cur = info.compilers[x];\n        acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);\n\n        return acc;\n      }, {});\n\n      return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler);\n    })();\n  }\n\n  /**\r\n   * Creates a development-mode CompilerHost from the previously saved\r\n   * configuration.\r\n   *\r\n   * @param  {string} rootCacheDir  The root directory to use for the cache. This\r\n   *                                cache must have cache information saved via\r\n   *                                {@link saveConfiguration}\r\n   *\r\n   * @param  {string} appRoot  The top-level directory for your application (i.e.\r\n   *                           the one which has your package.json).\r\n   *\r\n   * @param  {Object} compilersByMimeType  an Object whose keys are input MIME\r\n   *                                       types and whose values are instances\r\n   *                                       of CompilerBase. Create this via the\r\n   *                                       {@link createCompilers} method in\r\n   *                                       config-parser.\r\n   *\r\n   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled\r\n   *                                         which doesn't have a matching compiler,\r\n   *                                         this compiler will be used instead. If\r\n   *                                         null, will fail compilation. A good\r\n   *                                         alternate fallback is the compiler for\r\n   *                                         'text/plain', which is guaranteed to be\r\n   *                                         present.\r\n   *\r\n   * @return {Promise<CompilerHost>}  A read-only CompilerHost\r\n   */\n  static createFromConfiguration(rootCacheDir, appRoot, compilersByMimeType) {\n    let fallbackCompiler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    return _asyncToGenerator(function* () {\n      let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');\n      let buf = yield _promise.pfs.readFile(target);\n      let info = JSON.parse((yield _promise.pzlib.gunzip(buf)));\n\n      let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);\n\n      Object.keys(info.compilers).forEach(function (x) {\n        let cur = info.compilers[x];\n        compilersByMimeType[x].compilerOptions = cur.compilerOptions;\n      });\n\n      return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler);\n    })();\n  }\n\n  /**\r\n   * Saves the current compiler configuration to a file that\r\n   * {@link createReadonlyFromConfiguration} can use to recreate the current\r\n   * compiler environment\r\n   *\r\n   * @return {Promise}  Completion\r\n   */\n  saveConfiguration() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let serializedCompilerOpts = Object.keys(_this.compilersByMimeType).reduce(function (acc, x) {\n        let compiler = _this.compilersByMimeType[x];\n        let Klass = Object.getPrototypeOf(compiler).constructor;\n\n        let val = {\n          name: Klass.name,\n          inputMimeTypes: Klass.getInputMimeTypes(),\n          compilerOptions: compiler.compilerOptions,\n          compilerVersion: compiler.getCompilerVersion()\n        };\n\n        acc[x] = val;\n        return acc;\n      }, {});\n\n      let info = {\n        fileChangeCache: _this.fileChangeCache.getSavedData(),\n        compilers: serializedCompilerOpts\n      };\n\n      let target = _path2.default.join(_this.rootCacheDir, 'compiler-info.json.gz');\n      let buf = yield _promise.pzlib.gzip(new Buffer(JSON.stringify(info)));\n      yield _promise.pfs.writeFile(target, buf);\n    })();\n  }\n\n  /**\r\n   * Compiles a file and returns the compiled result.\r\n   *\r\n   * @param  {string} filePath  The path to the file to compile\r\n   *\r\n   * @return {Promise<object>}  An Object with the compiled result\r\n   *\r\n   * @property {Object} hashInfo  The hash information returned from getHashForPath\r\n   * @property {string} code  The source code if the file was a text file\r\n   * @property {Buffer} binaryData  The file if it was a binary file\r\n   * @property {string} mimeType  The MIME type saved in the cache.\r\n   * @property {string[]} dependentFiles  The dependent files returned from\r\n   *                                      compiling the file, if any.\r\n   */\n  compile(filePath) {\n    return this.readOnlyMode ? this.compileReadOnly(filePath) : this.fullCompile(filePath);\n  }\n\n  /**\r\n   * Handles compilation in read-only mode\r\n   *\r\n   * @private\r\n   */\n  compileReadOnly(filePath) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // We guarantee that node_modules are always shipped directly\n      let type = _mimeTypes2.default.lookup(filePath);\n      if (_fileChangeCache2.default.isInNodeModules(filePath)) {\n        return {\n          mimeType: type || 'application/javascript',\n          code: yield _promise.pfs.readFile(filePath, 'utf8')\n        };\n      }\n\n      let hashInfo = yield _this2.fileChangeCache.getHashForPath(filePath);\n\n      // NB: Here, we're basically only using the compiler here to find\n      // the appropriate CompileCache\n      let compiler = CompilerHost.shouldPassthrough(hashInfo) ? _this2.getPassthroughCompiler() : _this2.compilersByMimeType[type || '__lolnothere'];\n\n      // NB: We don't put this into shouldPassthrough because Inline HTML\n      // compiler is technically of type finalForms (i.e. a browser can\n      // natively handle this content), yet its compiler is\n      // InlineHtmlCompiler. However, we still want to catch standard CSS files\n      // which will be processed by PassthroughCompiler.\n      if (finalForms[type] && !compiler) {\n        compiler = _this2.getPassthroughCompiler();\n      }\n\n      if (!compiler) {\n        compiler = _this2.fallbackCompiler;\n\n        var _ref = yield compiler.get(filePath);\n\n        let code = _ref.code,\n            binaryData = _ref.binaryData,\n            mimeType = _ref.mimeType;\n\n        return { code: code || binaryData, mimeType };\n      }\n\n      let cache = _this2.cachesForCompilers.get(compiler);\n\n      var _ref2 = yield cache.get(filePath);\n\n      let code = _ref2.code,\n          binaryData = _ref2.binaryData,\n          mimeType = _ref2.mimeType;\n\n\n      code = code || binaryData;\n      if (!code || !mimeType) {\n        throw new Error(`Asked to compile ${filePath} in production, is this file not precompiled?`);\n      }\n\n      return { code, mimeType };\n    })();\n  }\n\n  /**\r\n   * Handles compilation in read-write mode\r\n   *\r\n   * @private\r\n   */\n  fullCompile(filePath) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      d(`Compiling ${filePath}`);\n\n      let hashInfo = yield _this3.fileChangeCache.getHashForPath(filePath);\n      let type = _mimeTypes2.default.lookup(filePath);\n\n      (0, _browserSignal.send)('electron-compile-compiled-file', { filePath, mimeType: type });\n\n      if (hashInfo.isInNodeModules) {\n        let code = hashInfo.sourceCode || (yield _promise.pfs.readFile(filePath, 'utf8'));\n        code = yield CompilerHost.fixNodeModulesSourceMapping(code, filePath, _this3.fileChangeCache.appRoot);\n        return { code, mimeType: type };\n      }\n\n      let compiler = CompilerHost.shouldPassthrough(hashInfo) ? _this3.getPassthroughCompiler() : _this3.compilersByMimeType[type || '__lolnothere'];\n\n      if (!compiler) {\n        d(`Falling back to passthrough compiler for ${filePath}`);\n        compiler = _this3.fallbackCompiler;\n      }\n\n      if (!compiler) {\n        throw new Error(`Couldn't find a compiler for ${filePath}`);\n      }\n\n      let cache = _this3.cachesForCompilers.get(compiler);\n      return yield cache.getOrFetch(filePath, function (filePath, hashInfo) {\n        return _this3.compileUncached(filePath, hashInfo, compiler);\n      });\n    })();\n  }\n\n  /**\r\n   * Handles invoking compilers independent of caching\r\n   *\r\n   * @private\r\n   */\n  compileUncached(filePath, hashInfo, compiler) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      let inputMimeType = _mimeTypes2.default.lookup(filePath);\n\n      if (hashInfo.isFileBinary) {\n        return {\n          binaryData: hashInfo.binaryData || (yield _promise.pfs.readFile(filePath)),\n          mimeType: inputMimeType,\n          dependentFiles: []\n        };\n      }\n\n      let ctx = {};\n      let code = hashInfo.sourceCode || (yield _promise.pfs.readFile(filePath, 'utf8'));\n\n      if (!(yield compiler.shouldCompileFile(code, ctx))) {\n        d(`Compiler returned false for shouldCompileFile: ${filePath}`);\n        return { code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] };\n      }\n\n      let dependentFiles = yield compiler.determineDependentFiles(code, filePath, ctx);\n\n      d(`Using compiler options: ${JSON.stringify(compiler.compilerOptions)}`);\n      let result = yield compiler.compile(code, filePath, ctx);\n\n      let shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';\n\n      let isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);\n\n      if (finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough) {\n        // Got something we can use in-browser, let's return it\n        return Object.assign(result, { dependentFiles });\n      } else {\n        d(`Recursively compiling result of ${filePath} with non-final MIME type ${result.mimeType}, input was ${inputMimeType}`);\n\n        hashInfo = Object.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);\n        compiler = _this4.compilersByMimeType[result.mimeType || '__lolnothere'];\n\n        if (!compiler) {\n          d(`Recursive compile failed - intermediate result: ${JSON.stringify(result)}`);\n\n          throw new Error(`Compiling ${filePath} resulted in a MIME type of ${result.mimeType}, which we don't know how to handle`);\n        }\n\n        return yield _this4.compileUncached(`${filePath}.${_mimeTypes2.default.extension(result.mimeType || 'txt')}`, hashInfo, compiler);\n      }\n    })();\n  }\n\n  /**\r\n   * Pre-caches an entire directory of files recursively. Usually used for\r\n   * building custom compiler tooling.\r\n   *\r\n   * @param  {string} rootDirectory  The top-level directory to compile\r\n   *\r\n   * @param  {Function} shouldCompile (optional)  A Function which allows the\r\n   *                                  caller to disable compiling certain files.\r\n   *                                  It takes a fully-qualified path to a file,\r\n   *                                  and should return a Boolean.\r\n   *\r\n   * @return {Promise}  Completion.\r\n   */\n  compileAll(rootDirectory) {\n    var _this5 = this;\n\n    let shouldCompile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return _asyncToGenerator(function* () {\n      let should = shouldCompile || function () {\n        return true;\n      };\n\n      yield (0, _forAllFiles.forAllFiles)(rootDirectory, function (f) {\n        if (!should(f)) return;\n\n        d(`Compiling ${f}`);\n        return _this5.compile(f, _this5.compilersByMimeType);\n      });\n    })();\n  }\n\n  listenToCompileEvents() {\n    return (0, _browserSignal.listen)('electron-compile-compiled-file').map((_ref3) => {\n      var _ref4 = _slicedToArray(_ref3, 1);\n\n      let x = _ref4[0];\n      return x;\n    });\n  }\n\n  /*\r\n   * Sync Methods\r\n   */\n\n  compileSync(filePath) {\n    return this.readOnlyMode ? this.compileReadOnlySync(filePath) : this.fullCompileSync(filePath);\n  }\n\n  static createReadonlyFromConfigurationSync(rootCacheDir, appRoot) {\n    let fallbackCompiler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');\n    let buf = _fs2.default.readFileSync(target);\n    let info = JSON.parse(_zlib2.default.gunzipSync(buf));\n\n    let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);\n\n    let compilers = Object.keys(info.compilers).reduce((acc, x) => {\n      let cur = info.compilers[x];\n      acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);\n\n      return acc;\n    }, {});\n\n    return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler);\n  }\n\n  static createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType) {\n    let fallbackCompiler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');\n    let buf = _fs2.default.readFileSync(target);\n    let info = JSON.parse(_zlib2.default.gunzipSync(buf));\n\n    let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);\n\n    Object.keys(info.compilers).forEach(x => {\n      let cur = info.compilers[x];\n      compilersByMimeType[x].compilerOptions = cur.compilerOptions;\n    });\n\n    return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler);\n  }\n\n  saveConfigurationSync() {\n    let serializedCompilerOpts = Object.keys(this.compilersByMimeType).reduce((acc, x) => {\n      let compiler = this.compilersByMimeType[x];\n      let Klass = Object.getPrototypeOf(compiler).constructor;\n\n      let val = {\n        name: Klass.name,\n        inputMimeTypes: Klass.getInputMimeTypes(),\n        compilerOptions: compiler.compilerOptions,\n        compilerVersion: compiler.getCompilerVersion()\n      };\n\n      acc[x] = val;\n      return acc;\n    }, {});\n\n    let info = {\n      fileChangeCache: this.fileChangeCache.getSavedData(),\n      compilers: serializedCompilerOpts\n    };\n\n    let target = _path2.default.join(this.rootCacheDir, 'compiler-info.json.gz');\n    let buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify(info)));\n    _fs2.default.writeFileSync(target, buf);\n  }\n\n  compileReadOnlySync(filePath) {\n    // We guarantee that node_modules are always shipped directly\n    let type = _mimeTypes2.default.lookup(filePath);\n    if (_fileChangeCache2.default.isInNodeModules(filePath)) {\n      return {\n        mimeType: type || 'application/javascript',\n        code: _fs2.default.readFileSync(filePath, 'utf8')\n      };\n    }\n\n    let hashInfo = this.fileChangeCache.getHashForPathSync(filePath);\n\n    // We guarantee that node_modules are always shipped directly\n    if (hashInfo.isInNodeModules) {\n      return {\n        mimeType: type,\n        code: hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8')\n      };\n    }\n\n    // NB: Here, we're basically only using the compiler here to find\n    // the appropriate CompileCache\n    let compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];\n\n    // NB: We don't put this into shouldPassthrough because Inline HTML\n    // compiler is technically of type finalForms (i.e. a browser can\n    // natively handle this content), yet its compiler is\n    // InlineHtmlCompiler. However, we still want to catch standard CSS files\n    // which will be processed by PassthroughCompiler.\n    if (finalForms[type] && !compiler) {\n      compiler = this.getPassthroughCompiler();\n    }\n\n    if (!compiler) {\n      compiler = this.fallbackCompiler;\n\n      var _compiler$getSync = compiler.getSync(filePath);\n\n      let code = _compiler$getSync.code,\n          binaryData = _compiler$getSync.binaryData,\n          mimeType = _compiler$getSync.mimeType;\n\n      return { code: code || binaryData, mimeType };\n    }\n\n    let cache = this.cachesForCompilers.get(compiler);\n\n    var _cache$getSync = cache.getSync(filePath);\n\n    let code = _cache$getSync.code,\n        binaryData = _cache$getSync.binaryData,\n        mimeType = _cache$getSync.mimeType;\n\n\n    code = code || binaryData;\n    if (!code || !mimeType) {\n      throw new Error(`Asked to compile ${filePath} in production, is this file not precompiled?`);\n    }\n\n    return { code, mimeType };\n  }\n\n  fullCompileSync(filePath) {\n    d(`Compiling ${filePath}`);\n\n    let hashInfo = this.fileChangeCache.getHashForPathSync(filePath);\n    let type = _mimeTypes2.default.lookup(filePath);\n\n    (0, _browserSignal.send)('electron-compile-compiled-file', { filePath, mimeType: type });\n\n    if (hashInfo.isInNodeModules) {\n      let code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');\n      code = CompilerHost.fixNodeModulesSourceMappingSync(code, filePath, this.fileChangeCache.appRoot);\n      return { code, mimeType: type };\n    }\n\n    let compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];\n\n    if (!compiler) {\n      d(`Falling back to passthrough compiler for ${filePath}`);\n      compiler = this.fallbackCompiler;\n    }\n\n    if (!compiler) {\n      throw new Error(`Couldn't find a compiler for ${filePath}`);\n    }\n\n    let cache = this.cachesForCompilers.get(compiler);\n    return cache.getOrFetchSync(filePath, (filePath, hashInfo) => this.compileUncachedSync(filePath, hashInfo, compiler));\n  }\n\n  compileUncachedSync(filePath, hashInfo, compiler) {\n    let inputMimeType = _mimeTypes2.default.lookup(filePath);\n\n    if (hashInfo.isFileBinary) {\n      return {\n        binaryData: hashInfo.binaryData || _fs2.default.readFileSync(filePath),\n        mimeType: inputMimeType,\n        dependentFiles: []\n      };\n    }\n\n    let ctx = {};\n    let code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');\n\n    if (!compiler.shouldCompileFileSync(code, ctx)) {\n      d(`Compiler returned false for shouldCompileFile: ${filePath}`);\n      return { code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] };\n    }\n\n    let dependentFiles = compiler.determineDependentFilesSync(code, filePath, ctx);\n\n    let result = compiler.compileSync(code, filePath, ctx);\n\n    let shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';\n\n    let isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);\n\n    if (finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough) {\n      // Got something we can use in-browser, let's return it\n      return Object.assign(result, { dependentFiles });\n    } else {\n      d(`Recursively compiling result of ${filePath} with non-final MIME type ${result.mimeType}, input was ${inputMimeType}`);\n\n      hashInfo = Object.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);\n      compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];\n\n      if (!compiler) {\n        d(`Recursive compile failed - intermediate result: ${JSON.stringify(result)}`);\n\n        throw new Error(`Compiling ${filePath} resulted in a MIME type of ${result.mimeType}, which we don't know how to handle`);\n      }\n\n      return this.compileUncachedSync(`${filePath}.${_mimeTypes2.default.extension(result.mimeType || 'txt')}`, hashInfo, compiler);\n    }\n  }\n\n  compileAllSync(rootDirectory) {\n    let shouldCompile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    let should = shouldCompile || function () {\n      return true;\n    };\n\n    (0, _forAllFiles.forAllFilesSync)(rootDirectory, f => {\n      if (!should(f)) return;\n      return this.compileSync(f, this.compilersByMimeType);\n    });\n  }\n\n  /*\r\n   * Other stuff\r\n   */\n\n  /**\r\n   * Returns the passthrough compiler\r\n   *\r\n   * @private\r\n   */\n  getPassthroughCompiler() {\n    return this.compilersByMimeType['text/plain'];\n  }\n\n  /**\r\n   * Determines whether we should even try to compile the content. Note that in\r\n   * some cases, content will still be in cache even if this returns true, and\r\n   * in other cases (isInNodeModules), we'll know explicitly to not even bother\r\n   * looking in the cache.\r\n   *\r\n   * @private\r\n   */\n  static shouldPassthrough(hashInfo) {\n    return hashInfo.isMinified || hashInfo.isInNodeModules || hashInfo.hasSourceMap || hashInfo.isFileBinary;\n  }\n\n  /**\r\n   * Look at the code of a node modules and see the sourceMapping path.\r\n   * If there is any, check the path and try to fix it with and\r\n   * root relative path.\r\n   * @private\r\n   */\n  static fixNodeModulesSourceMapping(sourceCode, sourcePath, appRoot) {\n    return _asyncToGenerator(function* () {\n      let regexSourceMapping = /\\/\\/#.*sourceMappingURL=(?!data:)([^\"'].*)/i;\n      let sourceMappingCheck = sourceCode.match(regexSourceMapping);\n\n      if (sourceMappingCheck && sourceMappingCheck[1] && sourceMappingCheck[1] !== '') {\n        let sourceMapPath = sourceMappingCheck[1];\n\n        try {\n          yield _promise.pfs.stat(sourceMapPath);\n        } catch (error) {\n          let normRoot = _path2.default.normalize(appRoot);\n          let absPathToModule = _path2.default.dirname(sourcePath.replace(normRoot, '').substring(1));\n          let newMapPath = _path2.default.join(absPathToModule, sourceMapPath);\n\n          return sourceCode.replace(regexSourceMapping, `//# sourceMappingURL=${newMapPath}`);\n        }\n      }\n\n      return sourceCode;\n    })();\n  }\n\n  /**\r\n   * Look at the code of a node modules and see the sourceMapping path.\r\n   * If there is any, check the path and try to fix it with and\r\n   * root relative path.\r\n   * @private\r\n   */\n  static fixNodeModulesSourceMappingSync(sourceCode, sourcePath, appRoot) {\n    let regexSourceMapping = /\\/\\/#.*sourceMappingURL=(?!data:)([^\"'].*)/i;\n    let sourceMappingCheck = sourceCode.match(regexSourceMapping);\n\n    if (sourceMappingCheck && sourceMappingCheck[1] && sourceMappingCheck[1] !== '') {\n      let sourceMapPath = sourceMappingCheck[1];\n\n      try {\n        _fs2.default.statSync(sourceMapPath);\n      } catch (error) {\n        let normRoot = _path2.default.normalize(appRoot);\n        let absPathToModule = _path2.default.dirname(sourcePath.replace(normRoot, '').substring(1));\n        let newMapPath = _path2.default.join(absPathToModule, sourceMapPath);\n\n        return sourceCode.replace(regexSourceMapping, `//# sourceMappingURL=${newMapPath}`);\n      }\n    }\n\n    return sourceCode;\n  }\n}\nexports.default = CompilerHost;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21waWxlci1ob3N0LmpzIl0sIm5hbWVzIjpbImQiLCJyZXF1aXJlIiwiaW5pdCIsImZpbmFsRm9ybXMiLCJDb21waWxlckhvc3QiLCJjb25zdHJ1Y3RvciIsInJvb3RDYWNoZURpciIsImNvbXBpbGVycyIsImZpbGVDaGFuZ2VDYWNoZSIsInJlYWRPbmx5TW9kZSIsImZhbGxiYWNrQ29tcGlsZXIiLCJzb3VyY2VNYXBQYXRoIiwiY29tcGlsZXJzQnlNaW1lVHlwZSIsIk9iamVjdCIsImFzc2lnbiIsImFwcFJvb3QiLCJjYWNoZXNGb3JDb21waWxlcnMiLCJrZXlzIiwicmVkdWNlIiwiYWNjIiwieCIsImNvbXBpbGVyIiwiaGFzIiwic2V0IiwiY3JlYXRlRnJvbUNvbXBpbGVyIiwiTWFwIiwiY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvbiIsInRhcmdldCIsImpvaW4iLCJidWYiLCJyZWFkRmlsZSIsImluZm8iLCJKU09OIiwicGFyc2UiLCJndW56aXAiLCJsb2FkRnJvbURhdGEiLCJjdXIiLCJuYW1lIiwiY29tcGlsZXJWZXJzaW9uIiwiY29tcGlsZXJPcHRpb25zIiwiaW5wdXRNaW1lVHlwZXMiLCJjcmVhdGVGcm9tQ29uZmlndXJhdGlvbiIsImZvckVhY2giLCJzYXZlQ29uZmlndXJhdGlvbiIsInNlcmlhbGl6ZWRDb21waWxlck9wdHMiLCJLbGFzcyIsImdldFByb3RvdHlwZU9mIiwidmFsIiwiZ2V0SW5wdXRNaW1lVHlwZXMiLCJnZXRDb21waWxlclZlcnNpb24iLCJnZXRTYXZlZERhdGEiLCJnemlwIiwiQnVmZmVyIiwic3RyaW5naWZ5Iiwid3JpdGVGaWxlIiwiY29tcGlsZSIsImZpbGVQYXRoIiwiY29tcGlsZVJlYWRPbmx5IiwiZnVsbENvbXBpbGUiLCJ0eXBlIiwibG9va3VwIiwiaXNJbk5vZGVNb2R1bGVzIiwibWltZVR5cGUiLCJjb2RlIiwiaGFzaEluZm8iLCJnZXRIYXNoRm9yUGF0aCIsInNob3VsZFBhc3N0aHJvdWdoIiwiZ2V0UGFzc3Rocm91Z2hDb21waWxlciIsImdldCIsImJpbmFyeURhdGEiLCJjYWNoZSIsIkVycm9yIiwic291cmNlQ29kZSIsImZpeE5vZGVNb2R1bGVzU291cmNlTWFwcGluZyIsImdldE9yRmV0Y2giLCJjb21waWxlVW5jYWNoZWQiLCJpbnB1dE1pbWVUeXBlIiwiaXNGaWxlQmluYXJ5IiwiZGVwZW5kZW50RmlsZXMiLCJjdHgiLCJzaG91bGRDb21waWxlRmlsZSIsImRldGVybWluZURlcGVuZGVudEZpbGVzIiwicmVzdWx0Iiwic2hvdWxkSW5saW5lSHRtbGlmeSIsImlzUGFzc3Rocm91Z2giLCJleHRlbnNpb24iLCJjb21waWxlQWxsIiwicm9vdERpcmVjdG9yeSIsInNob3VsZENvbXBpbGUiLCJzaG91bGQiLCJmIiwibGlzdGVuVG9Db21waWxlRXZlbnRzIiwibWFwIiwiY29tcGlsZVN5bmMiLCJjb21waWxlUmVhZE9ubHlTeW5jIiwiZnVsbENvbXBpbGVTeW5jIiwiY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvblN5bmMiLCJyZWFkRmlsZVN5bmMiLCJndW56aXBTeW5jIiwiY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb25TeW5jIiwic2F2ZUNvbmZpZ3VyYXRpb25TeW5jIiwiZ3ppcFN5bmMiLCJ3cml0ZUZpbGVTeW5jIiwiZ2V0SGFzaEZvclBhdGhTeW5jIiwiZ2V0U3luYyIsImZpeE5vZGVNb2R1bGVzU291cmNlTWFwcGluZ1N5bmMiLCJnZXRPckZldGNoU3luYyIsImNvbXBpbGVVbmNhY2hlZFN5bmMiLCJzaG91bGRDb21waWxlRmlsZVN5bmMiLCJkZXRlcm1pbmVEZXBlbmRlbnRGaWxlc1N5bmMiLCJjb21waWxlQWxsU3luYyIsImlzTWluaWZpZWQiLCJoYXNTb3VyY2VNYXAiLCJzb3VyY2VQYXRoIiwicmVnZXhTb3VyY2VNYXBwaW5nIiwic291cmNlTWFwcGluZ0NoZWNrIiwibWF0Y2giLCJzdGF0IiwiZXJyb3IiLCJub3JtUm9vdCIsIm5vcm1hbGl6ZSIsImFic1BhdGhUb01vZHVsZSIsImRpcm5hbWUiLCJyZXBsYWNlIiwic3Vic3RyaW5nIiwibmV3TWFwUGF0aCIsInN0YXRTeW5jIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBSUE7Ozs7OztBQUZBLE1BQU1BLElBQUlDLFFBQVEsT0FBUixFQUFpQixnQ0FBakIsQ0FBVjs7QUFJQUEsUUFBUSxrQkFBUixFQUE0QkMsSUFBNUI7O0FBRUE7QUFDQSxNQUFNQyxhQUFhO0FBQ2pCLHFCQUFtQixJQURGO0FBRWpCLDRCQUEwQixJQUZUO0FBR2pCLGVBQWEsSUFISTtBQUlqQixjQUFZLElBSks7QUFLakIsbUJBQWlCLElBTEE7QUFNakIsc0JBQW9CO0FBTkgsQ0FBbkI7O0FBU0E7Ozs7Ozs7Ozs7Ozs7O0FBY2UsTUFBTUMsWUFBTixDQUFtQjtBQUNoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBQyxjQUFZQyxZQUFaLEVBQTBCQyxTQUExQixFQUFxQ0MsZUFBckMsRUFBc0RDLFlBQXRELEVBQW1IO0FBQUEsUUFBL0NDLGdCQUErQyx1RUFBNUIsSUFBNEI7QUFBQSxRQUF0QkMsYUFBc0IsdUVBQU4sSUFBTTs7QUFDakgsUUFBSUMsc0JBQXNCQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQlAsU0FBbEIsQ0FBMUI7QUFDQU0sV0FBT0MsTUFBUCxDQUFjLElBQWQsRUFBb0IsRUFBQ1IsWUFBRCxFQUFlTSxtQkFBZixFQUFvQ0osZUFBcEMsRUFBcURDLFlBQXJELEVBQW1FQyxnQkFBbkUsRUFBcEI7QUFDQSxTQUFLSyxPQUFMLEdBQWUsS0FBS1AsZUFBTCxDQUFxQk8sT0FBcEM7O0FBRUEsU0FBS0Msa0JBQUwsR0FBMEJILE9BQU9JLElBQVAsQ0FBWUwsbUJBQVosRUFBaUNNLE1BQWpDLENBQXdDLENBQUNDLEdBQUQsRUFBTUMsQ0FBTixLQUFZO0FBQzVFLFVBQUlDLFdBQVdULG9C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QSxRQUFJQyxzQkFBc0JBLG1CQUFtQixDQUFuQixDQUF0QixJQUErQ0EsbUJBQW1CLENBQW5CLE1BQTBCLEVBQTdFLEVBQWdGO0FBQzlFLFVBQUl4RyxnQkFBZ0J3RyxtQkFBbUIsQ0FBbkIsQ0FBcEI7O0FBRUEsVUFBSTtBQUNGLHFCQUFHVyxRQUFILENBQVluSCxhQUFaO0FBQ0QsT0FGRCxDQUVFLE9BQU8yRyxLQUFQLEVBQWM7QUFDZCxZQUFJQyxXQUFXLGVBQUtDLFNBQUwsQ0FBZXpHLE9BQWYsQ0FBZjtBQUNBLFlBQUkwRyxrQkFBa0IsZUFBS0MsT0FBTCxDQUFhVCxXQUFXVSxPQUFYLENBQW1CSixRQUFuQixFQUE2QixFQUE3QixFQUFpQ0ssU0FBakMsQ0FBMkMsQ0FBM0MsQ0FBYixDQUF0QjtBQUNBLFlBQUlDLGFBQWEsZUFBS2pHLElBQUwsQ0FBVTZGLGVBQVYsRUFBMkI5RyxhQUEzQixDQUFqQjs7QUFFQSxlQUFPNkQsV0FBV21ELE9BQVgsQ0FBbUJULGtCQUFuQixFQUF3Qyx3QkFBdUJXLFVBQVcsRUFBMUUsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsV0FBT3JELFVBQVA7QUFDRDtBQXpvQitCO2tCQUFicEUsWSIsImZpbGUiOiJjb21waWxlci1ob3N0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1pbWVUeXBlcyBmcm9tICdAcGF1bGNiZXR0cy9taW1lLXR5cGVzJztcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQge3BmcywgcHpsaWJ9IGZyb20gJy4vcHJvbWlzZSc7XHJcblxyXG5pbXBvcnQge2ZvckFsbEZpbGVzLCBmb3JBbGxGaWxlc1N5bmN9IGZyb20gJy4vZm9yLWFsbC1maWxlcyc7XHJcbmltcG9ydCBDb21waWxlQ2FjaGUgZnJvbSAnLi9jb21waWxlLWNhY2hlJztcclxuaW1wb3J0IEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSAnLi9maWxlLWNoYW5nZS1jYWNoZSc7XHJcbmltcG9ydCBSZWFkT25seUNvbXBpbGVyIGZyb20gJy4vcmVhZC1vbmx5LWNvbXBpbGVyJztcclxuaW1wb3J0IHtsaXN0ZW4sIHNlbmR9IGZyb20gJy4vYnJvd3Nlci1zaWduYWwnO1xyXG5cclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6Y29tcGlsZXItaG9zdCcpO1xyXG5cclxuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tYXAnO1xyXG5cclxucmVxdWlyZSgnLi9yaWctbWltZS10eXBlcycpLmluaXQoKTtcclxuXHJcbi8vIFRoaXMgaXNuJ3QgZXZlbiBteVxyXG5jb25zdCBmaW5hbEZvcm1zID0ge1xyXG4gICd0ZXh0L2phdmFzY3JpcHQnOiB0cnVlLFxyXG4gICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JzogdHJ1ZSxcclxuICAndGV4dC9odG1sJzogdHJ1ZSxcclxuICAndGV4dC9jc3MnOiB0cnVlLFxyXG4gICdpbWFnZS9zdmcreG1sJzogdHJ1ZSxcclxuICAnYXBwbGljYXRpb24vanNvbic6IHRydWVcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGlzIHRoZSB0b3AtbGV2ZWwgY2xhc3MgdGhhdCBlbmNhcHN1bGF0ZXMgYWxsIG9mIHRoZSBsb2dpYyBvZlxyXG4gKiBjb21waWxpbmcgYW5kIGNhY2hpbmcgYXBwbGljYXRpb24gY29kZS4gSWYgeW91J3JlIGxvb2tpbmcgZm9yIGEgXCJNYWluIGNsYXNzXCIsXHJcbiAqIHRoaXMgaXMgaXQuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgY2FuIGJlIGNyZWF0ZWQgZGlyZWN0bHkgYnV0IGl0IGlzIHVzdWFsbHkgY3JlYXRlZCB2aWEgdGhlIG1ldGhvZHNcclxuICogaW4gY29uZmlnLXBhcnNlciwgd2hpY2ggd2lsbCBhbW9uZyBvdGhlciB0aGluZ3MsIHNldCB1cCB0aGUgY29tcGlsZXIgb3B0aW9uc1xyXG4gKiBnaXZlbiBhIHByb2plY3Qgcm9vdC5cclxuICpcclxuICogQ29tcGlsZXJIb3N0IGlzIGFsc28gdGhlIHRvcC1sZXZlbCBjbGFzcyB0aGF0IGtub3dzIGhvdyB0byBzZXJpYWxpemUgYWxsIG9mIHRoZVxyXG4gKiBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gcmVjcmVhdGUgaXRzZWxmLCBlaXRoZXIgYXMgYSBkZXZlbG9wbWVudCBob3N0IChpLmUuXHJcbiAqIHdpbGwgYWxsb3cgY2FjaGUgbWlzc2VzIGFuZCBhY3R1YWwgY29tcGlsYXRpb24pLCBvciBhcyBhIHJlYWQtb25seSB2ZXJzaW9uIG9mXHJcbiAqIGl0c2VsZiBmb3IgcHJvZHVjdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBpbGVySG9zdCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBDb21waWxlckhvc3QuIFlvdSBwcm9iYWJseSB3YW50IHRvIHVzZSB0aGUgbWV0aG9kc1xyXG4gICAqIGluIGNvbmZpZy1wYXJzZXIgZm9yIGRldmVsb3BtZW50LCBvciB7QGxpbmsgY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvbn1cclxuICAgKiBmb3IgcHJvZHVjdGlvbiBpbnN0ZWFkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgIFRoZSByb290IGRpcmVjdG9yeSB0byB1c2UgZm9yIHRoZSBjYWNoZVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb21waWxlcnMgIGFuIE9iamVjdCB3aG9zZSBrZXlzIGFyZSBpbnB1dCBNSU1FIHR5cGVzIGFuZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aG9zZSB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiBDb21waWxlckJhc2UuIENyZWF0ZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHZpYSB0aGUge0BsaW5rIGNyZWF0ZUNvbXBpbGVyc30gbWV0aG9kIGluXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy1wYXJzZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtGaWxlQ2hhbmdlZENhY2hlfSBmaWxlQ2hhbmdlQ2FjaGUgIEEgZmlsZS1jaGFuZ2UgY2FjaGUgdGhhdCBpc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxseSBwcmUtbG9hZGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gcmVhZE9ubHlNb2RlICBJZiBUcnVlLCBjYWNoZSBtaXNzZXMgd2lsbCBmYWlsIGFuZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGlsYXRpb24gd2lsbCBub3QgYmUgYXR0ZW1wdGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Q29tcGlsZXJCYXNlfSBmYWxsYmFja0NvbXBpbGVyIChvcHRpb25hbCkgIFdoZW4gYSBmaWxlIGlzIGNvbXBpbGVkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNvbXBpbGVyLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGNvbXBpbGVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBJZlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCB3aWxsIGZhaWwgY29tcGlsYXRpb24uIEEgZ29vZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGUgZmFsbGJhY2sgaXMgdGhlIGNvbXBpbGVyIGZvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dC9wbGFpbicsIHdoaWNoIGlzIGd1YXJhbnRlZWQgdG8gYmVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VNYXBQYXRoIChvcHRpb25hbCkgVGhlIGRpcmVjdG9yeSB0byBzdG9yZSBzb3VyY2VtYXAgc2VwYXJhdGVseVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGNvbXBpbGVyIG9wdGlvbiBlbmFibGVkIHRvIGVtaXQuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB0byBjYWNoZVBhdGggaWYgbm90IHNwZWNpZmllZC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihyb290Q2FjaGVEaXIsIGNvbXBpbGVycywgZmlsZUNoYW5nZUNhY2hlLCByZWFkT25seU1vZGUsIGZhbGxiYWNrQ29tcGlsZXIgPSBudWxsLCBzb3VyY2VNYXBQYXRoID0gbnVsbCkge1xyXG4gICAgbGV0IGNvbXBpbGVyc0J5TWltZVR5cGUgPSBPYmplY3QuYXNzaWduKHt9LCBjb21waWxlcnMpO1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7cm9vdENhY2hlRGlyLCBjb21waWxlcnNCeU1pbWVUeXBlLCBmaWxlQ2hhbmdlQ2FjaGUsIHJlYWRPbmx5TW9kZSwgZmFsbGJhY2tDb21waWxlcn0pO1xyXG4gICAgdGhpcy5hcHBSb290ID0gdGhpcy5maWxlQ2hhbmdlQ2FjaGUuYXBwUm9vdDtcclxuXHJcbiAgICB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycyA9IE9iamVjdC5rZXlzKGNvbXBpbGVyc0J5TWltZVR5cGUpLnJlZHVjZSgoYWNjLCB4KSA9PiB7XHJcbiAgICAgIGxldCBjb21waWxlciA9IGNvbXBpbGVyc0J5TWltZVR5cGVbeF07XHJcbiAgICAgIGlmIChhY2MuaGFzKGNvbXBpbGVyKSkgcmV0dXJuIGFjYztcclxuXHJcbiAgICAgIGFjYy5zZXQoXHJcbiAgICAgICAgY29tcGlsZXIsXHJcbiAgICAgICAgQ29tcGlsZUNhY2hlLmNyZWF0ZUZyb21Db21waWxlcihyb290Q2FjaGVEaXIsIGNvbXBpbGVyLCBmaWxlQ2hhbmdlQ2FjaGUsIHJlYWRPbmx5TW9kZSwgc291cmNlTWFwUGF0aCkpO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwgbmV3IE1hcCgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBwcm9kdWN0aW9uLW1vZGUgQ29tcGlsZXJIb3N0IGZyb20gdGhlIHByZXZpb3VzbHkgc2F2ZWRcclxuICAgKiBjb25maWd1cmF0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAgVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHVzZSBmb3IgdGhlIGNhY2hlLiBUaGlzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlIG11c3QgaGF2ZSBjYWNoZSBpbmZvcm1hdGlvbiBzYXZlZCB2aWFcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIHNhdmVDb25maWd1cmF0aW9ufVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Q29tcGlsZXJCYXNlfSBmYWxsYmFja0NvbXBpbGVyIChvcHRpb25hbCkgIFdoZW4gYSBmaWxlIGlzIGNvbXBpbGVkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNvbXBpbGVyLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGNvbXBpbGVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBJZlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCB3aWxsIGZhaWwgY29tcGlsYXRpb24uIEEgZ29vZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGUgZmFsbGJhY2sgaXMgdGhlIGNvbXBpbGVyIGZvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dC9wbGFpbicsIHdoaWNoIGlzIGd1YXJhbnRlZWQgdG8gYmVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8Q29tcGlsZXJIb3N0Pn0gIEEgcmVhZC1vbmx5IENvbXBpbGVySG9zdFxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9uKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgZmFsbGJhY2tDb21waWxlcj1udWxsKSB7XHJcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHBmcy5yZWFkRmlsZSh0YXJnZXQpO1xyXG4gICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKGF3YWl0IHB6bGliLmd1bnppcChidWYpKTtcclxuXHJcbiAgICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoaW5mby5maWxlQ2hhbmdlQ2FjaGUsIGFwcFJvb3QsIHRydWUpO1xyXG5cclxuICAgIGxldCBjb21waWxlcnMgPSBPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycykucmVkdWNlKChhY2MsIHgpID0+IHtcclxuICAgICAgbGV0IGN1ciA9IGluZm8uY29tcGlsZXJzW3hdO1xyXG4gICAgICBhY2NbeF0gPSBuZXcgUmVhZE9ubHlDb21waWxlcihjdXIubmFtZSwgY3VyLmNvbXBpbGVyVmVyc2lvbiwgY3VyLmNvbXBpbGVyT3B0aW9ucywgY3VyLmlucHV0TWltZVR5cGVzKTtcclxuXHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnMsIGZpbGVDaGFuZ2VDYWNoZSwgdHJ1ZSwgZmFsbGJhY2tDb21waWxlcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgZGV2ZWxvcG1lbnQtbW9kZSBDb21waWxlckhvc3QgZnJvbSB0aGUgcHJldmlvdXNseSBzYXZlZFxyXG4gICAqIGNvbmZpZ3VyYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAgVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHVzZSBmb3IgdGhlIGNhY2hlLiBUaGlzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlIG11c3QgaGF2ZSBjYWNoZSBpbmZvcm1hdGlvbiBzYXZlZCB2aWFcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIHNhdmVDb25maWd1cmF0aW9ufVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb21waWxlcnNCeU1pbWVUeXBlICBhbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgaW5wdXQgTUlNRVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMgYW5kIHdob3NlIHZhbHVlcyBhcmUgaW5zdGFuY2VzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBDb21waWxlckJhc2UuIENyZWF0ZSB0aGlzIHZpYSB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBjcmVhdGVDb21waWxlcnN9IG1ldGhvZCBpblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLXBhcnNlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0NvbXBpbGVyQmFzZX0gZmFsbGJhY2tDb21waWxlciAob3B0aW9uYWwpICBXaGVuIGEgZmlsZSBpcyBjb21waWxlZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBkb2Vzbid0IGhhdmUgYSBtYXRjaGluZyBjb21waWxlcixcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBjb21waWxlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gSWZcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgd2lsbCBmYWlsIGNvbXBpbGF0aW9uLiBBIGdvb2RcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRlIGZhbGxiYWNrIGlzIHRoZSBjb21waWxlciBmb3JcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQvcGxhaW4nLCB3aGljaCBpcyBndWFyYW50ZWVkIHRvIGJlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbXBpbGVySG9zdD59ICBBIHJlYWQtb25seSBDb21waWxlckhvc3RcclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb24ocm9vdENhY2hlRGlyLCBhcHBSb290LCBjb21waWxlcnNCeU1pbWVUeXBlLCBmYWxsYmFja0NvbXBpbGVyPW51bGwpIHtcclxuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XHJcbiAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKHRhcmdldCk7XHJcbiAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoYXdhaXQgcHpsaWIuZ3VuemlwKGJ1ZikpO1xyXG5cclxuICAgIGxldCBmaWxlQ2hhbmdlQ2FjaGUgPSBGaWxlQ2hhbmdlZENhY2hlLmxvYWRGcm9tRGF0YShpbmZvLmZpbGVDaGFuZ2VDYWNoZSwgYXBwUm9vdCwgZmFsc2UpO1xyXG5cclxuICAgIE9iamVjdC5rZXlzKGluZm8uY29tcGlsZXJzKS5mb3JFYWNoKCh4KSA9PiB7XHJcbiAgICAgIGxldCBjdXIgPSBpbmZvLmNvbXBpbGVyc1t4XTtcclxuICAgICAgY29tcGlsZXJzQnlNaW1lVHlwZVt4XS5jb21waWxlck9wdGlvbnMgPSBjdXIuY29tcGlsZXJPcHRpb25zO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnNCeU1pbWVUeXBlLCBmaWxlQ2hhbmdlQ2FjaGUsIGZhbHNlLCBmYWxsYmFja0NvbXBpbGVyKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBTYXZlcyB0aGUgY3VycmVudCBjb21waWxlciBjb25maWd1cmF0aW9uIHRvIGEgZmlsZSB0aGF0XHJcbiAgICoge0BsaW5rIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb259IGNhbiB1c2UgdG8gcmVjcmVhdGUgdGhlIGN1cnJlbnRcclxuICAgKiBjb21waWxlciBlbnZpcm9ubWVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gIENvbXBsZXRpb25cclxuICAgKi9cclxuICBhc3luYyBzYXZlQ29uZmlndXJhdGlvbigpIHtcclxuICAgIGxldCBzZXJpYWxpemVkQ29tcGlsZXJPcHRzID0gT2JqZWN0LmtleXModGhpcy5jb21waWxlcnNCeU1pbWVUeXBlKS5yZWR1Y2UoKGFjYywgeCkgPT4ge1xyXG4gICAgICBsZXQgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbeF07XHJcbiAgICAgIGxldCBLbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21waWxlcikuY29uc3RydWN0b3I7XHJcblxyXG4gICAgICBsZXQgdmFsID0ge1xyXG4gICAgICAgIG5hbWU6IEtsYXNzLm5hbWUsXHJcbiAgICAgICAgaW5wdXRNaW1lVHlwZXM6IEtsYXNzLmdldElucHV0TWltZVR5cGVzKCksXHJcbiAgICAgICAgY29tcGlsZXJPcHRpb25zOiBjb21waWxlci5jb21waWxlck9wdGlvbnMsXHJcbiAgICAgICAgY29tcGlsZXJWZXJzaW9uOiBjb21waWxlci5nZXRDb21waWxlclZlcnNpb24oKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgYWNjW3hdID0gdmFsO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30pO1xyXG5cclxuICAgIGxldCBpbmZvID0ge1xyXG4gICAgICBmaWxlQ2hhbmdlQ2FjaGU6IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldFNhdmVkRGF0YSgpLFxyXG4gICAgICBjb21waWxlcnM6IHNlcmlhbGl6ZWRDb21waWxlck9wdHNcclxuICAgIH07XHJcblxyXG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbih0aGlzLnJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHB6bGliLmd6aXAobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShpbmZvKSkpO1xyXG4gICAgYXdhaXQgcGZzLndyaXRlRmlsZSh0YXJnZXQsIGJ1Zik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21waWxlcyBhIGZpbGUgYW5kIHJldHVybnMgdGhlIGNvbXBpbGVkIHJlc3VsdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZVBhdGggIFRoZSBwYXRoIHRvIHRoZSBmaWxlIHRvIGNvbXBpbGVcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8b2JqZWN0Pn0gIEFuIE9iamVjdCB3aXRoIHRoZSBjb21waWxlZCByZXN1bHRcclxuICAgKlxyXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBoYXNoSW5mbyAgVGhlIGhhc2ggaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBnZXRIYXNoRm9yUGF0aFxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2RlICBUaGUgc291cmNlIGNvZGUgaWYgdGhlIGZpbGUgd2FzIGEgdGV4dCBmaWxlXHJcbiAgICogQHByb3BlcnR5IHtCdWZmZXJ9IGJpbmFyeURhdGEgIFRoZSBmaWxlIGlmIGl0IHdhcyBhIGJpbmFyeSBmaWxlXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG1pbWVUeXBlICBUaGUgTUlNRSB0eXBlIHNhdmVkIGluIHRoZSBjYWNoZS5cclxuICAgKiBAcHJvcGVydHkge3N0cmluZ1tdfSBkZXBlbmRlbnRGaWxlcyAgVGhlIGRlcGVuZGVudCBmaWxlcyByZXR1cm5lZCBmcm9tXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGluZyB0aGUgZmlsZSwgaWYgYW55LlxyXG4gICAqL1xyXG4gIGNvbXBpbGUoZmlsZVBhdGgpIHtcclxuICAgIHJldHVybiAodGhpcy5yZWFkT25seU1vZGUgPyB0aGlzLmNvbXBpbGVSZWFkT25seShmaWxlUGF0aCkgOiB0aGlzLmZ1bGxDb21waWxlKGZpbGVQYXRoKSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBjb21waWxhdGlvbiBpbiByZWFkLW9ubHkgbW9kZVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBhc3luYyBjb21waWxlUmVhZE9ubHkoZmlsZVBhdGgpIHtcclxuICAgIC8vIFdlIGd1YXJhbnRlZSB0aGF0IG5vZGVfbW9kdWxlcyBhcmUgYWx3YXlzIHNoaXBwZWQgZGlyZWN0bHlcclxuICAgIGxldCB0eXBlID0gbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCk7XHJcbiAgICBpZiAoRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoZmlsZVBhdGgpKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbWltZVR5cGU6IHR5cGUgfHwgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxyXG4gICAgICAgIGNvZGU6IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBoYXNoSW5mbyA9IGF3YWl0IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoKGZpbGVQYXRoKTtcclxuXHJcbiAgICAvLyBOQjogSGVyZSwgd2UncmUgYmFzaWNhbGx5IG9ubHkgdXNpbmcgdGhlIGNvbXBpbGVyIGhlcmUgdG8gZmluZFxyXG4gICAgLy8gdGhlIGFwcHJvcHJpYXRlIENvbXBpbGVDYWNoZVxyXG4gICAgbGV0IGNvbXBpbGVyID0gQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSA/XHJcbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcclxuICAgICAgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3R5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xyXG5cclxuXHJcbiAgICAvLyBOQjogV2UgZG9uJ3QgcHV0IHRoaXMgaW50byBzaG91bGRQYXNzdGhyb3VnaCBiZWNhdXNlIElubGluZSBIVE1MXHJcbiAgICAvLyBjb21waWxlciBpcyB0ZWNobmljYWxseSBvZiB0eXBlIGZpbmFsRm9ybXMgKGkuZS4gYSBicm93c2VyIGNhblxyXG4gICAgLy8gbmF0aXZlbHkgaGFuZGxlIHRoaXMgY29udGVudCksIHlldCBpdHMgY29tcGlsZXIgaXNcclxuICAgIC8vIElubGluZUh0bWxDb21waWxlci4gSG93ZXZlciwgd2Ugc3RpbGwgd2FudCB0byBjYXRjaCBzdGFuZGFyZCBDU1MgZmlsZXNcclxuICAgIC8vIHdoaWNoIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IFBhc3N0aHJvdWdoQ29tcGlsZXIuXHJcbiAgICBpZiAoZmluYWxGb3Jtc1t0eXBlXSAmJiAhY29tcGlsZXIpIHtcclxuICAgICAgY29tcGlsZXIgPSB0aGlzLmdldFBhc3N0aHJvdWdoQ29tcGlsZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbXBpbGVyKSB7XHJcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5mYWxsYmFja0NvbXBpbGVyO1xyXG5cclxuICAgICAgbGV0IHsgY29kZSwgYmluYXJ5RGF0YSwgbWltZVR5cGUgfSA9IGF3YWl0IGNvbXBpbGVyLmdldChmaWxlUGF0aCk7XHJcbiAgICAgIHJldHVybiB7IGNvZGU6IGNvZGUgfHwgYmluYXJ5RGF0YSwgbWltZVR5cGUgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xyXG4gICAgbGV0IHtjb2RlLCBiaW5hcnlEYXRhLCBtaW1lVHlwZX0gPSBhd2FpdCBjYWNoZS5nZXQoZmlsZVBhdGgpO1xyXG5cclxuICAgIGNvZGUgPSBjb2RlIHx8IGJpbmFyeURhdGE7XHJcbiAgICBpZiAoIWNvZGUgfHwgIW1pbWVUeXBlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgdG8gY29tcGlsZSAke2ZpbGVQYXRofSBpbiBwcm9kdWN0aW9uLCBpcyB0aGlzIGZpbGUgbm90IHByZWNvbXBpbGVkP2ApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIGNvbXBpbGF0aW9uIGluIHJlYWQtd3JpdGUgbW9kZVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBhc3luYyBmdWxsQ29tcGlsZShmaWxlUGF0aCkge1xyXG4gICAgZChgQ29tcGlsaW5nICR7ZmlsZVBhdGh9YCk7XHJcblxyXG4gICAgbGV0IGhhc2hJbmZvID0gYXdhaXQgdGhpcy5maWxlQ2hhbmdlQ2FjaGUuZ2V0SGFzaEZvclBhdGgoZmlsZVBhdGgpO1xyXG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuXHJcbiAgICBzZW5kKCdlbGVjdHJvbi1jb21waWxlLWNvbXBpbGVkLWZpbGUnLCB7IGZpbGVQYXRoLCBtaW1lVHlwZTogdHlwZSB9KTtcclxuXHJcbiAgICBpZiAoaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzKSB7XHJcbiAgICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4Jyk7XHJcbiAgICAgIGNvZGUgPSBhd2FpdCBDb21waWxlckhvc3QuZml4Tm9kZU1vZHVsZXNTb3VyY2VNYXBwaW5nKGNvZGUsIGZpbGVQYXRoLCB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5hcHBSb290KTtcclxuICAgICAgcmV0dXJuIHsgY29kZSwgbWltZVR5cGU6IHR5cGUgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY29tcGlsZXIgPSBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pID9cclxuICAgICAgdGhpcy5nZXRQYXNzdGhyb3VnaENvbXBpbGVyKCkgOlxyXG4gICAgICB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbdHlwZSB8fCAnX19sb2xub3RoZXJlJ107XHJcblxyXG4gICAgaWYgKCFjb21waWxlcikge1xyXG4gICAgICBkKGBGYWxsaW5nIGJhY2sgdG8gcGFzc3Rocm91Z2ggY29tcGlsZXIgZm9yICR7ZmlsZVBhdGh9YCk7XHJcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5mYWxsYmFja0NvbXBpbGVyO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBmaW5kIGEgY29tcGlsZXIgZm9yICR7ZmlsZVBhdGh9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNhY2hlID0gdGhpcy5jYWNoZXNGb3JDb21waWxlcnMuZ2V0KGNvbXBpbGVyKTtcclxuICAgIHJldHVybiBhd2FpdCBjYWNoZS5nZXRPckZldGNoKFxyXG4gICAgICBmaWxlUGF0aCxcclxuICAgICAgKGZpbGVQYXRoLCBoYXNoSW5mbykgPT4gdGhpcy5jb21waWxlVW5jYWNoZWQoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBpbnZva2luZyBjb21waWxlcnMgaW5kZXBlbmRlbnQgb2YgY2FjaGluZ1xyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBhc3luYyBjb21waWxlVW5jYWNoZWQoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikge1xyXG4gICAgbGV0IGlucHV0TWltZVR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuXHJcbiAgICBpZiAoaGFzaEluZm8uaXNGaWxlQmluYXJ5KSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgYmluYXJ5RGF0YTogaGFzaEluZm8uYmluYXJ5RGF0YSB8fCBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZVBhdGgpLFxyXG4gICAgICAgIG1pbWVUeXBlOiBpbnB1dE1pbWVUeXBlLFxyXG4gICAgICAgIGRlcGVuZGVudEZpbGVzOiBbXVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjdHggPSB7fTtcclxuICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4Jyk7XHJcblxyXG4gICAgaWYgKCEoYXdhaXQgY29tcGlsZXIuc2hvdWxkQ29tcGlsZUZpbGUoY29kZSwgY3R4KSkpIHtcclxuICAgICAgZChgQ29tcGlsZXIgcmV0dXJuZWQgZmFsc2UgZm9yIHNob3VsZENvbXBpbGVGaWxlOiAke2ZpbGVQYXRofWApO1xyXG4gICAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZTogbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCksIGRlcGVuZGVudEZpbGVzOiBbXSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBkZXBlbmRlbnRGaWxlcyA9IGF3YWl0IGNvbXBpbGVyLmRldGVybWluZURlcGVuZGVudEZpbGVzKGNvZGUsIGZpbGVQYXRoLCBjdHgpO1xyXG5cclxuICAgIGQoYFVzaW5nIGNvbXBpbGVyIG9wdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkoY29tcGlsZXIuY29tcGlsZXJPcHRpb25zKX1gKTtcclxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjb21waWxlci5jb21waWxlKGNvZGUsIGZpbGVQYXRoLCBjdHgpO1xyXG5cclxuICAgIGxldCBzaG91bGRJbmxpbmVIdG1saWZ5ID1cclxuICAgICAgaW5wdXRNaW1lVHlwZSAhPT0gJ3RleHQvaHRtbCcgJiZcclxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9odG1sJztcclxuXHJcbiAgICBsZXQgaXNQYXNzdGhyb3VnaCA9XHJcbiAgICAgIHJlc3VsdC5taW1lVHlwZSA9PT0gJ3RleHQvcGxhaW4nIHx8XHJcbiAgICAgICFyZXN1bHQubWltZVR5cGUgfHxcclxuICAgICAgQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKTtcclxuXHJcbiAgICBpZiAoKGZpbmFsRm9ybXNbcmVzdWx0Lm1pbWVUeXBlXSAmJiAhc2hvdWxkSW5saW5lSHRtbGlmeSkgfHwgaXNQYXNzdGhyb3VnaCkge1xyXG4gICAgICAvLyBHb3Qgc29tZXRoaW5nIHdlIGNhbiB1c2UgaW4tYnJvd3NlciwgbGV0J3MgcmV0dXJuIGl0XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3VsdCwge2RlcGVuZGVudEZpbGVzfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkKGBSZWN1cnNpdmVseSBjb21waWxpbmcgcmVzdWx0IG9mICR7ZmlsZVBhdGh9IHdpdGggbm9uLWZpbmFsIE1JTUUgdHlwZSAke3Jlc3VsdC5taW1lVHlwZX0sIGlucHV0IHdhcyAke2lucHV0TWltZVR5cGV9YCk7XHJcblxyXG4gICAgICBoYXNoSW5mbyA9IE9iamVjdC5hc3NpZ24oeyBzb3VyY2VDb2RlOiByZXN1bHQuY29kZSwgbWltZVR5cGU6IHJlc3VsdC5taW1lVHlwZSB9LCBoYXNoSW5mbyk7XHJcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3Jlc3VsdC5taW1lVHlwZSB8fCAnX19sb2xub3RoZXJlJ107XHJcblxyXG4gICAgICBpZiAoIWNvbXBpbGVyKSB7XHJcbiAgICAgICAgZChgUmVjdXJzaXZlIGNvbXBpbGUgZmFpbGVkIC0gaW50ZXJtZWRpYXRlIHJlc3VsdDogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfWApO1xyXG5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGluZyAke2ZpbGVQYXRofSByZXN1bHRlZCBpbiBhIE1JTUUgdHlwZSBvZiAke3Jlc3VsdC5taW1lVHlwZX0sIHdoaWNoIHdlIGRvbid0IGtub3cgaG93IHRvIGhhbmRsZWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb21waWxlVW5jYWNoZWQoXHJcbiAgICAgICAgYCR7ZmlsZVBhdGh9LiR7bWltZVR5cGVzLmV4dGVuc2lvbihyZXN1bHQubWltZVR5cGUgfHwgJ3R4dCcpfWAsXHJcbiAgICAgICAgaGFzaEluZm8sIGNvbXBpbGVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZS1jYWNoZXMgYW4gZW50aXJlIGRpcmVjdG9yeSBvZiBmaWxlcyByZWN1cnNpdmVseS4gVXN1YWxseSB1c2VkIGZvclxyXG4gICAqIGJ1aWxkaW5nIGN1c3RvbSBjb21waWxlciB0b29saW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSByb290RGlyZWN0b3J5ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSB0byBjb21waWxlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gc2hvdWxkQ29tcGlsZSAob3B0aW9uYWwpICBBIEZ1bmN0aW9uIHdoaWNoIGFsbG93cyB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZXIgdG8gZGlzYWJsZSBjb21waWxpbmcgY2VydGFpbiBmaWxlcy5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCB0YWtlcyBhIGZ1bGx5LXF1YWxpZmllZCBwYXRoIHRvIGEgZmlsZSxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgc2hvdWxkIHJldHVybiBhIEJvb2xlYW4uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgQ29tcGxldGlvbi5cclxuICAgKi9cclxuICBhc3luYyBjb21waWxlQWxsKHJvb3REaXJlY3RvcnksIHNob3VsZENvbXBpbGU9bnVsbCkge1xyXG4gICAgbGV0IHNob3VsZCA9IHNob3VsZENvbXBpbGUgfHwgZnVuY3Rpb24oKSB7cmV0dXJuIHRydWU7fTtcclxuXHJcbiAgICBhd2FpdCBmb3JBbGxGaWxlcyhyb290RGlyZWN0b3J5LCAoZikgPT4ge1xyXG4gICAgICBpZiAoIXNob3VsZChmKSkgcmV0dXJuO1xyXG5cclxuICAgICAgZChgQ29tcGlsaW5nICR7Zn1gKTtcclxuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZShmLCB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBsaXN0ZW5Ub0NvbXBpbGVFdmVudHMoKSB7XHJcbiAgICByZXR1cm4gbGlzdGVuKCdlbGVjdHJvbi1jb21waWxlLWNvbXBpbGVkLWZpbGUnKS5tYXAoKFt4XSkgPT4geCk7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIFN5bmMgTWV0aG9kc1xyXG4gICAqL1xyXG5cclxuICBjb21waWxlU3luYyhmaWxlUGF0aCkge1xyXG4gICAgcmV0dXJuICh0aGlzLnJlYWRPbmx5TW9kZSA/IHRoaXMuY29tcGlsZVJlYWRPbmx5U3luYyhmaWxlUGF0aCkgOiB0aGlzLmZ1bGxDb21waWxlU3luYyhmaWxlUGF0aCkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb25TeW5jKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgZmFsbGJhY2tDb21waWxlcj1udWxsKSB7XHJcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyh0YXJnZXQpO1xyXG4gICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKHpsaWIuZ3VuemlwU3luYyhidWYpKTtcclxuXHJcbiAgICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoaW5mby5maWxlQ2hhbmdlQ2FjaGUsIGFwcFJvb3QsIHRydWUpO1xyXG5cclxuICAgIGxldCBjb21waWxlcnMgPSBPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycykucmVkdWNlKChhY2MsIHgpID0+IHtcclxuICAgICAgbGV0IGN1ciA9IGluZm8uY29tcGlsZXJzW3hdO1xyXG4gICAgICBhY2NbeF0gPSBuZXcgUmVhZE9ubHlDb21waWxlcihjdXIubmFtZSwgY3VyLmNvbXBpbGVyVmVyc2lvbiwgY3VyLmNvbXBpbGVyT3B0aW9ucywgY3VyLmlucHV0TWltZVR5cGVzKTtcclxuXHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnMsIGZpbGVDaGFuZ2VDYWNoZSwgdHJ1ZSwgZmFsbGJhY2tDb21waWxlcik7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb25TeW5jKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgY29tcGlsZXJzQnlNaW1lVHlwZSwgZmFsbGJhY2tDb21waWxlcj1udWxsKSB7XHJcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyh0YXJnZXQpO1xyXG4gICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKHpsaWIuZ3VuemlwU3luYyhidWYpKTtcclxuXHJcbiAgICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoaW5mby5maWxlQ2hhbmdlQ2FjaGUsIGFwcFJvb3QsIGZhbHNlKTtcclxuXHJcbiAgICBPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycykuZm9yRWFjaCgoeCkgPT4ge1xyXG4gICAgICBsZXQgY3VyID0gaW5mby5jb21waWxlcnNbeF07XHJcbiAgICAgIGNvbXBpbGVyc0J5TWltZVR5cGVbeF0uY29tcGlsZXJPcHRpb25zID0gY3VyLmNvbXBpbGVyT3B0aW9ucztcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBuZXcgQ29tcGlsZXJIb3N0KHJvb3RDYWNoZURpciwgY29tcGlsZXJzQnlNaW1lVHlwZSwgZmlsZUNoYW5nZUNhY2hlLCBmYWxzZSwgZmFsbGJhY2tDb21waWxlcik7XHJcbiAgfVxyXG5cclxuICBzYXZlQ29uZmlndXJhdGlvblN5bmMoKSB7XHJcbiAgICBsZXQgc2VyaWFsaXplZENvbXBpbGVyT3B0cyA9IE9iamVjdC5rZXlzKHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZSkucmVkdWNlKChhY2MsIHgpID0+IHtcclxuICAgICAgbGV0IGNvbXBpbGVyID0gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3hdO1xyXG4gICAgICBsZXQgS2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcGlsZXIpLmNvbnN0cnVjdG9yO1xyXG5cclxuICAgICAgbGV0IHZhbCA9IHtcclxuICAgICAgICBuYW1lOiBLbGFzcy5uYW1lLFxyXG4gICAgICAgIGlucHV0TWltZVR5cGVzOiBLbGFzcy5nZXRJbnB1dE1pbWVUeXBlcygpLFxyXG4gICAgICAgIGNvbXBpbGVyT3B0aW9uczogY29tcGlsZXIuY29tcGlsZXJPcHRpb25zLFxyXG4gICAgICAgIGNvbXBpbGVyVmVyc2lvbjogY29tcGlsZXIuZ2V0Q29tcGlsZXJWZXJzaW9uKClcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGFjY1t4XSA9IHZhbDtcclxuICAgICAgcmV0dXJuIGFjYztcclxuICAgIH0sIHt9KTtcclxuXHJcbiAgICBsZXQgaW5mbyA9IHtcclxuICAgICAgZmlsZUNoYW5nZUNhY2hlOiB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRTYXZlZERhdGEoKSxcclxuICAgICAgY29tcGlsZXJzOiBzZXJpYWxpemVkQ29tcGlsZXJPcHRzXHJcbiAgICB9O1xyXG5cclxuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4odGhpcy5yb290Q2FjaGVEaXIsICdjb21waWxlci1pbmZvLmpzb24uZ3onKTtcclxuICAgIGxldCBidWYgPSB6bGliLmd6aXBTeW5jKG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoaW5mbykpKTtcclxuICAgIGZzLndyaXRlRmlsZVN5bmModGFyZ2V0LCBidWYpO1xyXG4gIH1cclxuXHJcbiAgY29tcGlsZVJlYWRPbmx5U3luYyhmaWxlUGF0aCkge1xyXG4gICAgLy8gV2UgZ3VhcmFudGVlIHRoYXQgbm9kZV9tb2R1bGVzIGFyZSBhbHdheXMgc2hpcHBlZCBkaXJlY3RseVxyXG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuICAgIGlmIChGaWxlQ2hhbmdlZENhY2hlLmlzSW5Ob2RlTW9kdWxlcyhmaWxlUGF0aCkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBtaW1lVHlwZTogdHlwZSB8fCAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXHJcbiAgICAgICAgY29kZTogZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGhhc2hJbmZvID0gdGhpcy5maWxlQ2hhbmdlQ2FjaGUuZ2V0SGFzaEZvclBhdGhTeW5jKGZpbGVQYXRoKTtcclxuXHJcbiAgICAvLyBXZSBndWFyYW50ZWUgdGhhdCBub2RlX21vZHVsZXMgYXJlIGFsd2F5cyBzaGlwcGVkIGRpcmVjdGx5XHJcbiAgICBpZiAoaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbWltZVR5cGU6IHR5cGUsXHJcbiAgICAgICAgY29kZTogaGFzaEluZm8uc291cmNlQ29kZSB8fCBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4JylcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOQjogSGVyZSwgd2UncmUgYmFzaWNhbGx5IG9ubHkgdXNpbmcgdGhlIGNvbXBpbGVyIGhlcmUgdG8gZmluZFxyXG4gICAgLy8gdGhlIGFwcHJvcHJpYXRlIENvbXBpbGVDYWNoZVxyXG4gICAgbGV0IGNvbXBpbGVyID0gQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSA/XHJcbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcclxuICAgICAgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3R5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xyXG5cclxuICAgIC8vIE5COiBXZSBkb24ndCBwdXQgdGhpcyBpbnRvIHNob3VsZFBhc3N0aHJvdWdoIGJlY2F1c2UgSW5saW5lIEhUTUxcclxuICAgIC8vIGNvbXBpbGVyIGlzIHRlY2huaWNhbGx5IG9mIHR5cGUgZmluYWxGb3JtcyAoaS5lLiBhIGJyb3dzZXIgY2FuXHJcbiAgICAvLyBuYXRpdmVseSBoYW5kbGUgdGhpcyBjb250ZW50KSwgeWV0IGl0cyBjb21waWxlciBpc1xyXG4gICAgLy8gSW5saW5lSHRtbENvbXBpbGVyLiBIb3dldmVyLCB3ZSBzdGlsbCB3YW50IHRvIGNhdGNoIHN0YW5kYXJkIENTUyBmaWxlc1xyXG4gICAgLy8gd2hpY2ggd2lsbCBiZSBwcm9jZXNzZWQgYnkgUGFzc3Rocm91Z2hDb21waWxlci5cclxuICAgIGlmIChmaW5hbEZvcm1zW3R5cGVdICYmICFjb21waWxlcikge1xyXG4gICAgICBjb21waWxlciA9IHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgY29tcGlsZXIgPSB0aGlzLmZhbGxiYWNrQ29tcGlsZXI7XHJcblxyXG4gICAgICBsZXQgeyBjb2RlLCBiaW5hcnlEYXRhLCBtaW1lVHlwZSB9ID0gY29tcGlsZXIuZ2V0U3luYyhmaWxlUGF0aCk7XHJcbiAgICAgIHJldHVybiB7IGNvZGU6IGNvZGUgfHwgYmluYXJ5RGF0YSwgbWltZVR5cGUgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xyXG4gICAgbGV0IHtjb2RlLCBiaW5hcnlEYXRhLCBtaW1lVHlwZX0gPSBjYWNoZS5nZXRTeW5jKGZpbGVQYXRoKTtcclxuXHJcbiAgICBjb2RlID0gY29kZSB8fCBiaW5hcnlEYXRhO1xyXG4gICAgaWYgKCFjb2RlIHx8ICFtaW1lVHlwZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFza2VkIHRvIGNvbXBpbGUgJHtmaWxlUGF0aH0gaW4gcHJvZHVjdGlvbiwgaXMgdGhpcyBmaWxlIG5vdCBwcmVjb21waWxlZD9gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZSB9O1xyXG4gIH1cclxuXHJcbiAgZnVsbENvbXBpbGVTeW5jKGZpbGVQYXRoKSB7XHJcbiAgICBkKGBDb21waWxpbmcgJHtmaWxlUGF0aH1gKTtcclxuXHJcbiAgICBsZXQgaGFzaEluZm8gPSB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aFN5bmMoZmlsZVBhdGgpO1xyXG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuXHJcbiAgICBzZW5kKCdlbGVjdHJvbi1jb21waWxlLWNvbXBpbGVkLWZpbGUnLCB7IGZpbGVQYXRoLCBtaW1lVHlwZTogdHlwZSB9KTtcclxuXHJcbiAgICBpZiAoaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzKSB7XHJcbiAgICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XHJcbiAgICAgIGNvZGUgPSBDb21waWxlckhvc3QuZml4Tm9kZU1vZHVsZXNTb3VyY2VNYXBwaW5nU3luYyhjb2RlLCBmaWxlUGF0aCwgdGhpcy5maWxlQ2hhbmdlQ2FjaGUuYXBwUm9vdCk7XHJcbiAgICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlOiB0eXBlIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNvbXBpbGVyID0gQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSA/XHJcbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcclxuICAgICAgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3R5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xyXG5cclxuICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgZChgRmFsbGluZyBiYWNrIHRvIHBhc3N0aHJvdWdoIGNvbXBpbGVyIGZvciAke2ZpbGVQYXRofWApO1xyXG4gICAgICBjb21waWxlciA9IHRoaXMuZmFsbGJhY2tDb21waWxlcjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbXBpbGVyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBhIGNvbXBpbGVyIGZvciAke2ZpbGVQYXRofWApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjYWNoZSA9IHRoaXMuY2FjaGVzRm9yQ29tcGlsZXJzLmdldChjb21waWxlcik7XHJcbiAgICByZXR1cm4gY2FjaGUuZ2V0T3JGZXRjaFN5bmMoXHJcbiAgICAgIGZpbGVQYXRoLFxyXG4gICAgICAoZmlsZVBhdGgsIGhhc2hJbmZvKSA9PiB0aGlzLmNvbXBpbGVVbmNhY2hlZFN5bmMoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikpO1xyXG4gIH1cclxuXHJcbiAgY29tcGlsZVVuY2FjaGVkU3luYyhmaWxlUGF0aCwgaGFzaEluZm8sIGNvbXBpbGVyKSB7XHJcbiAgICBsZXQgaW5wdXRNaW1lVHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xyXG5cclxuICAgIGlmIChoYXNoSW5mby5pc0ZpbGVCaW5hcnkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBiaW5hcnlEYXRhOiBoYXNoSW5mby5iaW5hcnlEYXRhIHx8IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCksXHJcbiAgICAgICAgbWltZVR5cGU6IGlucHV0TWltZVR5cGUsXHJcbiAgICAgICAgZGVwZW5kZW50RmlsZXM6IFtdXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGN0eCA9IHt9O1xyXG4gICAgbGV0IGNvZGUgPSBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKTtcclxuXHJcbiAgICBpZiAoIShjb21waWxlci5zaG91bGRDb21waWxlRmlsZVN5bmMoY29kZSwgY3R4KSkpIHtcclxuICAgICAgZChgQ29tcGlsZXIgcmV0dXJuZWQgZmFsc2UgZm9yIHNob3VsZENvbXBpbGVGaWxlOiAke2ZpbGVQYXRofWApO1xyXG4gICAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZTogbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCksIGRlcGVuZGVudEZpbGVzOiBbXSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBkZXBlbmRlbnRGaWxlcyA9IGNvbXBpbGVyLmRldGVybWluZURlcGVuZGVudEZpbGVzU3luYyhjb2RlLCBmaWxlUGF0aCwgY3R4KTtcclxuXHJcbiAgICBsZXQgcmVzdWx0ID0gY29tcGlsZXIuY29tcGlsZVN5bmMoY29kZSwgZmlsZVBhdGgsIGN0eCk7XHJcblxyXG4gICAgbGV0IHNob3VsZElubGluZUh0bWxpZnkgPVxyXG4gICAgICBpbnB1dE1pbWVUeXBlICE9PSAndGV4dC9odG1sJyAmJlxyXG4gICAgICByZXN1bHQubWltZVR5cGUgPT09ICd0ZXh0L2h0bWwnO1xyXG5cclxuICAgIGxldCBpc1Bhc3N0aHJvdWdoID1cclxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9wbGFpbicgfHxcclxuICAgICAgIXJlc3VsdC5taW1lVHlwZSB8fFxyXG4gICAgICBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pO1xyXG5cclxuICAgIGlmICgoZmluYWxGb3Jtc1tyZXN1bHQubWltZVR5cGVdICYmICFzaG91bGRJbmxpbmVIdG1saWZ5KSB8fCBpc1Bhc3N0aHJvdWdoKSB7XHJcbiAgICAgIC8vIEdvdCBzb21ldGhpbmcgd2UgY2FuIHVzZSBpbi1icm93c2VyLCBsZXQncyByZXR1cm4gaXRcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7ZGVwZW5kZW50RmlsZXN9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGQoYFJlY3Vyc2l2ZWx5IGNvbXBpbGluZyByZXN1bHQgb2YgJHtmaWxlUGF0aH0gd2l0aCBub24tZmluYWwgTUlNRSB0eXBlICR7cmVzdWx0Lm1pbWVUeXBlfSwgaW5wdXQgd2FzICR7aW5wdXRNaW1lVHlwZX1gKTtcclxuXHJcbiAgICAgIGhhc2hJbmZvID0gT2JqZWN0LmFzc2lnbih7IHNvdXJjZUNvZGU6IHJlc3VsdC5jb2RlLCBtaW1lVHlwZTogcmVzdWx0Lm1pbWVUeXBlIH0sIGhhc2hJbmZvKTtcclxuICAgICAgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbcmVzdWx0Lm1pbWVUeXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcclxuXHJcbiAgICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgICBkKGBSZWN1cnNpdmUgY29tcGlsZSBmYWlsZWQgLSBpbnRlcm1lZGlhdGUgcmVzdWx0OiAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9YCk7XHJcblxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcGlsaW5nICR7ZmlsZVBhdGh9IHJlc3VsdGVkIGluIGEgTUlNRSB0eXBlIG9mICR7cmVzdWx0Lm1pbWVUeXBlfSwgd2hpY2ggd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVVbmNhY2hlZFN5bmMoXHJcbiAgICAgICAgYCR7ZmlsZVBhdGh9LiR7bWltZVR5cGVzLmV4dGVuc2lvbihyZXN1bHQubWltZVR5cGUgfHwgJ3R4dCcpfWAsXHJcbiAgICAgICAgaGFzaEluZm8sIGNvbXBpbGVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbXBpbGVBbGxTeW5jKHJvb3REaXJlY3RvcnksIHNob3VsZENvbXBpbGU9bnVsbCkge1xyXG4gICAgbGV0IHNob3VsZCA9IHNob3VsZENvbXBpbGUgfHwgZnVuY3Rpb24oKSB7cmV0dXJuIHRydWU7fTtcclxuXHJcbiAgICBmb3JBbGxGaWxlc1N5bmMocm9vdERpcmVjdG9yeSwgKGYpID0+IHtcclxuICAgICAgaWYgKCFzaG91bGQoZikpIHJldHVybjtcclxuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZVN5bmMoZiwgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBPdGhlciBzdHVmZlxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcGFzc3Rocm91Z2ggY29tcGlsZXJcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbJ3RleHQvcGxhaW4nXTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGV2ZW4gdHJ5IHRvIGNvbXBpbGUgdGhlIGNvbnRlbnQuIE5vdGUgdGhhdCBpblxyXG4gICAqIHNvbWUgY2FzZXMsIGNvbnRlbnQgd2lsbCBzdGlsbCBiZSBpbiBjYWNoZSBldmVuIGlmIHRoaXMgcmV0dXJucyB0cnVlLCBhbmRcclxuICAgKiBpbiBvdGhlciBjYXNlcyAoaXNJbk5vZGVNb2R1bGVzKSwgd2UnbGwga25vdyBleHBsaWNpdGx5IHRvIG5vdCBldmVuIGJvdGhlclxyXG4gICAqIGxvb2tpbmcgaW4gdGhlIGNhY2hlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pIHtcclxuICAgIHJldHVybiBoYXNoSW5mby5pc01pbmlmaWVkIHx8IGhhc2hJbmZvLmlzSW5Ob2RlTW9kdWxlcyB8fCBoYXNoSW5mby5oYXNTb3VyY2VNYXAgfHwgaGFzaEluZm8uaXNGaWxlQmluYXJ5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9vayBhdCB0aGUgY29kZSBvZiBhIG5vZGUgbW9kdWxlcyBhbmQgc2VlIHRoZSBzb3VyY2VNYXBwaW5nIHBhdGguXHJcbiAgICogSWYgdGhlcmUgaXMgYW55LCBjaGVjayB0aGUgcGF0aCBhbmQgdHJ5IHRvIGZpeCBpdCB3aXRoIGFuZFxyXG4gICAqIHJvb3QgcmVsYXRpdmUgcGF0aC5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBmaXhOb2RlTW9kdWxlc1NvdXJjZU1hcHBpbmcoc291cmNlQ29kZSwgc291cmNlUGF0aCwgYXBwUm9vdCkge1xyXG4gICAgbGV0IHJlZ2V4U291cmNlTWFwcGluZyA9IC9cXC9cXC8jLipzb3VyY2VNYXBwaW5nVVJMPSg/IWRhdGE6KShbXlwiJ10uKikvaTtcclxuICAgIGxldCBzb3VyY2VNYXBwaW5nQ2hlY2sgPSBzb3VyY2VDb2RlLm1hdGNoKHJlZ2V4U291cmNlTWFwcGluZyk7XHJcblxyXG4gICAgaWYgKHNvdXJjZU1hcHBpbmdDaGVjayAmJiBzb3VyY2VNYXBwaW5nQ2hlY2tbMV0gJiYgc291cmNlTWFwcGluZ0NoZWNrWzFdICE9PSAnJyl7XHJcbiAgICAgIGxldCBzb3VyY2VNYXBQYXRoID0gc291cmNlTWFwcGluZ0NoZWNrWzFdO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBwZnMuc3RhdChzb3VyY2VNYXBQYXRoKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBsZXQgbm9ybVJvb3QgPSBwYXRoLm5vcm1hbGl6ZShhcHBSb290KTtcclxuICAgICAgICBsZXQgYWJzUGF0aFRvTW9kdWxlID0gcGF0aC5kaXJuYW1lKHNvdXJjZVBhdGgucmVwbGFjZShub3JtUm9vdCwgJycpLnN1YnN0cmluZygxKSk7XHJcbiAgICAgICAgbGV0IG5ld01hcFBhdGggPSBwYXRoLmpvaW4oYWJzUGF0aFRvTW9kdWxlLCBzb3VyY2VNYXBQYXRoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZUNvZGUucmVwbGFjZShyZWdleFNvdXJjZU1hcHBpbmcsIGAvLyMgc291cmNlTWFwcGluZ1VSTD0ke25ld01hcFBhdGh9YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc291cmNlQ29kZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvb2sgYXQgdGhlIGNvZGUgb2YgYSBub2RlIG1vZHVsZXMgYW5kIHNlZSB0aGUgc291cmNlTWFwcGluZyBwYXRoLlxyXG4gICAqIElmIHRoZXJlIGlzIGFueSwgY2hlY2sgdGhlIHBhdGggYW5kIHRyeSB0byBmaXggaXQgd2l0aCBhbmRcclxuICAgKiByb290IHJlbGF0aXZlIHBhdGguXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgZml4Tm9kZU1vZHVsZXNTb3VyY2VNYXBwaW5nU3luYyhzb3VyY2VDb2RlLCBzb3VyY2VQYXRoLCBhcHBSb290KSB7XHJcbiAgICBsZXQgcmVnZXhTb3VyY2VNYXBwaW5nID0gL1xcL1xcLyMuKnNvdXJjZU1hcHBpbmdVUkw9KD8hZGF0YTopKFteXCInXS4qKS9pO1xyXG4gICAgbGV0IHNvdXJjZU1hcHBpbmdDaGVjayA9IHNvdXJjZUNvZGUubWF0Y2gocmVnZXhTb3VyY2VNYXBwaW5nKTtcclxuXHJcbiAgICBpZiAoc291cmNlTWFwcGluZ0NoZWNrICYmIHNvdXJjZU1hcHBpbmdDaGVja1sxXSAmJiBzb3VyY2VNYXBwaW5nQ2hlY2tbMV0gIT09ICcnKXtcclxuICAgICAgbGV0IHNvdXJjZU1hcFBhdGggPSBzb3VyY2VNYXBwaW5nQ2hlY2tbMV07XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZzLnN0YXRTeW5jKHNvdXJjZU1hcFBhdGgpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGxldCBub3JtUm9vdCA9IHBhdGgubm9ybWFsaXplKGFwcFJvb3QpO1xyXG4gICAgICAgIGxldCBhYnNQYXRoVG9Nb2R1bGUgPSBwYXRoLmRpcm5hbWUoc291cmNlUGF0aC5yZXBsYWNlKG5vcm1Sb290LCAnJykuc3Vic3RyaW5nKDEpKTtcclxuICAgICAgICBsZXQgbmV3TWFwUGF0aCA9IHBhdGguam9pbihhYnNQYXRoVG9Nb2R1bGUsIHNvdXJjZU1hcFBhdGgpO1xyXG5cclxuICAgICAgICByZXR1cm4gc291cmNlQ29kZS5yZXBsYWNlKHJlZ2V4U291cmNlTWFwcGluZywgYC8vIyBzb3VyY2VNYXBwaW5nVVJMPSR7bmV3TWFwUGF0aH1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzb3VyY2VDb2RlO1xyXG4gIH1cclxufVxyXG4iXX0=","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/for-all-files.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forAllFiles = forAllFiles;\nexports.forAllFilesSync = forAllFilesSync;\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _promise = require('./promise');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n/**\r\n * Invokes a method on all files in a directory recursively.\r\n * \r\n * @private\r\n */\nfunction forAllFiles(rootDirectory, func) {\n  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  let rec = (() => {\n    var _ref = _asyncToGenerator(function* (dir) {\n      let entries = yield _promise.pfs.readdir(dir);\n\n      for (let name of entries) {\n        let fullName = _path2.default.join(dir, name);\n        let stats = yield _promise.pfs.stat(fullName);\n\n        if (stats.isDirectory()) {\n          yield rec(fullName);\n        }\n\n        if (stats.isFile()) {\n          yield func(fullName, ...args);\n        }\n      }\n    });\n\n    return function rec(_x) {\n      return _ref.apply(this, arguments);\n    };\n  })();\n\n  return rec(rootDirectory);\n}\n\nfunction forAllFilesSync(rootDirectory, func) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    args[_key2 - 2] = arguments[_key2];\n  }\n\n  let rec = dir => {\n    _fs2.default.readdirSync(dir).forEach(name => {\n      let fullName = _path2.default.join(dir, name);\n      let stats = _fs2.default.statSync(fullName);\n\n      if (stats.isDirectory()) {\n        rec(fullName);\n        return;\n      }\n\n      if (stats.isFile()) {\n        func(fullName, ...args);\n        return;\n      }\n    });\n  };\n\n  rec(rootDirectory);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9mb3ItYWxsLWZpbGVzLmpzIl0sIm5hbWVzIjpbImZvckFsbEZpbGVzIiwiZm9yQWxsRmlsZXNTeW5jIiwicm9vdERpcmVjdG9yeSIsImZ1bmMiLCJhcmdzIiwicmVjIiwiZGlyIiwiZW50cmllcyIsInJlYWRkaXIiLCJuYW1lIiwiZnVsbE5hbWUiLCJqb2luIiwic3RhdHMiLCJzdGF0IiwiaXNEaXJlY3RvcnkiLCJpc0ZpbGUiLCJyZWFkZGlyU3luYyIsImZvckVhY2giLCJzdGF0U3luYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFVZ0JBLFcsR0FBQUEsVztRQXFCQUMsZSxHQUFBQSxlOztBQS9CaEI7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFHQTs7Ozs7QUFLTyxTQUFTRCxXQUFULENBQXFCRSxhQUFyQixFQUFvQ0MsSUFBcEMsRUFBbUQ7QUFBQSxvQ0FBTkMsSUFBTTtBQUFOQSxRQUFNO0FBQUE7O0FBQ3hELE1BQUlDO0FBQUEsaUNBQU0sV0FBT0MsR0FBUCxFQUFlO0FBQ3ZCLFVBQUlDLFVBQVUsTUFBTSxhQUFJQyxPQUFKLENBQVlGLEdBQVosQ0FBcEI7O0FBRUEsV0FBSyxJQUFJRyxJQUFULElBQWlCRixPQUFqQixFQUEwQjtBQUN4QixZQUFJRyxXQUFXLGVBQUtDLElBQUwsQ0FBVUwsR0FBVixFQUFlRyxJQUFmLENBQWY7QUFDQSxZQUFJRyxRQUFRLE1BQU0sYUFBSUMsSUFBSixDQUFTSCxRQUFULENBQWxCOztBQUVBLFlBQUlFLE1BQU1FLFdBQU4sRUFBSixFQUF5QjtBQUN2QixnQkFBTVQsSUFBSUssUUFBSixDQUFOO0FBQ0Q7O0FBRUQsWUFBSUUsTUFBTUcsTUFBTixFQUFKLEVBQW9CO0FBQ2xCLGdCQUFNWixLQUFLTyxRQUFMLEVBQWUsR0FBR04sSUFBbEIsQ0FBTjtBQUNEO0FBQ0Y7QUFDRixLQWZHOztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BQUo7O0FBaUJBLFNBQU9DLElBQUlILGFBQUosQ0FBUDtBQUNEOztBQUVNLFNBQVNELGVBQVQsQ0FBeUJDLGFBQXpCLEVBQXdDQyxJQUF4QyxFQUF1RDtBQUFBLHFDQUFOQyxJQUFNO0FBQU5BLFFBQU07QUFBQTs7QUFDNUQsTUFBSUMsTUFBT0MsR0FBRCxJQUFTO0FBQ2pCLGlCQUFHVSxXQUFILENBQWVWLEdBQWYsRUFBb0JXLE9BQXBCLENBQTZCUixJQUFELElBQVU7QUFDcEMsVUFBSUMsV0FBVyxlQUFLQyxJQUFMLENBQVVMLEdBQVYsRUFBZUcsSUFBZixDQUFmO0FBQ0EsVUFBSUcsUUFBUSxhQUFHTSxRQUFILENBQVlSLFFBQVosQ0FBWjs7QUFFQSxVQUFJRSxNQUFNRSxXQUFOLEVBQUosRUFBeUI7QUFDdkJULFlBQUlLLFFBQUo7QUFDQTtBQUNEOztBQUVELFVBQUlFLE1BQU1HLE1BQU4sRUFBSixFQUFvQjtBQUNsQlosYUFBS08sUUFBTCxFQUFlLEdBQUdOLElBQWxCO0FBQ0E7QUFDRDtBQUNGLEtBYkQ7QUFjRCxHQWZEOztBQWlCQUMsTUFBSUgsYUFBSjtBQUNEIiwiZmlsZSI6ImZvci1hbGwtZmlsZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IHtwZnN9IGZyb20gJy4vcHJvbWlzZSc7XHJcblxyXG5cclxuLyoqXHJcbiAqIEludm9rZXMgYSBtZXRob2Qgb24gYWxsIGZpbGVzIGluIGEgZGlyZWN0b3J5IHJlY3Vyc2l2ZWx5LlxyXG4gKiBcclxuICogQHByaXZhdGVcclxuICovIFxyXG5leHBvcnQgZnVuY3Rpb24gZm9yQWxsRmlsZXMocm9vdERpcmVjdG9yeSwgZnVuYywgLi4uYXJncykge1xyXG4gIGxldCByZWMgPSBhc3luYyAoZGlyKSA9PiB7XHJcbiAgICBsZXQgZW50cmllcyA9IGF3YWl0IHBmcy5yZWFkZGlyKGRpcik7XHJcbiAgICBcclxuICAgIGZvciAobGV0IG5hbWUgb2YgZW50cmllcykge1xyXG4gICAgICBsZXQgZnVsbE5hbWUgPSBwYXRoLmpvaW4oZGlyLCBuYW1lKTtcclxuICAgICAgbGV0IHN0YXRzID0gYXdhaXQgcGZzLnN0YXQoZnVsbE5hbWUpO1xyXG5cclxuICAgICAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcclxuICAgICAgICBhd2FpdCByZWMoZnVsbE5hbWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcclxuICAgICAgICBhd2FpdCBmdW5jKGZ1bGxOYW1lLCAuLi5hcmdzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiByZWMocm9vdERpcmVjdG9yeSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JBbGxGaWxlc1N5bmMocm9vdERpcmVjdG9yeSwgZnVuYywgLi4uYXJncykge1xyXG4gIGxldCByZWMgPSAoZGlyKSA9PiB7XHJcbiAgICBmcy5yZWFkZGlyU3luYyhkaXIpLmZvckVhY2goKG5hbWUpID0+IHtcclxuICAgICAgbGV0IGZ1bGxOYW1lID0gcGF0aC5qb2luKGRpciwgbmFtZSk7XHJcbiAgICAgIGxldCBzdGF0cyA9IGZzLnN0YXRTeW5jKGZ1bGxOYW1lKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XHJcbiAgICAgICAgcmVjKGZ1bGxOYW1lKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChzdGF0cy5pc0ZpbGUoKSkge1xyXG4gICAgICAgIGZ1bmMoZnVsbE5hbWUsIC4uLmFyZ3MpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxuICBcclxuICByZWMocm9vdERpcmVjdG9yeSk7XHJcbn1cclxuIl19","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/compile-cache.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _zlib = require('zlib');\n\nvar _zlib2 = _interopRequireDefault(_zlib);\n\nvar _digestForObject = require('./digest-for-object');\n\nvar _digestForObject2 = _interopRequireDefault(_digestForObject);\n\nvar _promise = require('./promise');\n\nvar _mkdirp = require('mkdirp');\n\nvar _mkdirp2 = _interopRequireDefault(_mkdirp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst d = require('debug')('electron-compile:compile-cache');\n\n/**\n * CompileCache manages getting and setting entries for a single compiler; each\n * in-use compiler will have an instance of this class, usually created via\n * {@link createFromCompiler}.\n *\n * You usually will not use this class directly, it is an implementation class\n * for {@link CompileHost}.\n */\nclass CompileCache {\n  /**\n   * Creates an instance, usually used for testing only.\n   *\n   * @param  {string} cachePath  The root directory to use as a cache path\n   *\n   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is\n   *                                             optionally pre-loaded.\n   * @param {string} sourceMapPath The directory to store sourcemap separately if compiler option enabled to emit.\n   *                               Default to cachePath if not specified.\n   */\n  constructor(cachePath, fileChangeCache) {\n    let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    this.cachePath = cachePath;\n    this.fileChangeCache = fileChangeCache;\n    this.sourceMapPath = sourceMapPath || this.cachePath;\n  }\n\n  /**\n   * Creates a CompileCache from a class compatible with the CompilerBase\n   * interface. This method uses the compiler name / version / options to\n   * generate a unique directory name for cached results\n   *\n   * @param  {string} cachePath  The root path to use for the cache, a directory\n   *                             representing the hash of the compiler parameters\n   *                             will be created here.\n   *\n   * @param  {CompilerBase} compiler  The compiler to use for version / option\n   *                                  information.\n   *\n   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is\n   *                                             optionally pre-loaded.\n   *\n   * @param  {boolean} readOnlyMode  Don't attempt to create the cache directory.\n   *\n   * @param {string} sourceMapPath The directory to store sourcemap separately if compiler option enabled to emit.\n   *                               Default to cachePath if not specified.\n   *\n   * @return {CompileCache}  A configured CompileCache instance.\n   */\n  static createFromCompiler(cachePath, compiler, fileChangeCache) {\n    let readOnlyMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let sourceMapPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n    let newCachePath = null;\n    let getCachePath = () => {\n      if (newCachePath) return newCachePath;\n\n      const digestObj = {\n        name: compiler.name || Object.getPrototypeOf(compiler).constructor.name,\n        version: compiler.getCompilerVersion(),\n        options: compiler.compilerOptions\n      };\n\n      newCachePath = _path2.default.join(cachePath, (0, _digestForObject2.default)(digestObj));\n\n      d(`Path for ${digestObj.name}: ${newCachePath}`);\n      d(`Set up with parameters: ${JSON.stringify(digestObj)}`);\n\n      if (!readOnlyMode) _mkdirp2.default.sync(newCachePath);\n      return newCachePath;\n    };\n\n    let ret = new CompileCache('', fileChangeCache);\n    ret.getCachePath = getCachePath;\n\n    const newSourceMapPath = sourceMapPath;\n    ret.getSourceMapPath = () => newSourceMapPath || getCachePath();\n\n    return ret;\n  }\n\n  /**\n   * Returns a file's compiled contents from the cache.\n   *\n   * @param  {string} filePath  The path to the file. FileChangedCache will look\n   *                            up the hash and use that as the key in the cache.\n   *\n   * @return {Promise<Object>}  An object with all kinds of information\n   *\n   * @property {Object} hashInfo  The hash information returned from getHashForPath\n   * @property {string} code  The source code if the file was a text file\n   * @property {Buffer} binaryData  The file if it was a binary file\n   * @property {string} mimeType  The MIME type saved in the cache.\n   * @property {string[]} dependentFiles  The dependent files returned from\n   *                                      compiling the file, if any.\n   */\n  get(filePath) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      d(`Fetching ${filePath} from cache`);\n      let hashInfo = yield _this.fileChangeCache.getHashForPath(_path2.default.resolve(filePath));\n\n      let code = null;\n      let mimeType = null;\n      let binaryData = null;\n      let dependentFiles = null;\n\n      let cacheFile = null;\n      try {\n        cacheFile = _path2.default.join(_this.getCachePath(), hashInfo.hash);\n        let result = null;\n\n        if (hashInfo.isFileBinary) {\n          d(\"File is binary, reading out info\");\n          let info = JSON.parse((yield _promise.pfs.readFile(cacheFile + '.info')));\n          mimeType = info.mimeType;\n          dependentFiles = info.dependentFiles;\n\n          binaryData = hashInfo.binaryData;\n          if (!binaryData) {\n            binaryData = yield _promise.pfs.readFile(cacheFile);\n            binaryData = yield _promise.pzlib.gunzip(binaryData);\n          }\n        } else {\n          let buf = yield _promise.pfs.readFile(cacheFile);\n          let str = (yield _promise.pzlib.gunzip(buf)).toString('utf8');\n\n          result = JSON.parse(str);\n          code = result.code;\n          mimeType = result.mimeType;\n          dependentFiles = result.dependentFiles;\n        }\n      } catch (e) {\n        d(`Failed to read cache for ${filePath}, looked in ${cacheFile}: ${e.message}`);\n      }\n\n      return { hashInfo, code, mimeType, binaryData, dependentFiles };\n    })();\n  }\n\n  /**\n   * Saves a compiled result to cache\n   *\n   * @param  {Object} hashInfo  The hash information returned from getHashForPath\n   *\n   * @param  {string / Buffer} codeOrBinaryData   The file's contents, either as\n   *                                              a string or a Buffer.\n   * @param  {string} mimeType  The MIME type returned by the compiler.\n   *\n   * @param  {string[]} dependentFiles  The list of dependent files returned by\n   *                                    the compiler.\n   * @return {Promise}  Completion.\n   */\n  save(hashInfo, codeOrBinaryData, mimeType, dependentFiles) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let buf = null;\n      let target = _path2.default.join(_this2.getCachePath(), hashInfo.hash);\n      d(`Saving to ${target}`);\n\n      if (hashInfo.isFileBinary) {\n        buf = yield _promise.pzlib.gzip(codeOrBinaryData);\n        yield _promise.pfs.writeFile(target + '.info', JSON.stringify({ mimeType, dependentFiles }), 'utf8');\n      } else {\n        buf = yield _promise.pzlib.gzip(new Buffer(JSON.stringify({ code: codeOrBinaryData, mimeType, dependentFiles })));\n      }\n\n      yield _promise.pfs.writeFile(target, buf);\n    })();\n  }\n\n  /**\n   * Attempts to first get a key via {@link get}, then if it fails, call a method\n   * to retrieve the contents, then save the result to cache.\n   *\n   * The fetcher parameter is expected to have the signature:\n   *\n   * Promise<Object> fetcher(filePath : string, hashInfo : Object);\n   *\n   * hashInfo is a value returned from getHashForPath\n   * The return value of fetcher must be an Object with the properties:\n   *\n   * mimeType - the MIME type of the data to save\n   * code (optional) - the source code as a string, if file is text\n   * binaryData (optional) - the file contents as a Buffer, if file is binary\n   * dependentFiles - the dependent files returned by the compiler.\n   *\n   * @param  {string} filePath  The path to the file. FileChangedCache will look\n   *                            up the hash and use that as the key in the cache.\n   *\n   * @param  {Function} fetcher  A method which conforms to the description above.\n   *\n   * @return {Promise<Object>}  An Object which has the same fields as the\n   *                            {@link get} method return result.\n   */\n  getOrFetch(filePath, fetcher) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let cacheResult = yield _this3.get(filePath);\n      let anyDependenciesChanged = yield _this3.haveAnyDependentFilesChanged(cacheResult);\n\n      if ((cacheResult.code || cacheResult.binaryData) && !anyDependenciesChanged) {\n        return cacheResult;\n      }\n\n      let result = (yield fetcher(filePath, cacheResult.hashInfo)) || { hashInfo: cacheResult.hashInfo };\n\n      if (result.mimeType && !cacheResult.hashInfo.isInNodeModules) {\n        d(`Cache miss: saving out info for ${filePath}`);\n        yield _this3.save(cacheResult.hashInfo, result.code || result.binaryData, result.mimeType, result.dependentFiles);\n\n        const map = result.sourceMaps;\n        if (map) {\n          d(`source map for ${filePath} found, saving it to ${_this3.getSourceMapPath()}`);\n          yield _this3.saveSourceMap(cacheResult.hashInfo, filePath, map);\n        }\n      }\n\n      result.hashInfo = cacheResult.hashInfo;\n      return result;\n    })();\n  }\n\n  /**\n   * @private Check if any of a file's dependencies have changed\n   */\n  haveAnyDependentFilesChanged(cacheResult) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!cacheResult.code || !cacheResult.dependentFiles.length) return false;\n\n      for (let dependentFile of cacheResult.dependentFiles) {\n        let hasFileChanged = yield _this4.fileChangeCache.hasFileChanged(dependentFile);\n        if (hasFileChanged) {\n          return true;\n        }\n\n        let dependentFileCacheResult = yield _this4.get(dependentFile);\n        if (dependentFileCacheResult.dependentFiles && dependentFileCacheResult.dependentFiles.length) {\n          let anySubdependentFilesChanged = yield _this4.haveAnyDependentFilesChanged(dependentFileCacheResult);\n          if (anySubdependentFilesChanged) return true;\n        }\n      }\n\n      return false;\n    })();\n  }\n\n  getSync(filePath) {\n    d(`Fetching ${filePath} from cache`);\n    let hashInfo = this.fileChangeCache.getHashForPathSync(_path2.default.resolve(filePath));\n\n    let code = null;\n    let mimeType = null;\n    let binaryData = null;\n    let dependentFiles = null;\n\n    try {\n      let cacheFile = _path2.default.join(this.getCachePath(), hashInfo.hash);\n\n      let result = null;\n      if (hashInfo.isFileBinary) {\n        d(\"File is binary, reading out info\");\n        let info = JSON.parse(_fs2.default.readFileSync(cacheFile + '.info'));\n        mimeType = info.mimeType;\n        dependentFiles = info.dependentFiles;\n\n        binaryData = hashInfo.binaryData;\n        if (!binaryData) {\n          binaryData = _fs2.default.readFileSync(cacheFile);\n          binaryData = _zlib2.default.gunzipSync(binaryData);\n        }\n      } else {\n        let buf = _fs2.default.readFileSync(cacheFile);\n        let str = _zlib2.default.gunzipSync(buf).toString('utf8');\n\n        result = JSON.parse(str);\n        code = result.code;\n        mimeType = result.mimeType;\n        dependentFiles = result.dependentFiles;\n      }\n    } catch (e) {\n      d(`Failed to read cache for ${filePath}`);\n    }\n\n    return { hashInfo, code, mimeType, binaryData, dependentFiles };\n  }\n\n  saveSync(hashInfo, codeOrBinaryData, mimeType, dependentFiles) {\n    let buf = null;\n    let target = _path2.default.join(this.getCachePath(), hashInfo.hash);\n    d(`Saving to ${target}`);\n\n    if (hashInfo.isFileBinary) {\n      buf = _zlib2.default.gzipSync(codeOrBinaryData);\n      _fs2.default.writeFileSync(target + '.info', JSON.stringify({ mimeType, dependentFiles }), 'utf8');\n    } else {\n      buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify({ code: codeOrBinaryData, mimeType, dependentFiles })));\n    }\n\n    _fs2.default.writeFileSync(target, buf);\n  }\n\n  getOrFetchSync(filePath, fetcher) {\n    let cacheResult = this.getSync(filePath);\n    if (cacheResult.code || cacheResult.binaryData) return cacheResult;\n\n    let result = fetcher(filePath, cacheResult.hashInfo) || { hashInfo: cacheResult.hashInfo };\n\n    if (result.mimeType && !cacheResult.hashInfo.isInNodeModules) {\n      d(`Cache miss: saving out info for ${filePath}`);\n      this.saveSync(cacheResult.hashInfo, result.code || result.binaryData, result.mimeType, result.dependentFiles);\n    }\n\n    const map = result.sourceMaps;\n    if (map) {\n      d(`source map for ${filePath} found, saving it to ${this.getSourceMapPath()}`);\n      this.saveSourceMapSync(cacheResult.hashInfo, filePath, map);\n    }\n\n    result.hashInfo = cacheResult.hashInfo;\n    return result;\n  }\n\n  buildSourceMapTarget(hashInfo, filePath) {\n    const fileName = _path2.default.basename(filePath);\n    const mapFileName = fileName.replace(_path2.default.extname(fileName), '.js.map');\n\n    const target = _path2.default.join(this.getSourceMapPath(), mapFileName);\n    d(`Sourcemap target is: ${target}`);\n\n    return target;\n  }\n\n  /**\n   * Saves sourcemap string into cache, or specified separate dir\n   *\n   * @param  {Object} hashInfo  The hash information returned from getHashForPath\n   *\n   * @param  {string} filePath Path to original file to construct sourcemap file name\n    * @param  {string} sourceMap Sourcemap data as string\n   *\n   * @memberOf CompileCache\n   */\n  saveSourceMap(hashInfo, filePath, sourceMap) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const target = _this5.buildSourceMapTarget(hashInfo, filePath);\n      yield _promise.pfs.writeFile(target, sourceMap, 'utf-8');\n    })();\n  }\n\n  saveSourceMapSync(hashInfo, filePath, sourceMap) {\n    const target = this.buildSourceMapTarget(hashInfo, filePath);\n    _fs2.default.writeFileSync(target, sourceMap, 'utf-8');\n  }\n\n  /**\n   * @private\n   */\n  getCachePath() {\n    // NB: This is an evil hack so that createFromCompiler can stomp it\n    // at will\n    return this.cachePath;\n  }\n\n  /**\n   * @private\n   */\n  getSourceMapPath() {\n    return this.sourceMapPath;\n  }\n\n  /**\n   * Returns whether a file should not be compiled. Note that this doesn't\n   * necessarily mean it won't end up in the cache, only that its contents are\n   * saved verbatim instead of trying to find an appropriate compiler.\n   *\n   * @param  {Object} hashInfo  The hash information returned from getHashForPath\n   *\n   * @return {boolean}  True if a file should be ignored\n   */\n  static shouldPassthrough(hashInfo) {\n    return hashInfo.isMinified || hashInfo.isInNodeModules || hashInfo.hasSourceMap || hashInfo.isFileBinary;\n  }\n}\nexports.default = CompileCache;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21waWxlLWNhY2hlLmpzIl0sIm5hbWVzIjpbImQiLCJyZXF1aXJlIiwiQ29tcGlsZUNhY2hlIiwiY29uc3RydWN0b3IiLCJjYWNoZVBhdGgiLCJmaWxlQ2hhbmdlQ2FjaGUiLCJzb3VyY2VNYXBQYXRoIiwiY3JlYXRlRnJvbUNvbXBpbGVyIiwiY29tcGlsZXIiLCJyZWFkT25seU1vZGUiLCJuZXdDYWNoZVBhdGgiLCJnZXRDYWNoZVBhdGgiLCJkaWdlc3RPYmoiLCJuYW1lIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJ2ZXJzaW9uIiwiZ2V0Q29tcGlsZXJWZXJzaW9uIiwib3B0aW9ucyIsImNvbXBpbGVyT3B0aW9ucyIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5Iiwic3luYyIsInJldCIsIm5ld1NvdXJjZU1hcFBhdGgiLCJnZXRTb3VyY2VNYXBQYXRoIiwiZ2V0IiwiZmlsZVBhdGgiLCJoYXNoSW5mbyIsImdldEhhc2hGb3JQYXRoIiwicmVzb2x2ZSIsImNvZGUiLCJtaW1lVHlwZSIsImJpbmFyeURhdGEiLCJkZXBlbmRlbnRGaWxlcyIsImNhY2hlRmlsZSIsImhhc2giLCJyZXN1bHQiLCJpc0ZpbGVCaW5hcnkiLCJpbmZvIiwicGFyc2UiLCJyZWFkRmlsZSIsImd1bnppcCIsImJ1ZiIsInN0ciIsInRvU3RyaW5nIiwiZSIsIm1lc3NhZ2UiLCJzYXZlIiwiY29kZU9yQmluYXJ5RGF0YSIsInRhcmdldCIsImd6aXAiLCJ3cml0ZUZpbGUiLCJCdWZmZXIiLCJnZXRPckZldGNoIiwiZmV0Y2hlciIsImNhY2hlUmVzdWx0IiwiYW55RGVwZW5kZW5jaWVzQ2hhbmdlZCIsImhhdmVBbnlEZXBlbmRlbnRGaWxlc0NoYW5nZWQiLCJpc0luTm9kZU1vZHVsZXMiLCJtYXAiLCJzb3VyY2VNYXBzIiwic2F2ZVNvdXJjZU1hcCIsImxlbmd0aCIsImRlcGVuZGVudEZpbGUiLCJoYXNGaWxlQ2hhbmdlZCIsImRlcGVuZGVudEZpbGVDYWNoZVJlc3VsdCIsImFueVN1YmRlcGVuZGVudEZpbGVzQ2hhbmdlZCIsImdldFN5bmMiLCJnZXRIYXNoRm9yUGF0aFN5bmMiLCJyZWFkRmlsZVN5bmMiLCJndW56aXBTeW5jIiwic2F2ZVN5bmMiLCJnemlwU3luYyIsIndyaXRlRmlsZVN5bmMiLCJnZXRPckZldGNoU3luYyIsInNhdmVTb3VyY2VNYXBTeW5jIiwiYnVpbGRTb3VyY2VNYXBUYXJnZXQiLCJmaWxlTmFtZSIsImJhc2VuYW1lIiwibWFwRmlsZU5hbWUiLCJyZXBsYWNlIiwiZXh0bmFtZSIsInNvdXJjZU1hcCIsInNob3VsZFBhc3N0aHJvdWdoIiwiaXNNaW5pZmllZCIsImhhc1NvdXJjZU1hcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFFQSxNQUFNQSxJQUFJQyxRQUFRLE9BQVIsRUFBaUIsZ0NBQWpCLENBQVY7O0FBRUE7Ozs7Ozs7O0FBUWUsTUFBTUMsWUFBTixDQUFtQjtBQUNoQzs7Ozs7Ozs7OztBQVVBQyxjQUFZQyxTQUFaLEVBQXVCQyxlQUF2QixFQUE4RDtBQUFBLFFBQXRCQyxhQUFzQix1RUFBTixJQUFNOztBQUM1RCxTQUFLRixTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLFNBQUtDLGVBQUwsR0FBdUJBLGVBQXZCO0FBQ0EsU0FBS0MsYUFBTCxHQUFxQkEsaUJBQWlCLEtBQUtGLFNBQTNDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkEsU0FBT0csa0JBQVAsQ0FBMEJILFNBQTFCLEVBQXFDSSxRQUFyQyxFQUErQ0gsZUFBL0MsRUFBNEc7QUFBQSxRQUE1Q0ksWUFBNEMsdUVBQTdCLEtBQTZCO0FBQUEsUUFBdEJILGFBQXNCLHVFQUFOLElBQU07O0FBQzFHLFFBQUlJLGVBQWUsSUFBbkI7QUFDQSxRQUFJQyxlQUFlLE1BQU07QUFDdkIsVUFBSUQsWUFBSixFQUFrQixPQUFPQSxZQUFQOztBQUVsQixZQUFNRSxZQUFZO0FBQ2hCQyxjQUFN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QXpDLENBQXBCOztBQUVBLFVBQU01QixTQUFTLGVBQUsvQixJQUFMLENBQVUsS0FBS00sZ0JBQUwsRUFBVixFQUFtQ3VELFdBQW5DLENBQWY7QUFDQWpGLE1BQUcsd0JBQXVCbUQsTUFBTyxFQUFqQzs7QUFFQSxXQUFPQSxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7QUFXTVksZUFBTixDQUFvQmxDLFFBQXBCLEVBQThCRCxRQUE5QixFQUF3Q3dELFNBQXhDLEVBQW1EO0FBQUE7O0FBQUE7QUFDakQsWUFBTWpDLFNBQVMsT0FBSzJCLG9CQUFMLENBQTBCakQsUUFBMUIsRUFBb0NELFFBQXBDLENBQWY7QUFDQSxZQUFNLGFBQUl5QixTQUFKLENBQWNGLE1BQWQsRUFBc0JpQyxTQUF0QixFQUFpQyxPQUFqQyxDQUFOO0FBRmlEO0FBR2xEOztBQUVEUCxvQkFBa0JoRCxRQUFsQixFQUE0QkQsUUFBNUIsRUFBc0N3RCxTQUF0QyxFQUFpRDtBQUMvQyxVQUFNakMsU0FBUyxLQUFLMkIsb0JBQUwsQ0FBMEJqRCxRQUExQixFQUFvQ0QsUUFBcEMsQ0FBZjtBQUNBLGlCQUFHK0MsYUFBSCxDQUFpQnhCLE1BQWpCLEVBQXlCaUMsU0FBekIsRUFBb0MsT0FBcEM7QUFDRDs7QUFFRDs7O0FBR0F6RSxpQkFBZTtBQUNiO0FBQ0E7QUFDQSxXQUFPLEtBQUtQLFNBQVo7QUFDRDs7QUFFRDs7O0FBR0FzQixxQkFBbUI7QUFDakIsV0FBTyxLQUFLcEIsYUFBWjtBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQSxTQUFPK0UsaUJBQVAsQ0FBeUJ4RCxRQUF6QixFQUFtQztBQUNqQyxXQUFPQSxTQUFTeUQsVUFBVCxJQUF1QnpELFNBQVMrQixlQUFoQyxJQUFtRC9CLFNBQVMwRCxZQUE1RCxJQUE0RTFELFNBQVNVLFlBQTVGO0FBQ0Q7QUF2VytCO2tCQUFickMsWSIsImZpbGUiOiJjb21waWxlLWNhY2hlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XG5pbXBvcnQgY3JlYXRlRGlnZXN0Rm9yT2JqZWN0IGZyb20gJy4vZGlnZXN0LWZvci1vYmplY3QnO1xuaW1wb3J0IHtwZnMsIHB6bGlifSBmcm9tICcuL3Byb21pc2UnO1xuaW1wb3J0IG1rZGlycCBmcm9tICdta2RpcnAnO1xuXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWcnKSgnZWxlY3Ryb24tY29tcGlsZTpjb21waWxlLWNhY2hlJyk7XG5cbi8qKlxuICogQ29tcGlsZUNhY2hlIG1hbmFnZXMgZ2V0dGluZyBhbmQgc2V0dGluZyBlbnRyaWVzIGZvciBhIHNpbmdsZSBjb21waWxlcjsgZWFjaFxuICogaW4tdXNlIGNvbXBpbGVyIHdpbGwgaGF2ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLCB1c3VhbGx5IGNyZWF0ZWQgdmlhXG4gKiB7QGxpbmsgY3JlYXRlRnJvbUNvbXBpbGVyfS5cbiAqXG4gKiBZb3UgdXN1YWxseSB3aWxsIG5vdCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgaXQgaXMgYW4gaW1wbGVtZW50YXRpb24gY2xhc3NcbiAqIGZvciB7QGxpbmsgQ29tcGlsZUhvc3R9LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21waWxlQ2FjaGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSwgdXN1YWxseSB1c2VkIGZvciB0ZXN0aW5nIG9ubHkuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY2FjaGVQYXRoICBUaGUgcm9vdCBkaXJlY3RvcnkgdG8gdXNlIGFzIGEgY2FjaGUgcGF0aFxuICAgKlxuICAgKiBAcGFyYW0gIHtGaWxlQ2hhbmdlZENhY2hlfSBmaWxlQ2hhbmdlQ2FjaGUgIEEgZmlsZS1jaGFuZ2UgY2FjaGUgdGhhdCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsbHkgcHJlLWxvYWRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZU1hcFBhdGggVGhlIGRpcmVjdG9yeSB0byBzdG9yZSBzb3VyY2VtYXAgc2VwYXJhdGVseSBpZiBjb21waWxlciBvcHRpb24gZW5hYmxlZCB0byBlbWl0LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHRvIGNhY2hlUGF0aCBpZiBub3Qgc3BlY2lmaWVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FjaGVQYXRoLCBmaWxlQ2hhbmdlQ2FjaGUsIHNvdXJjZU1hcFBhdGggPSBudWxsKSB7XG4gICAgdGhpcy5jYWNoZVBhdGggPSBjYWNoZVBhdGg7XG4gICAgdGhpcy5maWxlQ2hhbmdlQ2FjaGUgPSBmaWxlQ2hhbmdlQ2FjaGU7XG4gICAgdGhpcy5zb3VyY2VNYXBQYXRoID0gc291cmNlTWFwUGF0aCB8fCB0aGlzLmNhY2hlUGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQ29tcGlsZUNhY2hlIGZyb20gYSBjbGFzcyBjb21wYXRpYmxlIHdpdGggdGhlIENvbXBpbGVyQmFzZVxuICAgKiBpbnRlcmZhY2UuIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGNvbXBpbGVyIG5hbWUgLyB2ZXJzaW9uIC8gb3B0aW9ucyB0b1xuICAgKiBnZW5lcmF0ZSBhIHVuaXF1ZSBkaXJlY3RvcnkgbmFtZSBmb3IgY2FjaGVkIHJlc3VsdHNcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBjYWNoZVBhdGggIFRoZSByb290IHBhdGggdG8gdXNlIGZvciB0aGUgY2FjaGUsIGEgZGlyZWN0b3J5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXByZXNlbnRpbmcgdGhlIGhhc2ggb2YgdGhlIGNvbXBpbGVyIHBhcmFtZXRlcnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgY3JlYXRlZCBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtDb21waWxlckJhc2V9IGNvbXBpbGVyICBUaGUgY29tcGlsZXIgdG8gdXNlIGZvciB2ZXJzaW9uIC8gb3B0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGaWxlQ2hhbmdlZENhY2hlfSBmaWxlQ2hhbmdlQ2FjaGUgIEEgZmlsZS1jaGFuZ2UgY2FjaGUgdGhhdCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsbHkgcHJlLWxvYWRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gcmVhZE9ubHlNb2RlICBEb24ndCBhdHRlbXB0IHRvIGNyZWF0ZSB0aGUgY2FjaGUgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlTWFwUGF0aCBUaGUgZGlyZWN0b3J5IHRvIHN0b3JlIHNvdXJjZW1hcCBzZXBhcmF0ZWx5IGlmIGNvbXBpbGVyIG9wdGlvbiBlbmFibGVkIHRvIGVtaXQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdG8gY2FjaGVQYXRoIGlmIG5vdCBzcGVjaWZpZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBpbGVDYWNoZX0gIEEgY29uZmlndXJlZCBDb21waWxlQ2FjaGUgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlRnJvbUNvbXBpbGVyKGNhY2hlUGF0aCwgY29tcGlsZXIsIGZpbGVDaGFuZ2VDYWNoZSwgcmVhZE9ubHlNb2RlID0gZmFsc2UsIHNvdXJjZU1hcFBhdGggPSBudWxsKSB7XG4gICAgbGV0IG5ld0NhY2hlUGF0aCA9IG51bGw7XG4gICAgbGV0IGdldENhY2hlUGF0aCA9ICgpID0+IHtcbiAgICAgIGlmIChuZXdDYWNoZVBhdGgpIHJldHVybiBuZXdDYWNoZVBhdGg7XG5cbiAgICAgIGNvbnN0IGRpZ2VzdE9iaiA9IHtcbiAgICAgICAgbmFtZTogY29tcGlsZXIubmFtZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcGlsZXIpLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgIHZlcnNpb246IGNvbXBpbGVyLmdldENvbXBpbGVyVmVyc2lvbigpLFxuICAgICAgICBvcHRpb25zOiBjb21waWxlci5jb21waWxlck9wdGlvbnNcbiAgICAgIH07XG5cbiAgICAgIG5ld0NhY2hlUGF0aCA9IHBhdGguam9pbihjYWNoZVBhdGgsIGNyZWF0ZURpZ2VzdEZvck9iamVjdChkaWdlc3RPYmopKTtcblxuICAgICAgZChgUGF0aCBmb3IgJHtkaWdlc3RPYmoubmFtZX06ICR7bmV3Q2FjaGVQYXRofWApO1xuICAgICAgZChgU2V0IHVwIHdpdGggcGFyYW1ldGVyczogJHtKU09OLnN0cmluZ2lmeShkaWdlc3RPYmopfWApO1xuXG4gICAgICBpZiAoIXJlYWRPbmx5TW9kZSkgbWtkaXJwLnN5bmMobmV3Q2FjaGVQYXRoKTtcbiAgICAgIHJldHVybiBuZXdDYWNoZVBhdGg7XG4gICAgfTtcblxuICAgIGxldCByZXQgPSBuZXcgQ29tcGlsZUNhY2hlKCcnLCBmaWxlQ2hhbmdlQ2FjaGUpO1xuICAgIHJldC5nZXRDYWNoZVBhdGggPSBnZXRDYWNoZVBhdGg7XG5cbiAgICBjb25zdCBuZXdTb3VyY2VNYXBQYXRoID0gc291cmNlTWFwUGF0aDtcbiAgICByZXQuZ2V0U291cmNlTWFwUGF0aCA9ICgpID0+IG5ld1NvdXJjZU1hcFBhdGggfHwgZ2V0Q2FjaGVQYXRoKCk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmaWxlJ3MgY29tcGlsZWQgY29udGVudHMgZnJvbSB0aGUgY2FjaGUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZVBhdGggIFRoZSBwYXRoIHRvIHRoZSBmaWxlLiBGaWxlQ2hhbmdlZENhY2hlIHdpbGwgbG9va1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cCB0aGUgaGFzaCBhbmQgdXNlIHRoYXQgYXMgdGhlIGtleSBpbiB0aGUgY2FjaGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gIEFuIG9iamVjdCB3aXRoIGFsbCBraW5kcyBvZiBpbmZvcm1hdGlvblxuICAgKlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaGFzaEluZm8gIFRoZSBoYXNoIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gZ2V0SGFzaEZvclBhdGhcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgIFRoZSBzb3VyY2UgY29kZSBpZiB0aGUgZmlsZSB3YXMgYSB0ZXh0IGZpbGVcbiAgICogQHByb3BlcnR5IHtCdWZmZXJ9IGJpbmFyeURhdGEgIFRoZSBmaWxlIGlmIGl0IHdhcyBhIGJpbmFyeSBmaWxlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtaW1lVHlwZSAgVGhlIE1JTUUgdHlwZSBzYXZlZCBpbiB0aGUgY2FjaGUuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGRlcGVuZGVudEZpbGVzICBUaGUgZGVwZW5kZW50IGZpbGVzIHJldHVybmVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGluZyB0aGUgZmlsZSwgaWYgYW55LlxuICAgKi9cbiAgYXN5bmMgZ2V0KGZpbGVQYXRoKSB7XG4gICAgZChgRmV0Y2hpbmcgJHtmaWxlUGF0aH0gZnJvbSBjYWNoZWApO1xuICAgIGxldCBoYXNoSW5mbyA9IGF3YWl0IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoKHBhdGgucmVzb2x2ZShmaWxlUGF0aCkpO1xuXG4gICAgbGV0IGNvZGUgPSBudWxsO1xuICAgIGxldCBtaW1lVHlwZSA9IG51bGw7XG4gICAgbGV0IGJpbmFyeURhdGEgPSBudWxsO1xuICAgIGxldCBkZXBlbmRlbnRGaWxlcyA9IG51bGw7XG5cbiAgICBsZXQgY2FjaGVGaWxlID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgY2FjaGVGaWxlID0gcGF0aC5qb2luKHRoaXMuZ2V0Q2FjaGVQYXRoKCksIGhhc2hJbmZvLmhhc2gpO1xuICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG5cbiAgICAgIGlmIChoYXNoSW5mby5pc0ZpbGVCaW5hcnkpIHtcbiAgICAgICAgZChcIkZpbGUgaXMgYmluYXJ5LCByZWFkaW5nIG91dCBpbmZvXCIpO1xuICAgICAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoYXdhaXQgcGZzLnJlYWRGaWxlKGNhY2hlRmlsZSArICcuaW5mbycpKTtcbiAgICAgICAgbWltZVR5cGUgPSBpbmZvLm1pbWVUeXBlO1xuICAgICAgICBkZXBlbmRlbnRGaWxlcyA9IGluZm8uZGVwZW5kZW50RmlsZXM7XG5cbiAgICAgICAgYmluYXJ5RGF0YSA9IGhhc2hJbmZvLmJpbmFyeURhdGE7XG4gICAgICAgIGlmICghYmluYXJ5RGF0YSkge1xuICAgICAgICAgIGJpbmFyeURhdGEgPSBhd2FpdCBwZnMucmVhZEZpbGUoY2FjaGVGaWxlKTtcbiAgICAgICAgICBiaW5hcnlEYXRhID0gYXdhaXQgcHpsaWIuZ3VuemlwKGJpbmFyeURhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKGNhY2hlRmlsZSk7XG4gICAgICAgIGxldCBzdHIgPSAoYXdhaXQgcHpsaWIuZ3VuemlwKGJ1ZikpLnRvU3RyaW5nKCd1dGY4Jyk7XG5cbiAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShzdHIpO1xuICAgICAgICBjb2RlID0gcmVzdWx0LmNvZGU7XG4gICAgICAgIG1pbWVUeXBlID0gcmVzdWx0Lm1pbWVUeXBlO1xuICAgICAgICBkZXBlbmRlbnRGaWxlcyA9IHJlc3VsdC5kZXBlbmRlbnRGaWxlcztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkKGBGYWlsZWQgdG8gcmVhZCBjYWNoZSBmb3IgJHtmaWxlUGF0aH0sIGxvb2tlZCBpbiAke2NhY2hlRmlsZX06ICR7ZS5tZXNzYWdlfWApO1xuICAgIH1cblxuICAgIHJldHVybiB7IGhhc2hJbmZvLCBjb2RlLCBtaW1lVHlwZSwgYmluYXJ5RGF0YSwgZGVwZW5kZW50RmlsZXMgfTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNhdmVzIGEgY29tcGlsZWQgcmVzdWx0IHRvIGNhY2hlXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gaGFzaEluZm8gIFRoZSBoYXNoIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gZ2V0SGFzaEZvclBhdGhcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nIC8gQnVmZmVyfSBjb2RlT3JCaW5hcnlEYXRhICAgVGhlIGZpbGUncyBjb250ZW50cywgZWl0aGVyIGFzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgc3RyaW5nIG9yIGEgQnVmZmVyLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG1pbWVUeXBlICBUaGUgTUlNRSB0eXBlIHJldHVybmVkIGJ5IHRoZSBjb21waWxlci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nW119IGRlcGVuZGVudEZpbGVzICBUaGUgbGlzdCBvZiBkZXBlbmRlbnQgZmlsZXMgcmV0dXJuZWQgYnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY29tcGlsZXIuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICBDb21wbGV0aW9uLlxuICAgKi9cbiAgYXN5bmMgc2F2ZShoYXNoSW5mbywgY29kZU9yQmluYXJ5RGF0YSwgbWltZVR5cGUsIGRlcGVuZGVudEZpbGVzKSB7XG4gICAgbGV0IGJ1ZiA9IG51bGw7XG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbih0aGlzLmdldENhY2hlUGF0aCgpLCBoYXNoSW5mby5oYXNoKTtcbiAgICBkKGBTYXZpbmcgdG8gJHt0YXJnZXR9YCk7XG5cbiAgICBpZiAoaGFzaEluZm8uaXNGaWxlQmluYXJ5KSB7XG4gICAgICBidWYgPSBhd2FpdCBwemxpYi5nemlwKGNvZGVPckJpbmFyeURhdGEpO1xuICAgICAgYXdhaXQgcGZzLndyaXRlRmlsZSh0YXJnZXQgKyAnLmluZm8nLCBKU09OLnN0cmluZ2lmeSh7bWltZVR5cGUsIGRlcGVuZGVudEZpbGVzfSksICd1dGY4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZiA9IGF3YWl0IHB6bGliLmd6aXAobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeSh7Y29kZTogY29kZU9yQmluYXJ5RGF0YSwgbWltZVR5cGUsIGRlcGVuZGVudEZpbGVzfSkpKTtcbiAgICB9XG5cbiAgICBhd2FpdCBwZnMud3JpdGVGaWxlKHRhcmdldCwgYnVmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmaXJzdCBnZXQgYSBrZXkgdmlhIHtAbGluayBnZXR9LCB0aGVuIGlmIGl0IGZhaWxzLCBjYWxsIGEgbWV0aG9kXG4gICAqIHRvIHJldHJpZXZlIHRoZSBjb250ZW50cywgdGhlbiBzYXZlIHRoZSByZXN1bHQgdG8gY2FjaGUuXG4gICAqXG4gICAqIFRoZSBmZXRjaGVyIHBhcmFtZXRlciBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBzaWduYXR1cmU6XG4gICAqXG4gICAqIFByb21pc2U8T2JqZWN0PiBmZXRjaGVyKGZpbGVQYXRoIDogc3RyaW5nLCBoYXNoSW5mbyA6IE9iamVjdCk7XG4gICAqXG4gICAqIGhhc2hJbmZvIGlzIGEgdmFsdWUgcmV0dXJuZWQgZnJvbSBnZXRIYXNoRm9yUGF0aFxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIG9mIGZldGNoZXIgbXVzdCBiZSBhbiBPYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllczpcbiAgICpcbiAgICogbWltZVR5cGUgLSB0aGUgTUlNRSB0eXBlIG9mIHRoZSBkYXRhIHRvIHNhdmVcbiAgICogY29kZSAob3B0aW9uYWwpIC0gdGhlIHNvdXJjZSBjb2RlIGFzIGEgc3RyaW5nLCBpZiBmaWxlIGlzIHRleHRcbiAgICogYmluYXJ5RGF0YSAob3B0aW9uYWwpIC0gdGhlIGZpbGUgY29udGVudHMgYXMgYSBCdWZmZXIsIGlmIGZpbGUgaXMgYmluYXJ5XG4gICAqIGRlcGVuZGVudEZpbGVzIC0gdGhlIGRlcGVuZGVudCBmaWxlcyByZXR1cm5lZCBieSB0aGUgY29tcGlsZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZVBhdGggIFRoZSBwYXRoIHRvIHRoZSBmaWxlLiBGaWxlQ2hhbmdlZENhY2hlIHdpbGwgbG9va1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cCB0aGUgaGFzaCBhbmQgdXNlIHRoYXQgYXMgdGhlIGtleSBpbiB0aGUgY2FjaGUuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmZXRjaGVyICBBIG1ldGhvZCB3aGljaCBjb25mb3JtcyB0byB0aGUgZGVzY3JpcHRpb24gYWJvdmUuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gIEFuIE9iamVjdCB3aGljaCBoYXMgdGhlIHNhbWUgZmllbGRzIGFzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgZ2V0fSBtZXRob2QgcmV0dXJuIHJlc3VsdC5cbiAgICovXG4gIGFzeW5jIGdldE9yRmV0Y2goZmlsZVBhdGgsIGZldGNoZXIpIHtcbiAgICBsZXQgY2FjaGVSZXN1bHQgPSBhd2FpdCB0aGlzLmdldChmaWxlUGF0aCk7XG4gICAgbGV0IGFueURlcGVuZGVuY2llc0NoYW5nZWQgPSBhd2FpdCB0aGlzLmhhdmVBbnlEZXBlbmRlbnRGaWxlc0NoYW5nZWQoY2FjaGVSZXN1bHQpO1xuXG4gICAgaWYgKChjYWNoZVJlc3VsdC5jb2RlIHx8IGNhY2hlUmVzdWx0LmJpbmFyeURhdGEpICYmICFhbnlEZXBlbmRlbmNpZXNDaGFuZ2VkKSB7XG4gICAgICByZXR1cm4gY2FjaGVSZXN1bHQ7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGZldGNoZXIoZmlsZVBhdGgsIGNhY2hlUmVzdWx0Lmhhc2hJbmZvKSB8fCB7IGhhc2hJbmZvOiBjYWNoZVJlc3VsdC5oYXNoSW5mbyB9O1xuXG4gICAgaWYgKHJlc3VsdC5taW1lVHlwZSAmJiAhY2FjaGVSZXN1bHQuaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzKSB7XG4gICAgICBkKGBDYWNoZSBtaXNzOiBzYXZpbmcgb3V0IGluZm8gZm9yICR7ZmlsZVBhdGh9YCk7XG4gICAgICBhd2FpdCB0aGlzLnNhdmUoY2FjaGVSZXN1bHQuaGFzaEluZm8sIHJlc3VsdC5jb2RlIHx8IHJlc3VsdC5iaW5hcnlEYXRhLCByZXN1bHQubWltZVR5cGUsIHJlc3VsdC5kZXBlbmRlbnRGaWxlcyk7XG5cbiAgICAgIGNvbnN0IG1hcCA9IHJlc3VsdC5zb3VyY2VNYXBzO1xuICAgICAgaWYgKG1hcCkge1xuICAgICAgICBkKGBzb3VyY2UgbWFwIGZvciAke2ZpbGVQYXRofSBmb3VuZCwgc2F2aW5nIGl0IHRvICR7dGhpcy5nZXRTb3VyY2VNYXBQYXRoKCl9YCk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZVNvdXJjZU1hcChjYWNoZVJlc3VsdC5oYXNoSW5mbywgZmlsZVBhdGgsIG1hcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0Lmhhc2hJbmZvID0gY2FjaGVSZXN1bHQuaGFzaEluZm87XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZSBDaGVjayBpZiBhbnkgb2YgYSBmaWxlJ3MgZGVwZW5kZW5jaWVzIGhhdmUgY2hhbmdlZFxuICAgKi9cbiAgYXN5bmMgaGF2ZUFueURlcGVuZGVudEZpbGVzQ2hhbmdlZChjYWNoZVJlc3VsdCkge1xuICAgIGlmICghY2FjaGVSZXN1bHQuY29kZSB8fCAhY2FjaGVSZXN1bHQuZGVwZW5kZW50RmlsZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBkZXBlbmRlbnRGaWxlIG9mIGNhY2hlUmVzdWx0LmRlcGVuZGVudEZpbGVzKSB7XG4gICAgICBsZXQgaGFzRmlsZUNoYW5nZWQgPSBhd2FpdCB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5oYXNGaWxlQ2hhbmdlZChkZXBlbmRlbnRGaWxlKTtcbiAgICAgIGlmIChoYXNGaWxlQ2hhbmdlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGRlcGVuZGVudEZpbGVDYWNoZVJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0KGRlcGVuZGVudEZpbGUpO1xuICAgICAgaWYgKGRlcGVuZGVudEZpbGVDYWNoZVJlc3VsdC5kZXBlbmRlbnRGaWxlcyAmJiBkZXBlbmRlbnRGaWxlQ2FjaGVSZXN1bHQuZGVwZW5kZW50RmlsZXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBhbnlTdWJkZXBlbmRlbnRGaWxlc0NoYW5nZWQgPSBhd2FpdCB0aGlzLmhhdmVBbnlEZXBlbmRlbnRGaWxlc0NoYW5nZWQoZGVwZW5kZW50RmlsZUNhY2hlUmVzdWx0KTtcbiAgICAgICAgaWYgKGFueVN1YmRlcGVuZGVudEZpbGVzQ2hhbmdlZCkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cblxuICBnZXRTeW5jKGZpbGVQYXRoKSB7XG4gICAgZChgRmV0Y2hpbmcgJHtmaWxlUGF0aH0gZnJvbSBjYWNoZWApO1xuICAgIGxldCBoYXNoSW5mbyA9IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoU3luYyhwYXRoLnJlc29sdmUoZmlsZVBhdGgpKTtcblxuICAgIGxldCBjb2RlID0gbnVsbDtcbiAgICBsZXQgbWltZVR5cGUgPSBudWxsO1xuICAgIGxldCBiaW5hcnlEYXRhID0gbnVsbDtcbiAgICBsZXQgZGVwZW5kZW50RmlsZXMgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBjYWNoZUZpbGUgPSBwYXRoLmpvaW4odGhpcy5nZXRDYWNoZVBhdGgoKSwgaGFzaEluZm8uaGFzaCk7XG5cbiAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgaWYgKGhhc2hJbmZvLmlzRmlsZUJpbmFyeSkge1xuICAgICAgICBkKFwiRmlsZSBpcyBiaW5hcnksIHJlYWRpbmcgb3V0IGluZm9cIik7XG4gICAgICAgIGxldCBpbmZvID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoY2FjaGVGaWxlICsgJy5pbmZvJykpO1xuICAgICAgICBtaW1lVHlwZSA9IGluZm8ubWltZVR5cGU7XG4gICAgICAgIGRlcGVuZGVudEZpbGVzID0gaW5mby5kZXBlbmRlbnRGaWxlcztcblxuICAgICAgICBiaW5hcnlEYXRhID0gaGFzaEluZm8uYmluYXJ5RGF0YTtcbiAgICAgICAgaWYgKCFiaW5hcnlEYXRhKSB7XG4gICAgICAgICAgYmluYXJ5RGF0YSA9IGZzLnJlYWRGaWxlU3luYyhjYWNoZUZpbGUpO1xuICAgICAgICAgIGJpbmFyeURhdGEgPSB6bGliLmd1bnppcFN5bmMoYmluYXJ5RGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBidWYgPSBmcy5yZWFkRmlsZVN5bmMoY2FjaGVGaWxlKTtcbiAgICAgICAgbGV0IHN0ciA9ICh6bGliLmd1bnppcFN5bmMoYnVmKSkudG9TdHJpbmcoJ3V0ZjgnKTtcblxuICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHN0cik7XG4gICAgICAgIGNvZGUgPSByZXN1bHQuY29kZTtcbiAgICAgICAgbWltZVR5cGUgPSByZXN1bHQubWltZVR5cGU7XG4gICAgICAgIGRlcGVuZGVudEZpbGVzID0gcmVzdWx0LmRlcGVuZGVudEZpbGVzO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGQoYEZhaWxlZCB0byByZWFkIGNhY2hlIGZvciAke2ZpbGVQYXRofWApO1xuICAgIH1cblxuICAgIHJldHVybiB7IGhhc2hJbmZvLCBjb2RlLCBtaW1lVHlwZSwgYmluYXJ5RGF0YSwgZGVwZW5kZW50RmlsZXMgfTtcbiAgfVxuXG4gIHNhdmVTeW5jKGhhc2hJbmZvLCBjb2RlT3JCaW5hcnlEYXRhLCBtaW1lVHlwZSwgZGVwZW5kZW50RmlsZXMpIHtcbiAgICBsZXQgYnVmID0gbnVsbDtcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHRoaXMuZ2V0Q2FjaGVQYXRoKCksIGhhc2hJbmZvLmhhc2gpO1xuICAgIGQoYFNhdmluZyB0byAke3RhcmdldH1gKTtcblxuICAgIGlmIChoYXNoSW5mby5pc0ZpbGVCaW5hcnkpIHtcbiAgICAgIGJ1ZiA9IHpsaWIuZ3ppcFN5bmMoY29kZU9yQmluYXJ5RGF0YSk7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKHRhcmdldCArICcuaW5mbycsIEpTT04uc3RyaW5naWZ5KHttaW1lVHlwZSwgZGVwZW5kZW50RmlsZXN9KSwgJ3V0ZjgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmID0gemxpYi5nemlwU3luYyhuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHtjb2RlOiBjb2RlT3JCaW5hcnlEYXRhLCBtaW1lVHlwZSwgZGVwZW5kZW50RmlsZXN9KSkpO1xuICAgIH1cblxuICAgIGZzLndyaXRlRmlsZVN5bmModGFyZ2V0LCBidWYpO1xuICB9XG5cbiAgZ2V0T3JGZXRjaFN5bmMoZmlsZVBhdGgsIGZldGNoZXIpIHtcbiAgICBsZXQgY2FjaGVSZXN1bHQgPSB0aGlzLmdldFN5bmMoZmlsZVBhdGgpO1xuICAgIGlmIChjYWNoZVJlc3VsdC5jb2RlIHx8IGNhY2hlUmVzdWx0LmJpbmFyeURhdGEpIHJldHVybiBjYWNoZVJlc3VsdDtcblxuICAgIGxldCByZXN1bHQgPSBmZXRjaGVyKGZpbGVQYXRoLCBjYWNoZVJlc3VsdC5oYXNoSW5mbykgfHwgeyBoYXNoSW5mbzogY2FjaGVSZXN1bHQuaGFzaEluZm8gfTtcblxuICAgIGlmIChyZXN1bHQubWltZVR5cGUgJiYgIWNhY2hlUmVzdWx0Lmhhc2hJbmZvLmlzSW5Ob2RlTW9kdWxlcykge1xuICAgICAgZChgQ2FjaGUgbWlzczogc2F2aW5nIG91dCBpbmZvIGZvciAke2ZpbGVQYXRofWApO1xuICAgICAgdGhpcy5zYXZlU3luYyhjYWNoZVJlc3VsdC5oYXNoSW5mbywgcmVzdWx0LmNvZGUgfHwgcmVzdWx0LmJpbmFyeURhdGEsIHJlc3VsdC5taW1lVHlwZSwgcmVzdWx0LmRlcGVuZGVudEZpbGVzKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXAgPSByZXN1bHQuc291cmNlTWFwcztcbiAgICBpZiAobWFwKSB7XG4gICAgICBkKGBzb3VyY2UgbWFwIGZvciAke2ZpbGVQYXRofSBmb3VuZCwgc2F2aW5nIGl0IHRvICR7dGhpcy5nZXRTb3VyY2VNYXBQYXRoKCl9YCk7XG4gICAgICB0aGlzLnNhdmVTb3VyY2VNYXBTeW5jKGNhY2hlUmVzdWx0Lmhhc2hJbmZvLCBmaWxlUGF0aCwgbWFwKTtcbiAgICB9XG5cbiAgICByZXN1bHQuaGFzaEluZm8gPSBjYWNoZVJlc3VsdC5oYXNoSW5mbztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYnVpbGRTb3VyY2VNYXBUYXJnZXQoaGFzaEluZm8sIGZpbGVQYXRoKSB7XG4gICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGVQYXRoKTtcbiAgICBjb25zdCBtYXBGaWxlTmFtZSA9IGZpbGVOYW1lLnJlcGxhY2UocGF0aC5leHRuYW1lKGZpbGVOYW1lKSwgJy5qcy5tYXAnKTtcblxuICAgIGNvbnN0IHRhcmdldCA9IHBhdGguam9pbih0aGlzLmdldFNvdXJjZU1hcFBhdGgoKSwgbWFwRmlsZU5hbWUpO1xuICAgIGQoYFNvdXJjZW1hcCB0YXJnZXQgaXM6ICR7dGFyZ2V0fWApO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyBzb3VyY2VtYXAgc3RyaW5nIGludG8gY2FjaGUsIG9yIHNwZWNpZmllZCBzZXBhcmF0ZSBkaXJcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBoYXNoSW5mbyAgVGhlIGhhc2ggaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBnZXRIYXNoRm9yUGF0aFxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVQYXRoIFBhdGggdG8gb3JpZ2luYWwgZmlsZSB0byBjb25zdHJ1Y3Qgc291cmNlbWFwIGZpbGUgbmFtZVxuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gc291cmNlTWFwIFNvdXJjZW1hcCBkYXRhIGFzIHN0cmluZ1xuICAgKlxuICAgKiBAbWVtYmVyT2YgQ29tcGlsZUNhY2hlXG4gICAqL1xuICBhc3luYyBzYXZlU291cmNlTWFwKGhhc2hJbmZvLCBmaWxlUGF0aCwgc291cmNlTWFwKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5idWlsZFNvdXJjZU1hcFRhcmdldChoYXNoSW5mbywgZmlsZVBhdGgpO1xuICAgIGF3YWl0IHBmcy53cml0ZUZpbGUodGFyZ2V0LCBzb3VyY2VNYXAsICd1dGYtOCcpO1xuICB9XG5cbiAgc2F2ZVNvdXJjZU1hcFN5bmMoaGFzaEluZm8sIGZpbGVQYXRoLCBzb3VyY2VNYXApIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmJ1aWxkU291cmNlTWFwVGFyZ2V0KGhhc2hJbmZvLCBmaWxlUGF0aCk7XG4gICAgZnMud3JpdGVGaWxlU3luYyh0YXJnZXQsIHNvdXJjZU1hcCwgJ3V0Zi04Jyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldENhY2hlUGF0aCgpIHtcbiAgICAvLyBOQjogVGhpcyBpcyBhbiBldmlsIGhhY2sgc28gdGhhdCBjcmVhdGVGcm9tQ29tcGlsZXIgY2FuIHN0b21wIGl0XG4gICAgLy8gYXQgd2lsbFxuICAgIHJldHVybiB0aGlzLmNhY2hlUGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U291cmNlTWFwUGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VNYXBQYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhIGZpbGUgc2hvdWxkIG5vdCBiZSBjb21waWxlZC4gTm90ZSB0aGF0IHRoaXMgZG9lc24ndFxuICAgKiBuZWNlc3NhcmlseSBtZWFuIGl0IHdvbid0IGVuZCB1cCBpbiB0aGUgY2FjaGUsIG9ubHkgdGhhdCBpdHMgY29udGVudHMgYXJlXG4gICAqIHNhdmVkIHZlcmJhdGltIGluc3RlYWQgb2YgdHJ5aW5nIHRvIGZpbmQgYW4gYXBwcm9wcmlhdGUgY29tcGlsZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gaGFzaEluZm8gIFRoZSBoYXNoIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gZ2V0SGFzaEZvclBhdGhcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgYSBmaWxlIHNob3VsZCBiZSBpZ25vcmVkXG4gICAqL1xuICBzdGF0aWMgc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pIHtcbiAgICByZXR1cm4gaGFzaEluZm8uaXNNaW5pZmllZCB8fCBoYXNoSW5mby5pc0luTm9kZU1vZHVsZXMgfHwgaGFzaEluZm8uaGFzU291cmNlTWFwIHx8IGhhc2hJbmZvLmlzRmlsZUJpbmFyeTtcbiAgfVxufVxuIl19","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/digest-for-object.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createDigestForObject;\n\nvar _crypto = require('crypto');\n\nvar _crypto2 = _interopRequireDefault(_crypto);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction updateDigestForJsonValue(shasum, value) {\n  // Implmentation is similar to that of pretty-printing a JSON object, except:\n  // * Strings are not escaped.\n  // * No effort is made to avoid trailing commas.\n  // These shortcuts should not affect the correctness of this function.\n  const type = typeof value;\n\n  if (type === 'string') {\n    shasum.update('\"', 'utf8');\n    shasum.update(value, 'utf8');\n    shasum.update('\"', 'utf8');\n    return;\n  }\n\n  if (type === 'boolean' || type === 'number') {\n    shasum.update(value.toString(), 'utf8');\n    return;\n  }\n\n  if (!value) {\n    shasum.update('null', 'utf8');\n    return;\n  }\n\n  if (Array.isArray(value)) {\n    shasum.update('[', 'utf8');\n    for (let i = 0; i < value.length; i++) {\n      updateDigestForJsonValue(shasum, value[i]);\n      shasum.update(',', 'utf8');\n    }\n    shasum.update(']', 'utf8');\n    return;\n  }\n\n  // value must be an object: be sure to sort the keys.\n  let keys = Object.keys(value);\n  keys.sort();\n\n  shasum.update('{', 'utf8');\n\n  for (let i = 0; i < keys.length; i++) {\n    updateDigestForJsonValue(shasum, keys[i]);\n    shasum.update(': ', 'utf8');\n    updateDigestForJsonValue(shasum, value[keys[i]]);\n    shasum.update(',', 'utf8');\n  }\n\n  shasum.update('}', 'utf8');\n}\n\n/**\r\n * Creates a hash from a JS object\r\n * \r\n * @private  \r\n */\nfunction createDigestForObject(obj) {\n  let sha1 = _crypto2.default.createHash('sha1');\n  updateDigestForJsonValue(sha1, obj);\n\n  return sha1.digest('hex');\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kaWdlc3QtZm9yLW9iamVjdC5qcyJdLCJuYW1lcyI6WyJjcmVhdGVEaWdlc3RGb3JPYmplY3QiLCJ1cGRhdGVEaWdlc3RGb3JKc29uVmFsdWUiLCJzaGFzdW0iLCJ2YWx1ZSIsInR5cGUiLCJ1cGRhdGUiLCJ0b1N0cmluZyIsIkFycmF5IiwiaXNBcnJheSIsImkiLCJsZW5ndGgiLCJrZXlzIiwiT2JqZWN0Iiwic29ydCIsIm9iaiIsInNoYTEiLCJjcmVhdGVIYXNoIiwiZGlnZXN0Il0sIm1hcHBpbmdzIjoiOzs7OztrQkEwRHdCQSxxQjs7QUExRHhCOzs7Ozs7QUFFQSxTQUFTQyx3QkFBVCxDQUFrQ0MsTUFBbEMsRUFBMENDLEtBQTFDLEVBQWlEO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTUMsT0FBTyxPQUFPRCxLQUFwQjs7QUFFQSxNQUFJQyxTQUFTLFFBQWIsRUFBdUI7QUFDckJGLFdBQU9HLE1BQVAsQ0FBYyxHQUFkLEVBQW1CLE1BQW5CO0FBQ0FILFdBQU9HLE1BQVAsQ0FBY0YsS0FBZCxFQUFxQixNQUFyQjtBQUNBRCxXQUFPRyxNQUFQLENBQWMsR0FBZCxFQUFtQixNQUFuQjtBQUNBO0FBQ0Q7O0FBRUQsTUFBSUQsU0FBUyxTQUFULElBQXNCQSxTQUFTLFFBQW5DLEVBQTZDO0FBQzNDRixXQUFPRyxNQUFQLENBQWNGLE1BQU1HLFFBQU4sRUFBZCxFQUFnQyxNQUFoQztBQUNBO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDSCxLQUFMLEVBQVk7QUFDVkQsV0FBT0csTUFBUCxDQUFjLE1BQWQsRUFBc0IsTUFBdEI7QUFDQTtBQUNEOztBQUVELE1BQUlFLE1BQU1DLE9BQU4sQ0FBY0wsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCRCxXQUFPRyxNQUFQLENBQWMsR0FBZCxFQUFtQixNQUFuQjtBQUNBLFNBQUssSUFBSUksSUFBRSxDQUFYLEVBQWNBLElBQUlOLE1BQU1PLE1BQXhCLEVBQWdDRCxHQUFoQyxFQUFxQztBQUNuQ1IsK0JBQXlCQyxNQUF6QixFQUFpQ0MsTUFBTU0sQ0FBTixDQUFqQztBQUNBUCxhQUFPRyxNQUFQLENBQWMsR0FBZCxFQUFtQixNQUFuQjtBQUNEO0FBQ0RILFdBQU9HLE1BQVAsQ0FBYyxHQUFkLEVBQW1CLE1BQW5CO0FBQ0E7QUFDRDs7QUFFRDtBQUNBLE1BQUlNLE9BQU9DLE9BQU9ELElBQVAsQ0FBWVIsS0FBWixDQUFYO0FBQ0FRLE9BQUtFLElBQUw7O0FBRUFYLFNBQU9HLE1BQVAsQ0FBYyxHQUFkLEVBQW1CLE1BQW5COztBQUVBLE9BQUssSUFBSUksSUFBRSxDQUFYLEVBQWNBLElBQUlFLEtBQUtELE1BQXZCLEVBQStCRCxHQUEvQixFQUFvQztBQUNsQ1IsNkJBQXlCQyxNQUF6QixFQUFpQ1MsS0FBS0YsQ0FBTCxDQUFqQztBQUNBUCxXQUFPRyxNQUFQLENBQWMsSUFBZCxFQUFvQixNQUFwQjtBQUNBSiw2QkFBeUJDLE1BQXpCLEVBQWlDQyxNQUFNUSxLQUFLRixDQUFMLENBQU4sQ0FBakM7QUFDQVAsV0FBT0csTUFBUCxDQUFjLEdBQWQsRUFBbUIsTUFBbkI7QUFDRDs7QUFFREgsU0FBT0csTUFBUCxDQUFjLEdBQWQsRUFBbUIsTUFBbkI7QUFDRDs7QUFHRDs7Ozs7QUFLZSxTQUFTTCxxQkFBVCxDQUErQmMsR0FBL0IsRUFBb0M7QUFDakQsTUFBSUMsT0FBTyxpQkFBT0MsVUFBUCxDQUFrQixNQUFsQixDQUFYO0FBQ0FmLDJCQUF5QmMsSUFBekIsRUFBK0JELEdBQS9COztBQUVBLFNBQU9DLEtBQUtFLE1BQUwsQ0FBWSxLQUFaLENBQVA7QUFDRCIsImZpbGUiOiJkaWdlc3QtZm9yLW9iamVjdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZURpZ2VzdEZvckpzb25WYWx1ZShzaGFzdW0sIHZhbHVlKSB7XHJcbiAgLy8gSW1wbG1lbnRhdGlvbiBpcyBzaW1pbGFyIHRvIHRoYXQgb2YgcHJldHR5LXByaW50aW5nIGEgSlNPTiBvYmplY3QsIGV4Y2VwdDpcclxuICAvLyAqIFN0cmluZ3MgYXJlIG5vdCBlc2NhcGVkLlxyXG4gIC8vICogTm8gZWZmb3J0IGlzIG1hZGUgdG8gYXZvaWQgdHJhaWxpbmcgY29tbWFzLlxyXG4gIC8vIFRoZXNlIHNob3J0Y3V0cyBzaG91bGQgbm90IGFmZmVjdCB0aGUgY29ycmVjdG5lc3Mgb2YgdGhpcyBmdW5jdGlvbi5cclxuICBjb25zdCB0eXBlID0gdHlwZW9mKHZhbHVlKTtcclxuXHJcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBzaGFzdW0udXBkYXRlKCdcIicsICd1dGY4Jyk7XHJcbiAgICBzaGFzdW0udXBkYXRlKHZhbHVlLCAndXRmOCcpO1xyXG4gICAgc2hhc3VtLnVwZGF0ZSgnXCInLCAndXRmOCcpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGUgPT09ICdib29sZWFuJyB8fCB0eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgc2hhc3VtLnVwZGF0ZSh2YWx1ZS50b1N0cmluZygpLCAndXRmOCcpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKCF2YWx1ZSkge1xyXG4gICAgc2hhc3VtLnVwZGF0ZSgnbnVsbCcsICd1dGY4Jyk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgIHNoYXN1bS51cGRhdGUoJ1snLCAndXRmOCcpO1xyXG4gICAgZm9yIChsZXQgaT0wOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdXBkYXRlRGlnZXN0Rm9ySnNvblZhbHVlKHNoYXN1bSwgdmFsdWVbaV0pO1xyXG4gICAgICBzaGFzdW0udXBkYXRlKCcsJywgJ3V0ZjgnKTtcclxuICAgIH1cclxuICAgIHNoYXN1bS51cGRhdGUoJ10nLCAndXRmOCcpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gdmFsdWUgbXVzdCBiZSBhbiBvYmplY3Q6IGJlIHN1cmUgdG8gc29ydCB0aGUga2V5cy5cclxuICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcclxuICBrZXlzLnNvcnQoKTtcclxuXHJcbiAgc2hhc3VtLnVwZGF0ZSgneycsICd1dGY4Jyk7XHJcblxyXG4gIGZvciAobGV0IGk9MDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHVwZGF0ZURpZ2VzdEZvckpzb25WYWx1ZShzaGFzdW0sIGtleXNbaV0pO1xyXG4gICAgc2hhc3VtLnVwZGF0ZSgnOiAnLCAndXRmOCcpO1xyXG4gICAgdXBkYXRlRGlnZXN0Rm9ySnNvblZhbHVlKHNoYXN1bSwgdmFsdWVba2V5c1tpXV0pO1xyXG4gICAgc2hhc3VtLnVwZGF0ZSgnLCcsICd1dGY4Jyk7XHJcbiAgfVxyXG5cclxuICBzaGFzdW0udXBkYXRlKCd9JywgJ3V0ZjgnKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgaGFzaCBmcm9tIGEgSlMgb2JqZWN0XHJcbiAqIFxyXG4gKiBAcHJpdmF0ZSAgXHJcbiAqLyBcclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlRGlnZXN0Rm9yT2JqZWN0KG9iaikge1xyXG4gIGxldCBzaGExID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcclxuICB1cGRhdGVEaWdlc3RGb3JKc29uVmFsdWUoc2hhMSwgb2JqKTtcclxuICBcclxuICByZXR1cm4gc2hhMS5kaWdlc3QoJ2hleCcpO1xyXG59XHJcbiJdfQ==","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/read-only-compiler.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n/**\n * ReadOnlyCompiler is a compiler which allows the host to inject all of the compiler\n * metadata information so that {@link CompileCache} et al are able to recreate the\n * hash without having two separate code paths.\n */\nclass ReadOnlyCompiler {\n  /**\n   * Creates a ReadOnlyCompiler instance\n   *\n   * @private\n   */\n  constructor(name, compilerVersion, compilerOptions, inputMimeTypes) {\n    Object.assign(this, { name, compilerVersion, compilerOptions, inputMimeTypes });\n  }\n\n  shouldCompileFile() {\n    return _asyncToGenerator(function* () {\n      return true;\n    })();\n  }\n  determineDependentFiles() {\n    return _asyncToGenerator(function* () {\n      return [];\n    })();\n  }\n\n  compile() {\n    return _asyncToGenerator(function* () {\n      throw new Error(\"Read-only compilers can't compile\");\n    })();\n  }\n\n  shouldCompileFileSync() {\n    return true;\n  }\n  determineDependentFilesSync() {\n    return [];\n  }\n\n  compileSync() {\n    throw new Error(\"Read-only compilers can't compile\");\n  }\n\n  getCompilerVersion() {\n    return this.compilerVersion;\n  }\n}\nexports.default = ReadOnlyCompiler;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZWFkLW9ubHktY29tcGlsZXIuanMiXSwibmFtZXMiOlsiUmVhZE9ubHlDb21waWxlciIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNvbXBpbGVyVmVyc2lvbiIsImNvbXBpbGVyT3B0aW9ucyIsImlucHV0TWltZVR5cGVzIiwiT2JqZWN0IiwiYXNzaWduIiwic2hvdWxkQ29tcGlsZUZpbGUiLCJkZXRlcm1pbmVEZXBlbmRlbnRGaWxlcyIsImNvbXBpbGUiLCJFcnJvciIsInNob3VsZENvbXBpbGVGaWxlU3luYyIsImRldGVybWluZURlcGVuZGVudEZpbGVzU3luYyIsImNvbXBpbGVTeW5jIiwiZ2V0Q29tcGlsZXJWZXJzaW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7OztBQUtlLE1BQU1BLGdCQUFOLENBQXVCO0FBQ3BDOzs7OztBQUtBQyxjQUFZQyxJQUFaLEVBQWtCQyxlQUFsQixFQUFtQ0MsZUFBbkMsRUFBb0RDLGNBQXBELEVBQW9FO0FBQ2xFQyxXQUFPQyxNQUFQLENBQWMsSUFBZCxFQUFvQixFQUFFTCxJQUFGLEVBQVFDLGVBQVIsRUFBeUJDLGVBQXpCLEVBQTBDQyxjQUExQyxFQUFwQjtBQUNEOztBQUVLRyxtQkFBTixHQUEwQjtBQUFBO0FBQUUsYUFBTyxJQUFQO0FBQUY7QUFBZ0I7QUFDcENDLHlCQUFOLEdBQWdDO0FBQUE7QUFBRSxhQUFPLEVBQVA7QUFBRjtBQUFjOztBQUV4Q0MsU0FBTixHQUFnQjtBQUFBO0FBQ2QsWUFBTSxJQUFJQyxLQUFKLENBQVUsbUNBQVYsQ0FBTjtBQURjO0FBRWY7O0FBRURDLDBCQUF3QjtBQUFFLFdBQU8sSUFBUDtBQUFjO0FBQ3hDQyxnQ0FBOEI7QUFBRSxXQUFPLEVBQVA7QUFBWTs7QUFFNUNDLGdCQUFjO0FBQ1osVUFBTSxJQUFJSCxLQUFKLENBQVUsbUNBQVYsQ0FBTjtBQUNEOztBQUVESSx1QkFBcUI7QUFDbkIsV0FBTyxLQUFLWixlQUFaO0FBQ0Q7QUExQm1DO2tCQUFqQkgsZ0IiLCJmaWxlIjoicmVhZC1vbmx5LWNvbXBpbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZWFkT25seUNvbXBpbGVyIGlzIGEgY29tcGlsZXIgd2hpY2ggYWxsb3dzIHRoZSBob3N0IHRvIGluamVjdCBhbGwgb2YgdGhlIGNvbXBpbGVyXG4gKiBtZXRhZGF0YSBpbmZvcm1hdGlvbiBzbyB0aGF0IHtAbGluayBDb21waWxlQ2FjaGV9IGV0IGFsIGFyZSBhYmxlIHRvIHJlY3JlYXRlIHRoZVxuICogaGFzaCB3aXRob3V0IGhhdmluZyB0d28gc2VwYXJhdGUgY29kZSBwYXRocy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhZE9ubHlDb21waWxlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVhZE9ubHlDb21waWxlciBpbnN0YW5jZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSwgY29tcGlsZXJWZXJzaW9uLCBjb21waWxlck9wdGlvbnMsIGlucHV0TWltZVR5cGVzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IG5hbWUsIGNvbXBpbGVyVmVyc2lvbiwgY29tcGlsZXJPcHRpb25zLCBpbnB1dE1pbWVUeXBlcyB9KTtcbiAgfVxuXG4gIGFzeW5jIHNob3VsZENvbXBpbGVGaWxlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICBhc3luYyBkZXRlcm1pbmVEZXBlbmRlbnRGaWxlcygpIHsgcmV0dXJuIFtdOyB9XG5cbiAgYXN5bmMgY29tcGlsZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkLW9ubHkgY29tcGlsZXJzIGNhbid0IGNvbXBpbGVcIik7XG4gIH1cblxuICBzaG91bGRDb21waWxlRmlsZVN5bmMoKSB7IHJldHVybiB0cnVlOyB9XG4gIGRldGVybWluZURlcGVuZGVudEZpbGVzU3luYygpIHsgcmV0dXJuIFtdOyB9XG5cbiAgY29tcGlsZVN5bmMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhZC1vbmx5IGNvbXBpbGVycyBjYW4ndCBjb21waWxlXCIpO1xuICB9XG5cbiAgZ2V0Q29tcGlsZXJWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVyVmVyc2lvbjtcbiAgfVxufVxuIl19","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/browser-signal.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.send = send;\nexports.listen = listen;\n\nvar _Observable = require('rxjs/Observable');\n\nvar _Subject = require('rxjs/Subject');\n\nrequire('rxjs/add/observable/throw');\n\nconst isElectron = 'type' in process;\nconst isBrowser = process.type === 'browser';\n\nconst ipc = !isElectron ? null : isBrowser ? require('electron').ipcMain : require('electron').ipcRenderer;\n\nconst channelList = {};\n\nfunction send(channel) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  if (isElectron && !isBrowser) {\n    ipc.send(channel, ...args);\n    return;\n  }\n\n  if (!(channel in channelList)) return;\n\n  let subj = channelList[channel].subj;\n\n  subj.next(args);\n}\n\nfunction listen(channel) {\n  if (isElectron && !isBrowser) return _Observable.Observable.throw(new Error(\"Can only call listen from browser\"));\n\n  return _Observable.Observable.create(s => {\n    if (!(channel in channelList)) {\n      let subj = new _Subject.Subject();\n      let ipcListener = function (e) {\n        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        subj.next(args);\n      };\n\n      channelList[channel] = { subj, refcount: 0 };\n      if (isElectron && isBrowser) {\n        ipc.on(channel, ipcListener);\n        channelList[channel].listener = ipcListener;\n      }\n    }\n\n    channelList[channel].refcount++;\n\n    let disp = channelList[channel].subj.subscribe(s);\n    disp.add(() => {\n      channelList[channel].refcount--;\n      if (channelList[channel].refcount > 0) return;\n\n      if (channelList[channel].listener) {\n        ipc.removeListener(channel, channelList[channel].listener);\n      }\n\n      delete channelList.channel;\n    });\n\n    return disp;\n  });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9icm93c2VyLXNpZ25hbC5qcyJdLCJuYW1lcyI6WyJzZW5kIiwibGlzdGVuIiwiaXNFbGVjdHJvbiIsInByb2Nlc3MiLCJpc0Jyb3dzZXIiLCJ0eXBlIiwiaXBjIiwicmVxdWlyZSIsImlwY01haW4iLCJpcGNSZW5kZXJlciIsImNoYW5uZWxMaXN0IiwiY2hhbm5lbCIsImFyZ3MiLCJzdWJqIiwibmV4dCIsInRocm93IiwiRXJyb3IiLCJjcmVhdGUiLCJzIiwiaXBjTGlzdGVuZXIiLCJlIiwicmVmY291bnQiLCJvbiIsImxpc3RlbmVyIiwiZGlzcCIsInN1YnNjcmliZSIsImFkZCIsInJlbW92ZUxpc3RlbmVyIl0sIm1hcHBpbmdzIjoiOzs7OztRQWFnQkEsSSxHQUFBQSxJO1FBWUFDLE0sR0FBQUEsTTs7QUF6QmhCOztBQUNBOztBQUVBOztBQUVBLE1BQU1DLGFBQWEsVUFBVUMsT0FBN0I7QUFDQSxNQUFNQyxZQUFZRCxRQUFRRSxJQUFSLEtBQWlCLFNBQW5DOztBQUVBLE1BQU1DLE1BQU0sQ0FBQ0osVUFBRCxHQUFjLElBQWQsR0FDVkUsWUFBWUcsUUFBUSxVQUFSLEVBQW9CQyxPQUFoQyxHQUEwQ0QsUUFBUSxVQUFSLEVBQW9CRSxXQURoRTs7QUFHQSxNQUFNQyxjQUFjLEVBQXBCOztBQUVPLFNBQVNWLElBQVQsQ0FBY1csT0FBZCxFQUFnQztBQUFBLG9DQUFOQyxJQUFNO0FBQU5BLFFBQU07QUFBQTs7QUFDckMsTUFBSVYsY0FBYyxDQUFDRSxTQUFuQixFQUE4QjtBQUM1QkUsUUFBSU4sSUFBSixDQUFTVyxPQUFULEVBQWtCLEdBQUdDLElBQXJCO0FBQ0E7QUFDRDs7QUFFRCxNQUFJLEVBQUVELFdBQVdELFdBQWIsQ0FBSixFQUErQjs7QUFOTSxNQVEvQkcsSUFSK0IsR0FRdEJILFlBQVlDLE9BQVosQ0FSc0IsQ0FRL0JFLElBUitCOztBQVNyQ0EsT0FBS0MsSUFBTCxDQUFVRixJQUFWO0FBQ0Q7O0FBRU0sU0FBU1gsTUFBVCxDQUFnQlUsT0FBaEIsRUFBeUI7QUFDOUIsTUFBSVQsY0FBYyxDQUFDRSxTQUFuQixFQUE4QixPQUFPLHVCQUFXVyxLQUFYLENBQWlCLElBQUlDLEtBQUosQ0FBVSxtQ0FBVixDQUFqQixDQUFQOztBQUU5QixTQUFPLHVCQUFXQyxNQUFYLENBQW1CQyxDQUFELElBQU87QUFDOUIsUUFBSSxFQUFFUCxXQUFXRCxXQUFiLENBQUosRUFBK0I7QUFDN0IsVUFBSUcsT0FBTyxzQkFBWDtBQUNBLFVBQUlNLGNBQWMsVUFBQ0MsQ0FBRCxFQUFnQjtBQUFBLDJDQUFUUixJQUFTO0FBQVRBLGNBQVM7QUFBQTs7QUFBRUMsYUFBS0MsSUFBTCxDQUFVRixJQUFWO0FBQWtCLE9BQXREOztBQUVBRixrQkFBWUMsT0FBWixJQUF1QixFQUFFRSxJQUFGLEVBQVFRLFVBQVUsQ0FBbEIsRUFBdkI7QUFDQSxVQUFJbkIsY0FBY0UsU0FBbEIsRUFBNkI7QUFDM0JFLFlBQUlnQixFQUFKLENBQU9YLE9BQVAsRUFBZ0JRLFdBQWhCO0FBQ0FULG9CQUFZQyxPQUFaLEVBQXFCWSxRQUFyQixHQUFnQ0osV0FBaEM7QUFDRDtBQUNGOztBQUVEVCxnQkFBWUMsT0FBWixFQUFxQlUsUUFBckI7O0FBRUEsUUFBSUcsT0FBT2QsWUFBWUMsT0FBWixFQUFxQkUsSUFBckIsQ0FBMEJZLFNBQTFCLENBQW9DUCxDQUFwQyxDQUFYO0FBQ0FNLFNBQUtFLEdBQUwsQ0FBUyxNQUFNO0FBQ2JoQixrQkFBWUMsT0FBWixFQUFxQlUsUUFBckI7QUFDQSxVQUFJWCxZQUFZQyxPQUFaLEVBQXFCVSxRQUFyQixHQUFnQyxDQUFwQyxFQUF1Qzs7QUFFdkMsVUFBSVgsWUFBWUMsT0FBWixFQUFxQlksUUFBekIsRUFBbUM7QUFDakNqQixZQUFJcUIsY0FBSixDQUFtQmhCLE9BQW5CLEVBQTRCRCxZQUFZQyxPQUFaLEVBQXFCWSxRQUFqRDtBQUNEOztBQUVELGFBQU9iLFlBQVlDLE9BQW5CO0FBQ0QsS0FURDs7QUFXQSxXQUFPYSxJQUFQO0FBQ0QsR0EzQk0sQ0FBUDtBQTRCRCIsImZpbGUiOiJicm93c2VyLXNpZ25hbC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcclxuaW1wb3J0IHtTdWJqZWN0fSBmcm9tICdyeGpzL1N1YmplY3QnO1xyXG5cclxuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL3Rocm93JztcclxuXHJcbmNvbnN0IGlzRWxlY3Ryb24gPSAndHlwZScgaW4gcHJvY2VzcztcclxuY29uc3QgaXNCcm93c2VyID0gcHJvY2Vzcy50eXBlID09PSAnYnJvd3Nlcic7XHJcblxyXG5jb25zdCBpcGMgPSAhaXNFbGVjdHJvbiA/IG51bGwgOlxyXG4gIGlzQnJvd3NlciA/IHJlcXVpcmUoJ2VsZWN0cm9uJykuaXBjTWFpbiA6IHJlcXVpcmUoJ2VsZWN0cm9uJykuaXBjUmVuZGVyZXI7XHJcblxyXG5jb25zdCBjaGFubmVsTGlzdCA9IHt9O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNlbmQoY2hhbm5lbCwgLi4uYXJncykge1xyXG4gIGlmIChpc0VsZWN0cm9uICYmICFpc0Jyb3dzZXIpIHtcclxuICAgIGlwYy5zZW5kKGNoYW5uZWwsIC4uLmFyZ3MpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKCEoY2hhbm5lbCBpbiBjaGFubmVsTGlzdCkpIHJldHVybjtcclxuXHJcbiAgbGV0IHsgc3ViaiB9ID0gY2hhbm5lbExpc3RbY2hhbm5lbF07XHJcbiAgc3Viai5uZXh0KGFyZ3MpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuKGNoYW5uZWwpIHtcclxuICBpZiAoaXNFbGVjdHJvbiAmJiAhaXNCcm93c2VyKSByZXR1cm4gT2JzZXJ2YWJsZS50aHJvdyhuZXcgRXJyb3IoXCJDYW4gb25seSBjYWxsIGxpc3RlbiBmcm9tIGJyb3dzZXJcIikpO1xyXG5cclxuICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKHMpID0+IHtcclxuICAgIGlmICghKGNoYW5uZWwgaW4gY2hhbm5lbExpc3QpKSB7XHJcbiAgICAgIGxldCBzdWJqID0gbmV3IFN1YmplY3QoKTtcclxuICAgICAgbGV0IGlwY0xpc3RlbmVyID0gKGUsIC4uLmFyZ3MpID0+IHsgc3Viai5uZXh0KGFyZ3MpOyB9O1xyXG5cclxuICAgICAgY2hhbm5lbExpc3RbY2hhbm5lbF0gPSB7IHN1YmosIHJlZmNvdW50OiAwIH07XHJcbiAgICAgIGlmIChpc0VsZWN0cm9uICYmIGlzQnJvd3Nlcikge1xyXG4gICAgICAgIGlwYy5vbihjaGFubmVsLCBpcGNMaXN0ZW5lcik7XHJcbiAgICAgICAgY2hhbm5lbExpc3RbY2hhbm5lbF0ubGlzdGVuZXIgPSBpcGNMaXN0ZW5lcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNoYW5uZWxMaXN0W2NoYW5uZWxdLnJlZmNvdW50Kys7XHJcblxyXG4gICAgbGV0IGRpc3AgPSBjaGFubmVsTGlzdFtjaGFubmVsXS5zdWJqLnN1YnNjcmliZShzKTtcclxuICAgIGRpc3AuYWRkKCgpID0+IHtcclxuICAgICAgY2hhbm5lbExpc3RbY2hhbm5lbF0ucmVmY291bnQtLTtcclxuICAgICAgaWYgKGNoYW5uZWxMaXN0W2NoYW5uZWxdLnJlZmNvdW50ID4gMCkgcmV0dXJuO1xyXG5cclxuICAgICAgaWYgKGNoYW5uZWxMaXN0W2NoYW5uZWxdLmxpc3RlbmVyKSB7XHJcbiAgICAgICAgaXBjLnJlbW92ZUxpc3RlbmVyKGNoYW5uZWwsIGNoYW5uZWxMaXN0W2NoYW5uZWxdLmxpc3RlbmVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGVsZXRlIGNoYW5uZWxMaXN0LmNoYW5uZWw7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZGlzcDtcclxuICB9KTtcclxufVxyXG4iXX0=","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/rig-mime-types.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.init = init;\n\nvar _mimeTypes = require('@paulcbetts/mime-types');\n\nvar _mimeTypes2 = _interopRequireDefault(_mimeTypes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst typesToRig = {\n  'text/typescript': 'ts',\n  'text/tsx': 'tsx',\n  'text/jade': 'jade',\n  'text/cson': 'cson',\n  'text/stylus': 'styl',\n  'text/sass': 'sass',\n  'text/scss': 'scss',\n  'text/vue': 'vue',\n  'text/graphql': 'graphql'\n};\n\n/**\r\n * Adds MIME types for types not in the mime-types package\r\n *\r\n * @private\r\n */\nfunction init() {\n  Object.keys(typesToRig).forEach(type => {\n    let ext = typesToRig[type];\n\n    _mimeTypes2.default.types[ext] = type;\n    _mimeTypes2.default.extensions[type] = [ext];\n  });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yaWctbWltZS10eXBlcy5qcyJdLCJuYW1lcyI6WyJpbml0IiwidHlwZXNUb1JpZyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwidHlwZSIsImV4dCIsInR5cGVzIiwiZXh0ZW5zaW9ucyJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFtQmdCQSxJLEdBQUFBLEk7O0FBbkJoQjs7Ozs7O0FBRUEsTUFBTUMsYUFBYTtBQUNqQixxQkFBbUIsSUFERjtBQUVqQixjQUFZLEtBRks7QUFHakIsZUFBYSxNQUhJO0FBSWpCLGVBQWEsTUFKSTtBQUtqQixpQkFBZSxNQUxFO0FBTWpCLGVBQWEsTUFOSTtBQU9qQixlQUFhLE1BUEk7QUFRakIsY0FBWSxLQVJLO0FBU2pCLGtCQUFnQjtBQVRDLENBQW5COztBQVlBOzs7OztBQUtPLFNBQVNELElBQVQsR0FBZ0I7QUFDckJFLFNBQU9DLElBQVAsQ0FBWUYsVUFBWixFQUF3QkcsT0FBeEIsQ0FBaUNDLElBQUQsSUFBVTtBQUN4QyxRQUFJQyxNQUFNTCxXQUFXSSxJQUFYLENBQVY7O0FBRUEsd0JBQVVFLEtBQVYsQ0FBZ0JELEdBQWhCLElBQXVCRCxJQUF2QjtBQUNBLHdCQUFVRyxVQUFWLENBQXFCSCxJQUFyQixJQUE2QixDQUFDQyxHQUFELENBQTdCO0FBQ0QsR0FMRDtBQU1EIiwiZmlsZSI6InJpZy1taW1lLXR5cGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1pbWVUeXBlcyBmcm9tICdAcGF1bGNiZXR0cy9taW1lLXR5cGVzJztcclxuXHJcbmNvbnN0IHR5cGVzVG9SaWcgPSB7XHJcbiAgJ3RleHQvdHlwZXNjcmlwdCc6ICd0cycsXHJcbiAgJ3RleHQvdHN4JzogJ3RzeCcsXHJcbiAgJ3RleHQvamFkZSc6ICdqYWRlJyxcclxuICAndGV4dC9jc29uJzogJ2Nzb24nLFxyXG4gICd0ZXh0L3N0eWx1cyc6ICdzdHlsJyxcclxuICAndGV4dC9zYXNzJzogJ3Nhc3MnLFxyXG4gICd0ZXh0L3Njc3MnOiAnc2NzcycsXHJcbiAgJ3RleHQvdnVlJzogJ3Z1ZScsXHJcbiAgJ3RleHQvZ3JhcGhxbCc6ICdncmFwaHFsJyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIE1JTUUgdHlwZXMgZm9yIHR5cGVzIG5vdCBpbiB0aGUgbWltZS10eXBlcyBwYWNrYWdlXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcclxuICBPYmplY3Qua2V5cyh0eXBlc1RvUmlnKS5mb3JFYWNoKCh0eXBlKSA9PiB7XHJcbiAgICBsZXQgZXh0ID0gdHlwZXNUb1JpZ1t0eXBlXTtcclxuXHJcbiAgICBtaW1lVHlwZXMudHlwZXNbZXh0XSA9IHR5cGU7XHJcbiAgICBtaW1lVHlwZXMuZXh0ZW5zaW9uc1t0eXBlXSA9IFtleHRdO1xyXG4gIH0pO1xyXG59XHJcbiJdfQ==","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/require-hook.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = registerRequireExtension;\n\nvar _mimeTypes = require('@paulcbetts/mime-types');\n\nvar _mimeTypes2 = _interopRequireDefault(_mimeTypes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nlet HMR = false;\n\nconst d = require('debug')('electron-compile:require-hook');\nlet electron = null;\n\nif (process.type === 'renderer') {\n  window.__hot = [];\n  electron = require('electron');\n  HMR = electron.remote.getGlobal('__electron_compile_hmr_enabled__');\n\n  if (HMR) {\n    electron.ipcRenderer.on('__electron-compile__HMR', () => {\n      d(\"Got HMR signal!\");\n\n      // Reset the module cache\n      let cache = require('module')._cache;\n      let toEject = Object.keys(cache).filter(x => x && !x.match(/[\\\\\\/](node_modules|.*\\.asar)[\\\\\\/]/i));\n      toEject.forEach(x => {\n        d(`Removing node module entry for ${x}`);\n        delete cache[x];\n      });\n\n      window.__hot.forEach(fn => fn());\n    });\n  }\n}\n\n/**\r\n * Initializes the node.js hook that allows us to intercept files loaded by\r\n * node.js and rewrite them. This method along with {@link initializeProtocolHook}\r\n * are the top-level methods that electron-compile actually uses to intercept\r\n * code that Electron loads.\r\n *\r\n * @param  {CompilerHost} compilerHost  The compiler host to use for compilation.\r\n */\nfunction registerRequireExtension(compilerHost) {\n  if (HMR) {\n    try {\n      require('module').prototype.hot = {\n        accept: cb => window.__hot.push(cb)\n      };\n\n      require.main.require('react-hot-loader/patch');\n    } catch (e) {\n      console.error(`Couldn't require react-hot-loader/patch, you need to add react-hot-loader@3 as a dependency! ${e.message}`);\n    }\n  }\n\n  Object.keys(compilerHost.compilersByMimeType).forEach(mimeType => {\n    let ext = _mimeTypes2.default.extension(mimeType);\n\n    require.extensions[`.${ext}`] = (module, filename) => {\n      var _compilerHost$compile = compilerHost.compileSync(filename);\n\n      let code = _compilerHost$compile.code;\n\n\n      if (code === null) {\n        console.error(`null code returned for \"${filename}\".  Please raise an issue on 'electron-compile' with the contents of this file.`);\n      }\n\n      module._compile(code, filename);\n    };\n  });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXF1aXJlLWhvb2suanMiXSwibmFtZXMiOlsicmVnaXN0ZXJSZXF1aXJlRXh0ZW5zaW9uIiwiSE1SIiwiZCIsInJlcXVpcmUiLCJlbGVjdHJvbiIsInByb2Nlc3MiLCJ0eXBlIiwid2luZG93IiwiX19ob3QiLCJyZW1vdGUiLCJnZXRHbG9iYWwiLCJpcGNSZW5kZXJlciIsIm9uIiwiY2FjaGUiLCJfY2FjaGUiLCJ0b0VqZWN0IiwiT2JqZWN0Iiwia2V5cyIsImZpbHRlciIsIngiLCJtYXRjaCIsImZvckVhY2giLCJmbiIsImNvbXBpbGVySG9zdCIsInByb3RvdHlwZSIsImhvdCIsImFjY2VwdCIsImNiIiwicHVzaCIsIm1haW4iLCJlIiwiY29uc29sZSIsImVycm9yIiwibWVzc2FnZSIsImNvbXBpbGVyc0J5TWltZVR5cGUiLCJtaW1lVHlwZSIsImV4dCIsImV4dGVuc2lvbiIsImV4dGVuc2lvbnMiLCJtb2R1bGUiLCJmaWxlbmFtZSIsImNvbXBpbGVTeW5jIiwiY29kZSIsIl9jb21waWxlIl0sIm1hcHBpbmdzIjoiOzs7OztrQkFxQ3dCQSx3Qjs7QUFyQ3hCOzs7Ozs7QUFFQSxJQUFJQyxNQUFNLEtBQVY7O0FBRUEsTUFBTUMsSUFBSUMsUUFBUSxPQUFSLEVBQWlCLCtCQUFqQixDQUFWO0FBQ0EsSUFBSUMsV0FBVyxJQUFmOztBQUVBLElBQUlDLFFBQVFDLElBQVIsS0FBaUIsVUFBckIsRUFBaUM7QUFDL0JDLFNBQU9DLEtBQVAsR0FBZSxFQUFmO0FBQ0FKLGFBQVdELFFBQVEsVUFBUixDQUFYO0FBQ0FGLFFBQU1HLFNBQVNLLE1BQVQsQ0FBZ0JDLFNBQWhCLENBQTBCLGtDQUExQixDQUFOOztBQUVBLE1BQUlULEdBQUosRUFBUztBQUNQRyxhQUFTTyxXQUFULENBQXFCQyxFQUFyQixDQUF3Qix5QkFBeEIsRUFBbUQsTUFBTTtBQUN2RFYsUUFBRSxpQkFBRjs7QUFFQTtBQUNBLFVBQUlXLFFBQVFWLFFBQVEsUUFBUixFQUFrQlcsTUFBOUI7QUFDQSxVQUFJQyxVQUFVQyxPQUFPQyxJQUFQLENBQVlKLEtBQVosRUFBbUJLLE1BQW5CLENBQTBCQyxLQUFLQSxLQUFLLENBQUNBLEVBQUVDLEtBQUYsQ0FBUSxzQ0FBUixDQUFyQyxDQUFkO0FBQ0FMLGNBQVFNLE9BQVIsQ0FBZ0JGLEtBQUs7QUFDbkJqQixVQUFHLGtDQUFpQ2lCLENBQUUsRUFBdEM7QUFDQSxlQUFPTixNQUFNTSxDQUFOLENBQVA7QUFDRCxPQUhEOztBQUtBWixhQUFPQyxLQUFQLENBQWFhLE9BQWIsQ0FBcUJDLE1BQU1BLElBQTNCO0FBQ0QsS0FaRDtBQWFEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O0FBUWUsU0FBU3RCLHdCQUFULENBQWtDdUIsWUFBbEMsRUFBZ0Q7QUFDN0QsTUFBSXRCLEdBQUosRUFBUztBQUNQLFFBQUk7QUFDRkUsY0FBUSxRQUFSLEVBQWtCcUIsU0FBbEIsQ0FBNEJDLEdBQTVCLEdBQWtDO0FBQ2hDQyxnQkFBU0MsRUFBRCxJQUFRcEIsT0FBT0MsS0FBUCxDQUFhb0IsSUFBYixDQUFrQkQsRUFBbEI7QUFEZ0IsT0FBbEM7O0FBSUF4QixjQUFRMEIsSUFBUixDQUFhMUIsT0FBYixDQUFxQix3QkFBckI7QUFDRCxLQU5ELENBTUUsT0FBTzJCLENBQVAsRUFBVTtBQUNWQyxjQUFRQyxLQUFSLENBQWUsZ0dBQStGRixFQUFFRyxPQUFRLEVBQXhIO0FBQ0Q7QUFDRjs7QUFFRGpCLFNBQU9DLElBQVAsQ0FBWU0sYUFBYVcsbUJBQXpCLEVBQThDYixPQUE5QyxDQUF1RGMsUUFBRCxJQUFjO0FBQ2xFLFFBQUlDLE1BQU0sb0JBQVVDLFNBQVYsQ0FBb0JGLFFBQXBCLENBQVY7O0FBRUFoQyxZQUFRbUMsVUFBUixDQUFvQixJQUFHRixHQUFJLEVBQTNCLElBQWdDLENBQUNHLE1BQUQsRUFBU0MsUUFBVCxLQUFzQjtBQUFBLGtDQUN2Q2pCLGFBQWFrQixXQUFiLENBQXlCRCxRQUF6QixDQUR1Qzs7QUFBQSxVQUMvQ0UsSUFEK0MseUJBQy9DQSxJQUQrQzs7O0FBR3BELFVBQUlBLFNBQVMsSUFBYixFQUFtQjtBQUNqQlgsZ0JBQVFDLEtBQVIsQ0FBZSwyQkFBMEJRLFFBQVMsaUZBQWxEO0FBQ0Q7O0FBRURELGFBQU9JLFFBQVAsQ0FBZ0JELElBQWhCLEVBQXNCRixRQUF0QjtBQUNELEtBUkQ7QUFTRCxHQVpEO0FBYUQiLCJmaWxlIjoicmVxdWlyZS1ob29rLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1pbWVUeXBlcyBmcm9tICdAcGF1bGNiZXR0cy9taW1lLXR5cGVzJztcclxuXHJcbmxldCBITVIgPSBmYWxzZTtcclxuXHJcbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOnJlcXVpcmUtaG9vaycpO1xyXG5sZXQgZWxlY3Ryb24gPSBudWxsO1xyXG5cclxuaWYgKHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xyXG4gIHdpbmRvdy5fX2hvdCA9IFtdO1xyXG4gIGVsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcclxuICBITVIgPSBlbGVjdHJvbi5yZW1vdGUuZ2V0R2xvYmFsKCdfX2VsZWN0cm9uX2NvbXBpbGVfaG1yX2VuYWJsZWRfXycpO1xyXG5cclxuICBpZiAoSE1SKSB7XHJcbiAgICBlbGVjdHJvbi5pcGNSZW5kZXJlci5vbignX19lbGVjdHJvbi1jb21waWxlX19ITVInLCAoKSA9PiB7XHJcbiAgICAgIGQoXCJHb3QgSE1SIHNpZ25hbCFcIik7XHJcblxyXG4gICAgICAvLyBSZXNldCB0aGUgbW9kdWxlIGNhY2hlXHJcbiAgICAgIGxldCBjYWNoZSA9IHJlcXVpcmUoJ21vZHVsZScpLl9jYWNoZTtcclxuICAgICAgbGV0IHRvRWplY3QgPSBPYmplY3Qua2V5cyhjYWNoZSkuZmlsdGVyKHggPT4geCAmJiAheC5tYXRjaCgvW1xcXFxcXC9dKG5vZGVfbW9kdWxlc3wuKlxcLmFzYXIpW1xcXFxcXC9dL2kpKTtcclxuICAgICAgdG9FamVjdC5mb3JFYWNoKHggPT4ge1xyXG4gICAgICAgIGQoYFJlbW92aW5nIG5vZGUgbW9kdWxlIGVudHJ5IGZvciAke3h9YCk7XHJcbiAgICAgICAgZGVsZXRlIGNhY2hlW3hdO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHdpbmRvdy5fX2hvdC5mb3JFYWNoKGZuID0+IGZuKCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgdGhlIG5vZGUuanMgaG9vayB0aGF0IGFsbG93cyB1cyB0byBpbnRlcmNlcHQgZmlsZXMgbG9hZGVkIGJ5XHJcbiAqIG5vZGUuanMgYW5kIHJld3JpdGUgdGhlbS4gVGhpcyBtZXRob2QgYWxvbmcgd2l0aCB7QGxpbmsgaW5pdGlhbGl6ZVByb3RvY29sSG9va31cclxuICogYXJlIHRoZSB0b3AtbGV2ZWwgbWV0aG9kcyB0aGF0IGVsZWN0cm9uLWNvbXBpbGUgYWN0dWFsbHkgdXNlcyB0byBpbnRlcmNlcHRcclxuICogY29kZSB0aGF0IEVsZWN0cm9uIGxvYWRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtDb21waWxlckhvc3R9IGNvbXBpbGVySG9zdCAgVGhlIGNvbXBpbGVyIGhvc3QgdG8gdXNlIGZvciBjb21waWxhdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlZ2lzdGVyUmVxdWlyZUV4dGVuc2lvbihjb21waWxlckhvc3QpIHtcclxuICBpZiAoSE1SKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXF1aXJlKCdtb2R1bGUnKS5wcm90b3R5cGUuaG90ID0ge1xyXG4gICAgICAgIGFjY2VwdDogKGNiKSA9PiB3aW5kb3cuX19ob3QucHVzaChjYilcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJlcXVpcmUubWFpbi5yZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyL3BhdGNoJyk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkbid0IHJlcXVpcmUgcmVhY3QtaG90LWxvYWRlci9wYXRjaCwgeW91IG5lZWQgdG8gYWRkIHJlYWN0LWhvdC1sb2FkZXJAMyBhcyBhIGRlcGVuZGVuY3khICR7ZS5tZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgT2JqZWN0LmtleXMoY29tcGlsZXJIb3N0LmNvbXBpbGVyc0J5TWltZVR5cGUpLmZvckVhY2goKG1pbWVUeXBlKSA9PiB7XHJcbiAgICBsZXQgZXh0ID0gbWltZVR5cGVzLmV4dGVuc2lvbihtaW1lVHlwZSk7XHJcblxyXG4gICAgcmVxdWlyZS5leHRlbnNpb25zW2AuJHtleHR9YF0gPSAobW9kdWxlLCBmaWxlbmFtZSkgPT4ge1xyXG4gICAgICBsZXQge2NvZGV9ID0gY29tcGlsZXJIb3N0LmNvbXBpbGVTeW5jKGZpbGVuYW1lKTtcclxuXHJcbiAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgbnVsbCBjb2RlIHJldHVybmVkIGZvciBcIiR7ZmlsZW5hbWV9XCIuICBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgb24gJ2VsZWN0cm9uLWNvbXBpbGUnIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZS5gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbW9kdWxlLl9jb21waWxlKGNvZGUsIGZpbGVuYW1lKTtcclxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuIl19","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/protocol-hook.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rigHtmlDocumentToInitializeElectronCompile = rigHtmlDocumentToInitializeElectronCompile;\nexports.addBypassChecker = addBypassChecker;\nexports.initializeProtocolHook = initializeProtocolHook;\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _mimeTypes = require('@paulcbetts/mime-types');\n\nvar _mimeTypes2 = _interopRequireDefault(_mimeTypes);\n\nvar _lruCache = require('lru-cache');\n\nvar _lruCache2 = _interopRequireDefault(_lruCache);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst magicWords = \"__magic__file__to__help__electron__compile.js\";\n\n// NB: These are duped in initialize-renderer so we can save startup time, make\n// sure to run both!\nconst magicGlobalForRootCacheDir = '__electron_compile_root_cache_dir';\nconst magicGlobalForAppRootDir = '__electron_compile_app_root_dir';\n\nconst d = require('debug')('electron-compile:protocol-hook');\n\nlet protocol = null;\n\nconst mapStatCache = new _lruCache2.default({ length: 512 });\nfunction doesMapFileExist(filePath) {\n  let ret = mapStatCache.get(filePath);\n  if (ret !== undefined) return Promise.resolve(ret);\n\n  return new Promise(res => {\n    _fs2.default.lstat(filePath, (err, s) => {\n      let failed = err || !s;\n\n      mapStatCache.set(filePath, !failed);\n      res(!failed);\n    });\n  });\n}\n\n/**\r\n * Adds our script header to the top of all HTML files\r\n *\r\n * @private\r\n */\nfunction rigHtmlDocumentToInitializeElectronCompile(doc) {\n  let lines = doc.split(\"\\n\");\n  let replacement = `<head><script src=\"${magicWords}\"></script>`;\n  let replacedHead = false;\n\n  for (let i = 0; i < lines.length; i++) {\n    if (!lines[i].match(/<head>/i)) continue;\n\n    lines[i] = lines[i].replace(/<head>/i, replacement);\n    replacedHead = true;\n    break;\n  }\n\n  if (!replacedHead) {\n    replacement = `<html$1><head><script src=\"${magicWords}\"></script></head>`;\n    for (let i = 0; i < lines.length; i++) {\n      if (!lines[i].match(/<html/i)) continue;\n\n      lines[i] = lines[i].replace(/<html([^>]+)>/i, replacement);\n      break;\n    }\n  }\n\n  return lines.join(\"\\n\");\n}\n\nfunction requestFileJob(filePath, finish) {\n  _fs2.default.readFile(filePath, (err, buf) => {\n    if (err) {\n      if (err.errno === 34) {\n        finish(-6); // net::ERR_FILE_NOT_FOUND\n        return;\n      } else {\n        finish(-2); // net::FAILED\n        return;\n      }\n    }\n\n    finish({\n      data: buf,\n      mimeType: _mimeTypes2.default.lookup(filePath) || 'text/plain'\n    });\n  });\n}\n\nconst bypassCheckers = [];\n\n/**\r\n * Adds a function that will be called on electron-compile's protocol hook\r\n * used to intercept file requests.  Use this to bypass electron-compile\r\n * entirely for certain URI's.\r\n * \r\n * @param {Function} bypassChecker Function that will be called with the file path to determine whether to bypass or not\r\n */\nfunction addBypassChecker(bypassChecker) {\n  bypassCheckers.push(bypassChecker);\n}\n\n/**\r\n * Initializes the protocol hook on file: that allows us to intercept files\r\n * loaded by Chromium and rewrite them. This method along with\r\n * {@link registerRequireExtension} are the top-level methods that electron-compile\r\n * actually uses to intercept code that Electron loads.\r\n *\r\n * @param  {CompilerHost} compilerHost  The compiler host to use for compilation.\r\n */\nfunction initializeProtocolHook(compilerHost) {\n  protocol = protocol || require('electron').protocol;\n\n  global[magicGlobalForRootCacheDir] = compilerHost.rootCacheDir;\n  global[magicGlobalForAppRootDir] = compilerHost.appRoot;\n\n  const electronCompileSetupCode = `if (window.require) require('electron-compile/lib/initialize-renderer').initializeRendererProcess(${compilerHost.readOnlyMode});`;\n\n  protocol.interceptBufferProtocol('file', (() => {\n    var _ref = _asyncToGenerator(function* (request, finish) {\n      let uri = _url2.default.parse(request.url);\n\n      d(`Intercepting url ${request.url}`);\n      if (request.url.indexOf(magicWords) > -1) {\n        finish({\n          mimeType: 'application/javascript',\n          data: new Buffer(electronCompileSetupCode, 'utf8')\n        });\n\n        return;\n      }\n\n      // This is a protocol-relative URL that has gone pear-shaped in Electron,\n      // let's rewrite it\n      if (uri.host && uri.host.length > 1) {\n        //let newUri = request.url.replace(/^file:/, \"https:\");\n        // TODO: Jump off this bridge later\n        d(`TODO: Found bogus protocol-relative URL, can't fix it up!!`);\n        finish(-2);\n        return;\n      }\n\n      let filePath = decodeURIComponent(uri.pathname);\n\n      // NB: pathname has a leading '/' on Win32 for some reason\n      if (process.platform === 'win32') {\n        filePath = filePath.slice(1);\n      }\n\n      // NB: Special-case files coming from atom.asar or node_modules\n      if (filePath.match(/[\\/\\\\](atom|electron).asar/) || filePath.match(/[\\/\\\\](node_modules|bower_components)/)) {\n        // NBs on NBs: If we're loading an HTML file from node_modules, we still have\n        // to do the HTML document rigging\n        if (filePath.match(/\\.html?$/i)) {\n          let riggedContents = null;\n          _fs2.default.readFile(filePath, 'utf8', function (err, contents) {\n            if (err) {\n              if (err.errno === 34) {\n                finish(-6); // net::ERR_FILE_NOT_FOUND\n                return;\n              } else {\n                finish(-2); // net::FAILED\n                return;\n              }\n            }\n\n            riggedContents = rigHtmlDocumentToInitializeElectronCompile(contents);\n            finish({ data: new Buffer(riggedContents), mimeType: 'text/html' });\n            return;\n          });\n\n          return;\n        }\n\n        requestFileJob(filePath, finish);\n        return;\n      }\n\n      // NB: Chromium will somehow decide that external source map references\n      // aren't relative to the file that was loaded for node.js modules, but\n      // relative to the HTML file. Since we can't really figure out what the\n      // real path is, we just need to squelch it.\n      if (filePath.match(/\\.map$/i) && !(yield doesMapFileExist(filePath))) {\n        finish({ data: new Buffer(\"\", 'utf8'), mimeType: 'text/plain' });\n        return;\n      }\n\n      for (const bypassChecker of bypassCheckers) {\n        if (bypassChecker(filePath)) {\n          d('bypassing compilers for:', filePath);\n          requestFileJob(filePath, finish);\n          return;\n        }\n      }\n\n      try {\n        let result = yield compilerHost.compile(filePath);\n\n        if (result.mimeType === 'text/html') {\n          result.code = rigHtmlDocumentToInitializeElectronCompile(result.code);\n        }\n\n        if (result.binaryData || result.code instanceof Buffer) {\n          finish({ data: result.binaryData || result.code, mimeType: result.mimeType });\n          return;\n        } else {\n          finish({ data: new Buffer(result.code), mimeType: result.mimeType });\n          return;\n        }\n      } catch (e) {\n        let err = `Failed to compile ${filePath}: ${e.message}\\n${e.stack}`;\n        d(err);\n\n        if (e.errno === 34 /*ENOENT*/) {\n            finish(-6); // net::ERR_FILE_NOT_FOUND\n            return;\n          }\n\n        finish({ mimeType: 'text/plain', data: new Buffer(err) });\n        return;\n      }\n    });\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  })());\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm90b2NvbC1ob29rLmpzIl0sIm5hbWVzIjpbInJpZ0h0bWxEb2N1bWVudFRvSW5pdGlhbGl6ZUVsZWN0cm9uQ29tcGlsZSIsImFkZEJ5cGFzc0NoZWNrZXIiLCJpbml0aWFsaXplUHJvdG9jb2xIb29rIiwibWFnaWNXb3JkcyIsIm1hZ2ljR2xvYmFsRm9yUm9vdENhY2hlRGlyIiwibWFnaWNHbG9iYWxGb3JBcHBSb290RGlyIiwiZCIsInJlcXVpcmUiLCJwcm90b2NvbCIsIm1hcFN0YXRDYWNoZSIsImxlbmd0aCIsImRvZXNNYXBGaWxlRXhpc3QiLCJmaWxlUGF0aCIsInJldCIsImdldCIsInVuZGVmaW5lZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzIiwibHN0YXQiLCJlcnIiLCJzIiwiZmFpbGVkIiwic2V0IiwiZG9jIiwibGluZXMiLCJzcGxpdCIsInJlcGxhY2VtZW50IiwicmVwbGFjZWRIZWFkIiwiaSIsIm1hdGNoIiwicmVwbGFjZSIsImpvaW4iLCJyZXF1ZXN0RmlsZUpvYiIsImZpbmlzaCIsInJlYWRGaWxlIiwiYnVmIiwiZXJybm8iLCJkYXRhIiwibWltZVR5cGUiLCJsb29rdXAiLCJieXBhc3NDaGVja2VycyIsImJ5cGFzc0NoZWNrZXIiLCJwdXNoIiwiY29tcGlsZXJIb3N0IiwiZ2xvYmFsIiwicm9vdENhY2hlRGlyIiwiYXBwUm9vdCIsImVsZWN0cm9uQ29tcGlsZVNldHVwQ29kZSIsInJlYWRPbmx5TW9kZSIsImludGVyY2VwdEJ1ZmZlclByb3RvY29sIiwicmVxdWVzdCIsInVyaSIsInBhcnNlIiwidXJsIiwiaW5kZXhPZiIsIkJ1ZmZlciIsImhvc3QiLCJkZWNvZGVVUklDb21wb25lbnQiLCJwYXRobmFtZSIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsInNsaWNlIiwicmlnZ2VkQ29udGVudHMiLCJjb250ZW50cyIsInJlc3VsdCIsImNvbXBpbGUiLCJjb2RlIiwiYmluYXJ5RGF0YSIsImUiLCJtZXNzYWdlIiwic3RhY2si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anMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdXJsIGZyb20gJ3VybCc7XHJcbmltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCBtaW1lIGZyb20gJ0BwYXVsY2JldHRzL21pbWUtdHlwZXMnO1xyXG5pbXBvcnQgTFJVIGZyb20gJ2xydS1jYWNoZSc7XHJcblxyXG5jb25zdCBtYWdpY1dvcmRzID0gXCJfX21hZ2ljX19maWxlX190b19faGVscF9fZWxlY3Ryb25fX2NvbXBpbGUuanNcIjtcclxuXHJcbi8vIE5COiBUaGVzZSBhcmUgZHVwZWQgaW4gaW5pdGlhbGl6ZS1yZW5kZXJlciBzbyB3ZSBjYW4gc2F2ZSBzdGFydHVwIHRpbWUsIG1ha2VcclxuLy8gc3VyZSB0byBydW4gYm90aCFcclxuY29uc3QgbWFnaWNHbG9iYWxGb3JSb290Q2FjaGVEaXIgPSAnX19lbGVjdHJvbl9jb21waWxlX3Jvb3RfY2FjaGVfZGlyJztcclxuY29uc3QgbWFnaWNHbG9iYWxGb3JBcHBSb290RGlyID0gJ19fZWxlY3Ryb25fY29tcGlsZV9hcHBfcm9vdF9kaXInO1xyXG5cclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6cHJvdG9jb2wtaG9vaycpO1xyXG5cclxubGV0IHByb3RvY29sID0gbnVsbDtcclxuXHJcbmNvbnN0IG1hcFN0YXRDYWNoZSA9IG5ldyBMUlUoe2xlbmd0aDogNTEyfSk7XHJcbmZ1bmN0aW9uIGRvZXNNYXBGaWxlRXhpc3QoZmlsZVBhdGgpIHtcclxuICBsZXQgcmV0ID0gbWFwU3RhdENhY2hlLmdldChmaWxlUGF0aCk7XHJcbiAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJldCk7XHJcblxyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XHJcbiAgICBmcy5sc3RhdChmaWxlUGF0aCwgKGVyciwgcykgPT4ge1xyXG4gICAgICBsZXQgZmFpbGVkID0gKGVyciB8fCAhcyk7XHJcblxyXG4gICAgICBtYXBTdGF0Q2FjaGUuc2V0KGZpbGVQYXRoLCAhZmFpbGVkKTtcclxuICAgICAgcmVzKCFmYWlsZWQpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIG91ciBzY3JpcHQgaGVhZGVyIHRvIHRoZSB0b3Agb2YgYWxsIEhUTUwgZmlsZXNcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByaWdIdG1sRG9jdW1lbnRUb0luaXRpYWxpemVFbGVjdHJvbkNvbXBpbGUoZG9jKSB7XHJcbiAgbGV0IGxpbmVzID0gZG9jLnNwbGl0KFwiXFxuXCIpO1xyXG4gIGxldCByZXBsYWNlbWVudCA9IGA8aGVhZD48c2NyaXB0IHNyYz1cIiR7bWFnaWNXb3Jkc31cIj48L3NjcmlwdD5gO1xyXG4gIGxldCByZXBsYWNlZEhlYWQgPSBmYWxzZTtcclxuXHJcbiAgZm9yIChsZXQgaT0wOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICghbGluZXNbaV0ubWF0Y2goLzxoZWFkPi9pKSkgY29udGludWU7XHJcblxyXG4gICAgbGluZXNbaV0gPSAobGluZXNbaV0pLnJlcGxhY2UoLzxoZWFkPi9pLCByZXBsYWNlbWVudCk7XHJcbiAgICByZXBsYWNlZEhlYWQgPSB0cnVlO1xyXG4gICAgYnJlYWs7XHJcbiAgfVxyXG5cclxuICBpZiAoIXJlcGxhY2VkSGVhZCkge1xyXG4gICAgcmVwbGFjZW1lbnQgPSBgPGh0bWwkMT48aGVhZD48c2NyaXB0IHNyYz1cIiR7bWFnaWNXb3Jkc31cIj48L3NjcmlwdD48L2hlYWQ+YDtcclxuICAgIGZvciAobGV0IGk9MDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICghbGluZXNbaV0ubWF0Y2goLzxodG1sL2kpKSBjb250aW51ZTtcclxuXHJcbiAgICAgIGxpbmVzW2ldID0gKGxpbmVzW2ldKS5yZXBsYWNlKC88aHRtbChbXj5dKyk+L2ksIHJlcGxhY2VtZW50KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGluZXMuam9pbihcIlxcblwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdWVzdEZpbGVKb2IoZmlsZVBhdGgsIGZpbmlzaCkge1xyXG4gIGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAoZXJyLCBidWYpID0+IHtcclxuICAgIGlmIChlcnIpIHtcclxuICAgICAgaWYgKGVyci5lcnJubyA9PT0gMzQpIHtcclxuICAgICAgICBmaW5pc2goLTYpOyAvLyBuZXQ6OkVSUl9GSUxFX05PVF9GT1VORFxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmaW5pc2goLTIpOyAvLyBuZXQ6OkZBSUxFRFxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZpbmlzaCh7XHJcbiAgICAgIGRhdGE6IGJ1ZixcclxuICAgICAgbWltZVR5cGU6IG1pbWUubG9va3VwKGZpbGVQYXRoKSB8fCAndGV4dC9wbGFpbidcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5jb25zdCBieXBhc3NDaGVja2VycyA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uIGVsZWN0cm9uLWNvbXBpbGUncyBwcm90b2NvbCBob29rXHJcbiAqIHVzZWQgdG8gaW50ZXJjZXB0IGZpbGUgcmVxdWVzdHMuICBVc2UgdGhpcyB0byBieXBhc3MgZWxlY3Ryb24tY29tcGlsZVxyXG4gKiBlbnRpcmVseSBmb3IgY2VydGFpbiBVUkkncy5cclxuICogXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJ5cGFzc0NoZWNrZXIgRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBmaWxlIHBhdGggdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gYnlwYXNzIG9yIG5vdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJ5cGFzc0NoZWNrZXIoYnlwYXNzQ2hlY2tlcikge1xyXG4gIGJ5cGFzc0NoZWNrZXJzLnB1c2goYnlwYXNzQ2hlY2tlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyB0aGUgcHJvdG9jb2wgaG9vayBvbiBmaWxlOiB0aGF0IGFsbG93cyB1cyB0byBpbnRlcmNlcHQgZmlsZXNcclxuICogbG9hZGVkIGJ5IENocm9taXVtIGFuZCByZXdyaXRlIHRoZW0uIFRoaXMgbWV0aG9kIGFsb25nIHdpdGhcclxuICoge0BsaW5rIHJlZ2lzdGVyUmVxdWlyZUV4dGVuc2lvbn0gYXJlIHRoZSB0b3AtbGV2ZWwgbWV0aG9kcyB0aGF0IGVsZWN0cm9uLWNvbXBpbGVcclxuICogYWN0dWFsbHkgdXNlcyB0byBpbnRlcmNlcHQgY29kZSB0aGF0IEVsZWN0cm9uIGxvYWRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtDb21waWxlckhvc3R9IGNvbXBpbGVySG9zdCAgVGhlIGNvbXBpbGVyIGhvc3QgdG8gdXNlIGZvciBjb21waWxhdGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplUHJvdG9jb2xIb29rKGNvbXBpbGVySG9zdCkge1xyXG4gIHByb3RvY29sID0gcHJvdG9jb2wgfHwgcmVxdWlyZSgnZWxlY3Ryb24nKS5wcm90b2NvbDtcclxuXHJcbiAgZ2xvYmFsW21hZ2ljR2xvYmFsRm9yUm9vdENhY2hlRGlyXSA9IGNvbXBpbGVySG9zdC5yb290Q2FjaGVEaXI7XHJcbiAgZ2xvYmFsW21hZ2ljR2xvYmFsRm9yQXBwUm9vdERpcl0gPSBjb21waWxlckhvc3QuYXBwUm9vdDtcclxuXHJcbiAgY29uc3QgZWxlY3Ryb25Db21waWxlU2V0dXBDb2RlID0gYGlmICh3aW5kb3cucmVxdWlyZSkgcmVxdWlyZSgnZWxlY3Ryb24tY29tcGlsZS9saWIvaW5pdGlhbGl6ZS1yZW5kZXJlcicpLmluaXRpYWxpemVSZW5kZXJlclByb2Nlc3MoJHtjb21waWxlckhvc3QucmVhZE9ubHlNb2RlfSk7YDtcclxuXHJcbiAgcHJvdG9jb2wuaW50ZXJjZXB0QnVmZmVyUHJvdG9jb2woJ2ZpbGUnLCBhc3luYyBmdW5jdGlvbihyZXF1ZXN0LCBmaW5pc2gpIHtcclxuICAgIGxldCB1cmkgPSB1cmwucGFyc2UocmVxdWVzdC51cmwpO1xyXG5cclxuICAgIGQoYEludGVyY2VwdGluZyB1cmwgJHtyZXF1ZXN0LnVybH1gKTtcclxuICAgIGlmIChyZXF1ZXN0LnVybC5pbmRleE9mKG1hZ2ljV29yZHMpID4gLTEpIHtcclxuICAgICAgZmluaXNoKHtcclxuICAgICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxyXG4gICAgICAgIGRhdGE6IG5ldyBCdWZmZXIoZWxlY3Ryb25Db21waWxlU2V0dXBDb2RlLCAndXRmOCcpXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoaXMgaXMgYSBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgdGhhdCBoYXMgZ29uZSBwZWFyLXNoYXBlZCBpbiBFbGVjdHJvbixcclxuICAgIC8vIGxldCdzIHJld3JpdGUgaXRcclxuICAgIGlmICh1cmkuaG9zdCAmJiB1cmkuaG9zdC5sZW5ndGggPiAxKSB7XHJcbiAgICAgIC8vbGV0IG5ld1VyaSA9IHJlcXVlc3QudXJsLnJlcGxhY2UoL15maWxlOi8sIFwiaHR0cHM6XCIpO1xyXG4gICAgICAvLyBUT0RPOiBKdW1wIG9mZiB0aGlzIGJyaWRnZSBsYXRlclxyXG4gICAgICBkKGBUT0RPOiBGb3VuZCBib2d1cyBwcm90b2NvbC1yZWxhdGl2ZSBVUkwsIGNhbid0IGZpeCBpdCB1cCEhYCk7XHJcbiAgICAgIGZpbmlzaCgtMik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZmlsZVBhdGggPSBkZWNvZGVVUklDb21wb25lbnQodXJpLnBhdGhuYW1lKTtcclxuXHJcbiAgICAvLyBOQjogcGF0aG5hbWUgaGFzIGEgbGVhZGluZyAnLycgb24gV2luMzIgZm9yIHNvbWUgcmVhc29uXHJcbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xyXG4gICAgICBmaWxlUGF0aCA9IGZpbGVQYXRoLnNsaWNlKDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5COiBTcGVjaWFsLWNhc2UgZmlsZXMgY29taW5nIGZyb20gYXRvbS5hc2FyIG9yIG5vZGVfbW9kdWxlc1xyXG4gICAgaWYgKGZpbGVQYXRoLm1hdGNoKC9bXFwvXFxcXF0oYXRvbXxlbGVjdHJvbikuYXNhci8pIHx8IGZpbGVQYXRoLm1hdGNoKC9bXFwvXFxcXF0obm9kZV9tb2R1bGVzfGJvd2VyX2NvbXBvbmVudHMpLykpIHtcclxuICAgICAgLy8gTkJzIG9uIE5CczogSWYgd2UncmUgbG9hZGluZyBhbiBIVE1MIGZpbGUgZnJvbSBub2RlX21vZHVsZXMsIHdlIHN0aWxsIGhhdmVcclxuICAgICAgLy8gdG8gZG8gdGhlIEhUTUwgZG9jdW1lbnQgcmlnZ2luZ1xyXG4gICAgICBpZiAoZmlsZVBhdGgubWF0Y2goL1xcLmh0bWw/JC9pKSkge1xyXG4gICAgICAgIGxldCByaWdnZWRDb250ZW50cyA9IG51bGw7XHJcbiAgICAgICAgZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4JywgKGVyciwgY29udGVudHMpID0+IHtcclxuICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKGVyci5lcnJubyA9PT0gMzQpIHtcclxuICAgICAgICAgICAgICBmaW5pc2goLTYpOyAvLyBuZXQ6OkVSUl9GSUxFX05PVF9GT1VORFxyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBmaW5pc2goLTIpOyAvLyBuZXQ6OkZBSUxFRFxyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJpZ2dlZENvbnRlbnRzID0gcmlnSHRtbERvY3VtZW50VG9Jbml0aWFsaXplRWxlY3Ryb25Db21waWxlKGNvbnRlbnRzKTtcclxuICAgICAgICAgIGZpbmlzaCh7IGRhdGE6IG5ldyBCdWZmZXIocmlnZ2VkQ29udGVudHMpLCBtaW1lVHlwZTogJ3RleHQvaHRtbCcgfSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVxdWVzdEZpbGVKb2IoZmlsZVBhdGgsIGZpbmlzaCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOQjogQ2hyb21pdW0gd2lsbCBzb21laG93IGRlY2lkZSB0aGF0IGV4dGVybmFsIHNvdXJjZSBtYXAgcmVmZXJlbmNlc1xyXG4gICAgLy8gYXJlbid0IHJlbGF0aXZlIHRvIHRoZSBmaWxlIHRoYXQgd2FzIGxvYWRlZCBmb3Igbm9kZS5qcyBtb2R1bGVzLCBidXRcclxuICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBIVE1MIGZpbGUuIFNpbmNlIHdlIGNhbid0IHJlYWxseSBmaWd1cmUgb3V0IHdoYXQgdGhlXHJcbiAgICAvLyByZWFsIHBhdGggaXMsIHdlIGp1c3QgbmVlZCB0byBzcXVlbGNoIGl0LlxyXG4gICAgaWYgKGZpbGVQYXRoLm1hdGNoKC9cXC5tYXAkL2kpICYmICEoYXdhaXQgZG9lc01hcEZpbGVFeGlzdChmaWxlUGF0aCkpKSB7XHJcbiAgICAgIGZpbmlzaCh7IGRhdGE6IG5ldyBCdWZmZXIoXCJcIiwgJ3V0ZjgnKSwgbWltZVR5cGU6ICd0ZXh0L3BsYWluJyB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3QgYnlwYXNzQ2hlY2tlciBvZiBieXBhc3NDaGVja2Vycykge1xyXG4gICAgICBpZiAoYnlwYXNzQ2hlY2tlcihmaWxlUGF0aCkpIHtcclxuICAgICAgICBkKCdieXBhc3NpbmcgY29tcGlsZXJzIGZvcjonLCBmaWxlUGF0aCk7XHJcbiAgICAgICAgcmVxdWVzdEZpbGVKb2IoZmlsZVBhdGgsIGZpbmlzaCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVySG9zdC5jb21waWxlKGZpbGVQYXRoKTtcclxuXHJcbiAgICAgIGlmIChyZXN1bHQubWltZVR5cGUgPT09ICd0ZXh0L2h0bWwnKSB7XHJcbiAgICAgICAgcmVzdWx0LmNvZGUgPSByaWdIdG1sRG9jdW1lbnRUb0luaXRpYWxpemVFbGVjdHJvbkNvbXBpbGUocmVzdWx0LmNvZGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVzdWx0LmJpbmFyeURhdGEgfHwgcmVzdWx0LmNvZGUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcclxuICAgICAgICBmaW5pc2goeyBkYXRhOiByZXN1bHQuYmluYXJ5RGF0YSB8fCByZXN1bHQuY29kZSwgbWltZVR5cGU6IHJlc3VsdC5taW1lVHlwZSB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmluaXNoKHsgZGF0YTogbmV3IEJ1ZmZlcihyZXN1bHQuY29kZSksIG1pbWVUeXBlOiByZXN1bHQubWltZVR5cGUgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGxldCBlcnIgPSBgRmFpbGVkIHRvIGNvbXBpbGUgJHtmaWxlUGF0aH06ICR7ZS5tZXNzYWdlfVxcbiR7ZS5zdGFja31gO1xyXG4gICAgICBkKGVycik7XHJcblxyXG4gICAgICBpZiAoZS5lcnJubyA9PT0gMzQgLypFTk9FTlQqLykge1xyXG4gICAgICAgIGZpbmlzaCgtNik7IC8vIG5ldDo6RVJSX0ZJTEVfTk9UX0ZPVU5EXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmaW5pc2goeyBtaW1lVHlwZTogJ3RleHQvcGxhaW4nLCBkYXRhOiBuZXcgQnVmZmVyKGVycikgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG4iXX0=","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/cli.js":"#!/usr/bin/env node\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.main = undefined;\n\nlet main = exports.main = (() => {\n  var _ref = _asyncToGenerator(function* (appDir, sourceDirs, cacheDir, sourceMapDir) {\n    let compilerHost = null;\n    if (!cacheDir || cacheDir.length < 1) {\n      cacheDir = '.cache';\n    }\n\n    let rootCacheDir = _path2.default.join(appDir, cacheDir);\n    _mkdirp2.default.sync(rootCacheDir);\n    let mapDir = rootCacheDir;\n\n    if (sourceMapDir) {\n      mapDir = _path2.default.join(appDir, sourceMapDir);\n      d(`specifed separate source map dir at ${mapDir}, creating it`);\n      _mkdirp2.default.sync(mapDir);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(`Using NODE_ENV = ${process.env.NODE_ENV || 'development'}`);\n    }\n\n    d(`main: ${appDir}, ${JSON.stringify(sourceDirs)}`);\n    try {\n      compilerHost = yield (0, _configParser.createCompilerHostFromProjectRoot)(appDir, rootCacheDir, sourceMapDir);\n    } catch (e) {\n      console.error(`Couldn't set up compilers: ${e.message}`);\n      d(e.stack);\n\n      throw e;\n    }\n\n    yield Promise.all(sourceDirs.map(function (dir) {\n      return (0, _forAllFiles.forAllFiles)(dir, (() => {\n        var _ref2 = _asyncToGenerator(function* (f) {\n          try {\n            d(`Starting compilation for ${f}`);\n            yield compilerHost.compile(f);\n          } catch (e) {\n            console.error(`Failed to compile file: ${f}`);\n            console.error(e.message);\n\n            d(e.stack);\n          }\n        });\n\n        return function (_x5) {\n          return _ref2.apply(this, arguments);\n        };\n      })());\n    }));\n\n    d('Saving out configuration');\n    yield compilerHost.saveConfiguration();\n  });\n\n  return function main(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _mkdirp = require('mkdirp');\n\nvar _mkdirp2 = _interopRequireDefault(_mkdirp);\n\nvar _configParser = require('./config-parser');\n\nvar _forAllFiles = require('./for-all-files');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nprocess.on('unhandledRejection', e => {\n  d(e.message || e);\n  d(e.stack || '');\n});\n\nprocess.on('uncaughtException', e => {\n  d(e.message || e);\n  d(e.stack || '');\n});\n\nconst d = require('debug')('electron-compile');\n\nconst yargs = require('yargs').usage('Usage: electron-compile --appdir [root-app-dir] paths...').alias('a', 'appdir').describe('a', 'The top-level application directory (i.e. where your package.json is)').default('a', process.cwd()).alias('c', 'cachedir').describe('c', 'The directory to put the cache').alias('s', 'sourcemapdir').describe('s', 'The directory to store sourcemap if compiler configured to have sourcemap file. Default to cachedir if not specified.').help('h').alias('h', 'help').epilog('Copyright 2015');\n\nif (process.mainModule === module) {\n  const argv = yargs.argv;\n\n  if (!argv._ || argv._.length < 1) {\n    yargs.showHelp();\n    process.exit(-1);\n  }\n\n  const sourceDirs = argv._;\n  const appDir = argv.a;\n  const cacheDir = argv.c;\n  const sourceMapDir = argv.s;\n\n  main(appDir, sourceDirs, cacheDir, sourceMapDir).then(() => process.exit(0)).catch(e => {\n    console.error(e.message || e);\n    d(e.stack);\n\n    console.error(\"Compilation failed!\\nFor extra information, set the DEBUG environment variable to '*'\");\n    process.exit(-1);\n  });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGkuanMiXSwibmFtZXMiOlsiYXBwRGlyIiwic291cmNlRGlycyIsImNhY2hlRGlyIiwic291cmNlTWFwRGlyIiwiY29tcGlsZXJIb3N0IiwibGVuZ3RoIiwicm9vdENhY2hlRGlyIiwiam9pbiIsInN5bmMiLCJtYXBEaXIiLCJkIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29uc29sZSIsImxvZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiZGlyIiwiZiIsImNvbXBpbGUiLCJzYXZlQ29uZmlndXJhdGlvbiIsIm1haW4iLCJvbiIsInJlcXVpcmUiLCJ5YXJncyIsInVzYWdlIiwiYWxpYXMiLCJkZXNjcmliZSIsImRlZmF1bHQiLCJjd2QiLCJoZWxwIiwiZXBpbG9nIiwibWFpbk1vZHVsZSIsIm1vZHVsZSIsImFyZ3YiLCJfIiwic2hvd0hlbHAiLCJleGl0IiwiYSIsImMiLCJzIiwidGhlbiIsImNhdGNoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OzsrQkFrQk8sV0FBb0JBLE1BQXBCLEVBQTRCQyxVQUE1QixFQUF3Q0MsUUFBeEMsRUFBa0RDLFlBQWxELEVBQWdFO0FBQ3JFLFFBQUlDLGVBQWUsSUFBbkI7QUFDQSxRQUFJLENBQUNGLFFBQUQsSUFBYUEsU0FBU0csTUFBVCxHQUFrQixDQUFuQyxFQUFzQztBQUNwQ0gsaUJBQVcsUUFBWDtBQUNEOztBQUVELFFBQUlJLGVBQWUsZUFBS0MsSUFBTCxDQUFVUCxNQUFWLEVBQWtCRSxRQUFsQixDQUFuQjtBQUNBLHFCQUFPTSxJQUFQLENBQVlGLFlBQVo7QUFDQSxRQUFJRyxTQUFTSCxZQUFiOztBQUVBLFFBQUlILFlBQUosRUFBa0I7QUFDaEJNLGVBQVMsZUFBS0YsSUFBTCxDQUFVUCxNQUFWLEVBQWtCRyxZQUFsQixDQUFUO0FBQ0FPLFFBQUcsdUNBQXNDRCxNQUFPLGVBQWhEO0FBQ0EsdUJBQU9ELElBQVAsQ0FBWUMsTUFBWjtBQUNEOztBQUVELFFBQUlFLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q0MsY0FBUUMsR0FBUixDQUFhLG9CQUFtQkosUUFBUUMsR0FBUixDQUFZQyxRQUFaLElBQXdCLGFBQWMsRUFBdEU7QUFDRDs7QUFFREgsTUFBRyxTQUFRVixNQUFPLEtBQUlnQixLQUFLQyxTQUFMLENBQWVoQixVQUFmLENBQTJCLEVBQWpEO0FBQ0EsUUFBSTtBQUNGRyxxQkFBZSxNQUFNLHFEQUFrQ0osTUFBbEMsRUFBMENNLFlBQTFDLEVBQXdESCxZQUF4RCxDQUFyQjtBQUNELEtBRkQsQ0FFRSxPQUFPZSxDQUFQLEVBQVU7QUFDVkosY0FBUUssS0FBUixDQUFlLDhCQUE2QkQsRUFBRUUsT0FBUSxFQUF0RDtBQUNBVixRQUFFUSxFQUFFRyxLQUFKOztBQUVBLFlBQU1ILENBQU47QUFDRDs7QUFFRCxVQUFNSSxRQUFRQyxHQUFSLENBQVl0QixXQUFXdUIsR0FBWCxDQUFlLFVBQUNDLEdBQUQ7QUFBQSxhQUFTLDhCQUFZQSxHQUFaO0FBQUEsc0NBQWlCLFdBQU9DLENBQVAsRUFBYTtBQUN0RSxjQUFJO0FBQ0ZoQixjQUFHLDRCQUEyQmdCLENBQUUsRUFBaEM7QUFDQSxrQkFBTXRCLGFBQWF1QixPQUFiLENBQXFCRCxDQUFyQixDQUFOO0FBQ0QsV0FIRCxDQUdFLE9BQU9SLENBQVAsRUFBVTtBQUNWSixvQkFBUUssS0FBUixDQUFlLDJCQUEwQk8sQ0FBRSxFQUEzQztBQUNBWixvQkFBUUssS0FBUixDQUFjRCxFQUFFRSxPQUFoQjs7QUFFQVYsY0FBRVEsRUFBRUcsS0FBSjtBQUNEO0FBQ0YsU0FWeUM7O0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBVDtBQUFBLEtBQWYsQ0FBWixDQUFOOztBQVlBWCxNQUFFLDBCQUFGO0FBQ0EsVUFBTU4sYUFBYXdCLGlCQUFiLEVBQU47QUFDRCxHOztrQkE1Q3FCQyxJOzs7OztBQWhCdEI7Ozs7QUFDQTs7OztBQUVBOztBQUNBOzs7Ozs7QUFFQWxCLFFBQVFtQixFQUFSLENBQVcsb0JBQVgsRUFBa0NaLENBQUQsSUFBTztBQUN0Q1IsSUFBRVEsRUFBRUUsT0FBRixJQUFhRixDQUFmO0FBQ0FSLElBQUVRLEVBQUVHLEtBQUYsSUFBVyxFQUFiO0FBQ0QsQ0FIRDs7QUFLQVYsUUFBUW1CLEVBQVIsQ0FBVyxtQkFBWCxFQUFpQ1osQ0FBRCxJQUFPO0FBQ3JDUixJQUFFUSxFQUFFRSxPQUFGLElBQWFGLENBQWY7QUFDQVIsSUFBRVEsRUFBRUcsS0FBRixJQUFXLEVBQWI7QUFDRCxDQUhEOztBQW1EQSxNQUFNWCxJQUFJcUIsUUFBUSxPQUFSLEVBQWlCLGtCQUFqQixDQUFWOztBQUVBLE1BQU1DLFFBQVFELFFBQVEsT0FBUixFQUNYRSxLQURXLENBQ0wsMERBREssRUFFWEMsS0FGVyxDQUVMLEdBRkssRUFFQSxRQUZBLEVBR1hDLFFBSFcsQ0FHRixHQUhFLEVBR0csdUVBSEgsRUFJWEMsT0FKVyxDQUlILEdBSkcsRUFJRXpCLFFBQVEwQixHQUFSLEVBSkYsRUFLWEgsS0FMVyxDQUtMLEdBTEssRUFLQSxVQUxBLEVBTVhDLFFBTlcsQ0FNRixHQU5FLEVBTUcsZ0NBTkgsRUFPWEQsS0FQVyxDQU9MLEdBUEssRUFPQSxjQVBBLEVBUVhDLFFBUlcsQ0FRRixHQVJFLEVBUUcsdUhBUkgsRUFTWEcsSUFUVyxDQVNOLEdBVE0sRUFVWEosS0FWVyxDQVVMLEdBVkssRUFVQSxNQVZBLEVBV1hLLE1BWFcsQ0FXSixnQkFYSSxDQUFkOztBQWFBLElBQUk1QixRQUFRNkIsVUFBUixLQUF1QkMsTUFBM0IsRUFBbUM7QUFDakMsUUFBTUMsT0FBT1YsTUFBTVUsSUFBbkI7O0FBRUEsTUFBSSxDQUFDQSxLQUFLQyxDQUFOLElBQVdELEtBQUtDLENBQUwsQ0FBT3RDLE1BQVAsR0FBZ0IsQ0FBL0IsRUFBa0M7QUFDaEMyQixVQUFNWSxRQUFOO0FBQ0FqQyxZQUFRa0MsSUFBUixDQUFhLENBQUMsQ0FBZDtBQUNEOztBQUVELFFBQU01QyxhQUFheUMsS0FBS0MsQ0FBeEI7QUFDQSxRQUFNM0MsU0FBUzBDLEtBQUtJLENBQXBCO0FBQ0EsUUFBTTVDLFdBQVd3QyxLQUFLSyxDQUF0QjtBQUNBLFFBQU01QyxlQUFldUMsS0FBS00sQ0FBMUI7O0FBRUFuQixPQUFLN0IsTUFBTCxFQUFhQyxVQUFiLEVBQXlCQyxRQUF6QixFQUFtQ0MsWUFBbkMsRUFDRzhDLElBREgsQ0FDUSxNQUFNdEMsUUFBUWtDLElBQVIsQ0FBYSxDQUFiLENBRGQsRUFFR0ssS0FGSCxDQUVVaEMsQ0FBRCxJQUFPO0FBQ1pKLFlBQVFLLEtBQVIsQ0FBY0QsRUFBRUUsT0FBRixJQUFhRixDQUEzQjtBQUNBUixNQUFFUSxFQUFFRyxLQUFKOztBQUVBUCxZQUFRSyxLQUFSLENBQWMsdUZBQWQ7QUFDQVIsWUFBUWtDLElBQVIsQ0FBYSxDQUFDLENBQWQ7QUFDRCxHQVJIO0FBU0QiLCJmaWxlIjoiY2xpLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXHJcblxyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IG1rZGlycCBmcm9tICdta2RpcnAnO1xyXG5cclxuaW1wb3J0IHtjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3R9IGZyb20gJy4vY29uZmlnLXBhcnNlcic7XHJcbmltcG9ydCB7Zm9yQWxsRmlsZXN9IGZyb20gJy4vZm9yLWFsbC1maWxlcyc7XHJcblxyXG5wcm9jZXNzLm9uKCd1bmhhbmRsZWRSZWplY3Rpb24nLCAoZSkgPT4ge1xyXG4gIGQoZS5tZXNzYWdlIHx8IGUpO1xyXG4gIGQoZS5zdGFjayB8fCAnJyk7XHJcbn0pO1xyXG5cclxucHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCAoZSkgPT4ge1xyXG4gIGQoZS5tZXNzYWdlIHx8IGUpO1xyXG4gIGQoZS5zdGFjayB8fCAnJyk7XHJcbn0pO1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1haW4oYXBwRGlyLCBzb3VyY2VEaXJzLCBjYWNoZURpciwgc291cmNlTWFwRGlyKSB7XHJcbiAgbGV0IGNvbXBpbGVySG9zdCA9IG51bGw7XHJcbiAgaWYgKCFjYWNoZURpciB8fCBjYWNoZURpci5sZW5ndGggPCAxKSB7XHJcbiAgICBjYWNoZURpciA9ICcuY2FjaGUnO1xyXG4gIH1cclxuXHJcbiAgbGV0IHJvb3RDYWNoZURpciA9IHBhdGguam9pbihhcHBEaXIsIGNhY2hlRGlyKTtcclxuICBta2RpcnAuc3luYyhyb290Q2FjaGVEaXIpO1xyXG4gIGxldCBtYXBEaXIgPSByb290Q2FjaGVEaXI7XHJcblxyXG4gIGlmIChzb3VyY2VNYXBEaXIpIHtcclxuICAgIG1hcERpciA9IHBhdGguam9pbihhcHBEaXIsIHNvdXJjZU1hcERpcik7XHJcbiAgICBkKGBzcGVjaWZlZCBzZXBhcmF0ZSBzb3VyY2UgbWFwIGRpciBhdCAke21hcERpcn0sIGNyZWF0aW5nIGl0YCk7XHJcbiAgICBta2RpcnAuc3luYyhtYXBEaXIpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIGNvbnNvbGUubG9nKGBVc2luZyBOT0RFX0VOViA9ICR7cHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50J31gKTtcclxuICB9XHJcblxyXG4gIGQoYG1haW46ICR7YXBwRGlyfSwgJHtKU09OLnN0cmluZ2lmeShzb3VyY2VEaXJzKX1gKTtcclxuICB0cnkge1xyXG4gICAgY29tcGlsZXJIb3N0ID0gYXdhaXQgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290KGFwcERpciwgcm9vdENhY2hlRGlyLCBzb3VyY2VNYXBEaXIpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkbid0IHNldCB1cCBjb21waWxlcnM6ICR7ZS5tZXNzYWdlfWApO1xyXG4gICAgZChlLnN0YWNrKTtcclxuXHJcbiAgICB0aHJvdyBlO1xyXG4gIH1cclxuXHJcbiAgYXdhaXQgUHJvbWlzZS5hbGwoc291cmNlRGlycy5tYXAoKGRpcikgPT4gZm9yQWxsRmlsZXMoZGlyLCBhc3luYyAoZikgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgZChgU3RhcnRpbmcgY29tcGlsYXRpb24gZm9yICR7Zn1gKTtcclxuICAgICAgYXdhaXQgY29tcGlsZXJIb3N0LmNvbXBpbGUoZik7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjb21waWxlIGZpbGU6ICR7Zn1gKTtcclxuICAgICAgY29uc29sZS5lcnJvcihlLm1lc3NhZ2UpO1xyXG5cclxuICAgICAgZChlLnN0YWNrKTtcclxuICAgIH1cclxuICB9KSkpO1xyXG5cclxuICBkKCdTYXZpbmcgb3V0IGNvbmZpZ3VyYXRpb24nKTtcclxuICBhd2FpdCBjb21waWxlckhvc3Quc2F2ZUNvbmZpZ3VyYXRpb24oKTtcclxufVxyXG5cclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGUnKTtcclxuXHJcbmNvbnN0IHlhcmdzID0gcmVxdWlyZSgneWFyZ3MnKVxyXG4gIC51c2FnZSgnVXNhZ2U6IGVsZWN0cm9uLWNvbXBpbGUgLS1hcHBkaXIgW3Jvb3QtYXBwLWRpcl0gcGF0aHMuLi4nKVxyXG4gIC5hbGlhcygnYScsICdhcHBkaXInKVxyXG4gIC5kZXNjcmliZSgnYScsICdUaGUgdG9wLWxldmVsIGFwcGxpY2F0aW9uIGRpcmVjdG9yeSAoaS5lLiB3aGVyZSB5b3VyIHBhY2thZ2UuanNvbiBpcyknKVxyXG4gIC5kZWZhdWx0KCdhJywgcHJvY2Vzcy5jd2QoKSlcclxuICAuYWxpYXMoJ2MnLCAnY2FjaGVkaXInKVxyXG4gIC5kZXNjcmliZSgnYycsICdUaGUgZGlyZWN0b3J5IHRvIHB1dCB0aGUgY2FjaGUnKVxyXG4gIC5hbGlhcygncycsICdzb3VyY2VtYXBkaXInKVxyXG4gIC5kZXNjcmliZSgncycsICdUaGUgZGlyZWN0b3J5IHRvIHN0b3JlIHNvdXJjZW1hcCBpZiBjb21waWxlciBjb25maWd1cmVkIHRvIGhhdmUgc291cmNlbWFwIGZpbGUuIERlZmF1bHQgdG8gY2FjaGVkaXIgaWYgbm90IHNwZWNpZmllZC4nKVxyXG4gIC5oZWxwKCdoJylcclxuICAuYWxpYXMoJ2gnLCAnaGVscCcpXHJcbiAgLmVwaWxvZygnQ29weXJpZ2h0IDIwMTUnKTtcclxuXHJcbmlmIChwcm9jZXNzLm1haW5Nb2R1bGUgPT09IG1vZHVsZSkge1xyXG4gIGNvbnN0IGFyZ3YgPSB5YXJncy5hcmd2O1xyXG5cclxuICBpZiAoIWFyZ3YuXyB8fCBhcmd2Ll8ubGVuZ3RoIDwgMSkge1xyXG4gICAgeWFyZ3Muc2hvd0hlbHAoKTtcclxuICAgIHByb2Nlc3MuZXhpdCgtMSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzb3VyY2VEaXJzID0gYXJndi5fO1xyXG4gIGNvbnN0IGFwcERpciA9IGFyZ3YuYTtcclxuICBjb25zdCBjYWNoZURpciA9IGFyZ3YuYztcclxuICBjb25zdCBzb3VyY2VNYXBEaXIgPSBhcmd2LnM7XHJcblxyXG4gIG1haW4oYXBwRGlyLCBzb3VyY2VEaXJzLCBjYWNoZURpciwgc291cmNlTWFwRGlyKVxyXG4gICAgLnRoZW4oKCkgPT4gcHJvY2Vzcy5leGl0KDApKVxyXG4gICAgLmNhdGNoKChlKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZS5tZXNzYWdlIHx8IGUpO1xyXG4gICAgICBkKGUuc3RhY2spO1xyXG5cclxuICAgICAgY29uc29sZS5lcnJvcihcIkNvbXBpbGF0aW9uIGZhaWxlZCFcXG5Gb3IgZXh0cmEgaW5mb3JtYXRpb24sIHNldCB0aGUgREVCVUcgZW52aXJvbm1lbnQgdmFyaWFibGUgdG8gJyonXCIpO1xyXG4gICAgICBwcm9jZXNzLmV4aXQoLTEpO1xyXG4gICAgfSk7XHJcbn1cclxuIl19","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/custom-operators.js":"'use strict';\n\nvar _Observable = require('rxjs/Observable');\n\nvar _async = require('rxjs/scheduler/async');\n\nrequire('rxjs/add/observable/range');\n\nrequire('rxjs/add/observable/throw');\n\nrequire('rxjs/add/observable/timer');\n\nrequire('rxjs/add/operator/mergeMap');\n\nrequire('rxjs/add/operator/map');\n\nrequire('rxjs/add/operator/retryWhen');\n\nrequire('rxjs/add/operator/switch');\n\nrequire('rxjs/add/operator/zip');\n\nfunction retryWithDelayOrError(errors, maxRetries) {\n  return _Observable.Observable.range(1, maxRetries + 1).zip(errors, (i, e) => {\n    return { attempts: i, error: e };\n  }).mergeMap((_ref) => {\n    let attempts = _ref.attempts,\n        error = _ref.error;\n\n    return attempts <= maxRetries ? _Observable.Observable.timer(attempts * 1000) : _Observable.Observable.throw(error);\n  });\n}\n\nconst newCoolOperators = {\n  guaranteedThrottle: function (time) {\n    let scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _async.async;\n\n    return this.map(x => _Observable.Observable.timer(time, scheduler).map(() => x)).switch();\n  },\n\n  retryAtIntervals: function () {\n    let maxRetries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n\n    return this.retryWhen(errors => retryWithDelayOrError(errors, maxRetries));\n  }\n};\n\nfor (const key of Object.keys(newCoolOperators)) {\n  _Observable.Observable.prototype[key] = newCoolOperators[key];\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jdXN0b20tb3BlcmF0b3JzLmpzIl0sIm5hbWVzIjpbInJldHJ5V2l0aERlbGF5T3JFcnJvciIsImVycm9ycyIsIm1heFJldHJpZXMiLCJyYW5nZSIsInppcCIsImkiLCJlIiwiYXR0ZW1wdHMiLCJlcnJvciIsIm1lcmdlTWFwIiwidGltZXIiLCJ0aHJvdyIsIm5ld0Nvb2xPcGVyYXRvcnMiLCJndWFyYW50ZWVkVGhyb3R0bGUiLCJ0aW1lIiwic2NoZWR1bGVyIiwibWFwIiwieCIsInN3aXRjaCIsInJldHJ5QXRJbnRlcnZhbHMiLCJyZXRyeVdoZW4iLCJrZXkiLCJPYmplY3QiLCJrZXlzIiwicHJvdG90eXBlIl0sIm1hcHBpbmdzIjoiOztBQUFBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBLFNBQVNBLHFCQUFULENBQStCQyxNQUEvQixFQUF1Q0MsVUFBdkMsRUFBbUQ7QUFDakQsU0FBTyx1QkFBV0MsS0FBWCxDQUFpQixDQUFqQixFQUFvQkQsYUFBYSxDQUFqQyxFQUNKRSxHQURJLENBQ0FILE1BREEsRUFDUSxDQUFDSSxDQUFELEVBQUlDLENBQUosS0FBVTtBQUNyQixXQUFPLEVBQUVDLFVBQVVGLENBQVosRUFBZUcsT0FBT0YsQ0FBdEIsRUFBUDtBQUNELEdBSEksRUFJSkcsUUFKSSxDQUlLLFVBQXVCO0FBQUEsUUFBckJGLFFBQXFCLFFBQXJCQSxRQUFxQjtBQUFBLFFBQVhDLEtBQVcsUUFBWEEsS0FBVzs7QUFDL0IsV0FBT0QsWUFBWUwsVUFBWixHQUNMLHVCQUFXUSxLQUFYLENBQWlCSCxXQUFXLElBQTVCLENBREssR0FFTCx1QkFBV0ksS0FBWCxDQUFpQkgsS0FBakIsQ0FGRjtBQUdELEdBUkksQ0FBUDtBQVNEOztBQUVELE1BQU1JLG1CQUFtQjtBQUN2QkMsc0JBQW9CLFVBQVNDLElBQVQsRUFBa0M7QUFBQSxRQUFuQkMsU0FBbUI7O0FBQ3BELFdBQU8sS0FDSkMsR0FESSxDQUNDQyxDQUFELElBQU8sdUJBQVdQLEtBQVgsQ0FBaUJJLElBQWpCLEVBQXVCQyxTQUF2QixFQUFrQ0MsR0FBbEMsQ0FBc0MsTUFBTUMsQ0FBNUMsQ0FEUCxFQUVKQyxNQUZJLEVBQVA7QUFHRCxHQUxzQjs7QUFPdkJDLG9CQUFrQixZQUF5QjtBQUFBLFFBQWhCakIsVUFBZ0IsdUVBQUgsQ0FBRzs7QUFDekMsV0FBTyxLQUFLa0IsU0FBTCxDQUFnQm5CLE1BQUQsSUFBWUQsc0JBQXNCQyxNQUF0QixFQUE4QkMsVUFBOUIsQ0FBM0IsQ0FBUDtBQUNEO0FBVHNCLENBQXpCOztBQWFBLEtBQUssTUFBTW1CLEdBQVgsSUFBa0JDLE9BQU9DLElBQVAsQ0FBWVgsZ0JBQVosQ0FBbEIsRUFBaUQ7QUFDL0MseUJBQVdZLFNBQVgsQ0FBcUJILEdBQXJCLElBQTRCVCxpQkFBaUJTLEdBQWpCLENBQTVCO0FBQ0QiLCJmaWxlIjoiY3VzdG9tLW9wZXJhdG9ycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcclxuaW1wb3J0IHthc3luY30gZnJvbSAncnhqcy9zY2hlZHVsZXIvYXN5bmMnO1xyXG5cclxuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL3JhbmdlJztcclxuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL3Rocm93JztcclxuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL3RpbWVyJztcclxuXHJcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2VNYXAnO1xyXG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL21hcCc7XHJcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvcmV0cnlXaGVuJztcclxuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9zd2l0Y2gnO1xyXG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3ppcCc7XHJcblxyXG5mdW5jdGlvbiByZXRyeVdpdGhEZWxheU9yRXJyb3IoZXJyb3JzLCBtYXhSZXRyaWVzKSB7XHJcbiAgcmV0dXJuIE9ic2VydmFibGUucmFuZ2UoMSwgbWF4UmV0cmllcyArIDEpXHJcbiAgICAuemlwKGVycm9ycywgKGksIGUpID0+IHtcclxuICAgICAgcmV0dXJuIHsgYXR0ZW1wdHM6IGksIGVycm9yOiBlIH07XHJcbiAgICB9KVxyXG4gICAgLm1lcmdlTWFwKCh7YXR0ZW1wdHMsIGVycm9yfSkgPT4ge1xyXG4gICAgICByZXR1cm4gYXR0ZW1wdHMgPD0gbWF4UmV0cmllcyA/XHJcbiAgICAgICAgT2JzZXJ2YWJsZS50aW1lcihhdHRlbXB0cyAqIDEwMDApIDpcclxuICAgICAgICBPYnNlcnZhYmxlLnRocm93KGVycm9yKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5jb25zdCBuZXdDb29sT3BlcmF0b3JzID0ge1xyXG4gIGd1YXJhbnRlZWRUaHJvdHRsZTogZnVuY3Rpb24odGltZSwgc2NoZWR1bGVyID0gYXN5bmMpIHtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgICAgIC5tYXAoKHgpID0+IE9ic2VydmFibGUudGltZXIodGltZSwgc2NoZWR1bGVyKS5tYXAoKCkgPT4geCkpXHJcbiAgICAgIC5zd2l0Y2goKTtcclxuICB9LFxyXG5cclxuICByZXRyeUF0SW50ZXJ2YWxzOiBmdW5jdGlvbihtYXhSZXRyaWVzID0gMykge1xyXG4gICAgcmV0dXJuIHRoaXMucmV0cnlXaGVuKChlcnJvcnMpID0+IHJldHJ5V2l0aERlbGF5T3JFcnJvcihlcnJvcnMsIG1heFJldHJpZXMpKTtcclxuICB9LFxyXG59O1xyXG5cclxuXHJcbmZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG5ld0Nvb2xPcGVyYXRvcnMpKSB7XHJcbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGVba2V5XSA9IG5ld0Nvb2xPcGVyYXRvcnNba2V5XTtcclxufVxyXG4iXX0=","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/es6-shim.js":"'use strict';\n\nvar path = require('path');\nvar electronCompile = require('electron-compile');\n\nvar packageJson = require('./package.json');\nlet initScript = path.resolve(__dirname, packageJson.originalMain);\nelectronCompile.init(__dirname, initScript);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9lczYtc2hpbS5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsImVsZWN0cm9uQ29tcGlsZSIsInBhY2thZ2VKc29uIiwiaW5pdFNjcmlwdCIsInJlc29sdmUiLCJfX2Rpcm5hbWUiLCJvcmlnaW5hbE1haW4iLCJpbml0Il0sIm1hcHBpbmdzIjoiOztBQUFBLElBQUlBLE9BQU9DLFFBQVEsTUFBUixDQUFYO0FBQ0EsSUFBSUMsa0JBQWtCRCxRQUFRLGtCQUFSLENBQXRCOztBQUVBLElBQUlFLGNBQWNGLFFBQVEsZ0JBQVIsQ0FBbEI7QUFDQSxJQUFJRyxhQUFhSixLQUFLSyxPQUFMLENBQWFDLFNBQWIsRUFBd0JILFlBQVlJLFlBQXBDLENBQWpCO0FBQ0FMLGdCQUFnQk0sSUFBaEIsQ0FBcUJGLFNBQXJCLEVBQWdDRixVQUFoQyIsImZpbGUiOiJlczYtc2hpbS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG52YXIgZWxlY3Ryb25Db21waWxlID0gcmVxdWlyZSgnZWxlY3Ryb24tY29tcGlsZScpO1xyXG5cclxudmFyIHBhY2thZ2VKc29uID0gcmVxdWlyZSgnLi9wYWNrYWdlLmpzb24nKTtcclxubGV0IGluaXRTY3JpcHQgPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCBwYWNrYWdlSnNvbi5vcmlnaW5hbE1haW4pO1xyXG5lbGVjdHJvbkNvbXBpbGUuaW5pdChfX2Rpcm5hbWUsIGluaXRTY3JpcHQpO1xyXG4iXX0=","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/initialize-renderer.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initializeRendererProcess = initializeRendererProcess;\n\nvar _compilerHost = require('./compiler-host');\n\nvar _compilerHost2 = _interopRequireDefault(_compilerHost);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// NB: These are duped in protocol-hook so we can save startup time, make\n// sure to run both!\nconst magicGlobalForRootCacheDir = '__electron_compile_root_cache_dir';\nconst magicGlobalForAppRootDir = '__electron_compile_app_root_dir';\n\nconst d = require('debug')('electron-compile:initialize-renderer');\n\nlet rendererInitialized = false;\n\n/**\n * Called by our rigged script file at the top of every HTML file to set up\n * the same compilers as the browser process that created us\n *\n * @private\n */\nfunction initializeRendererProcess(readOnlyMode) {\n  if (rendererInitialized) return;\n\n  let rootCacheDir = require('electron').remote.getGlobal(magicGlobalForRootCacheDir);\n  let appRoot = require('electron').remote.getGlobal(magicGlobalForAppRootDir);\n  let compilerHost = null;\n\n  // NB: This has to be synchronous because we need to block HTML parsing\n  // until we're set up\n  if (readOnlyMode) {\n    d(`Setting up electron-compile in precompiled mode with cache dir: ${rootCacheDir}`);\n\n    // NB: React cares SUPER HARD about this, and this is the earliest place \n    // we can set it up to ensure React picks it up correctly\n    process.env.NODE_ENV = 'production';\n    compilerHost = _compilerHost2.default.createReadonlyFromConfigurationSync(rootCacheDir, appRoot);\n  } else {\n    d(`Setting up electron-compile in development mode with cache dir: ${rootCacheDir}`);\n\n    var _require = require('./config-parser');\n\n    const createCompilers = _require.createCompilers;\n\n    const compilersByMimeType = createCompilers();\n\n    compilerHost = _compilerHost2.default.createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType);\n  }\n\n  require('./x-require');\n  require('./require-hook').default(compilerHost);\n  rendererInitialized = true;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbml0aWFsaXplLXJlbmRlcmVyLmpzIl0sIm5hbWVzIjpbImluaXRpYWxpemVSZW5kZXJlclByb2Nlc3MiLCJtYWdpY0dsb2JhbEZvclJvb3RDYWNoZURpciIsIm1hZ2ljR2xvYmFsRm9yQXBwUm9vdERpciIsImQiLCJyZXF1aXJlIiwicmVuZGVyZXJJbml0aWFsaXplZCIsInJlYWRPbmx5TW9kZSIsInJvb3RDYWNoZURpciIsInJlbW90ZSIsImdldEdsb2JhbCIsImFwcFJvb3QiLCJjb21waWxlckhvc3QiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9uU3luYyIsImNyZWF0ZUNvbXBpbGVycyIsImNvbXBpbGVyc0J5TWltZVR5cGUiLCJjcmVhdGVGcm9tQ29uZmlndXJhdGlvblN5bmMiLCJkZWZhdWx0Il0sIm1hcHBpbmdzIjoiOzs7OztRQWlCZ0JBLHlCLEdBQUFBLHlCOztBQWpCaEI7Ozs7OztBQUVBO0FBQ0E7QUFDQSxNQUFNQyw2QkFBNkIsbUNBQW5DO0FBQ0EsTUFBTUMsMkJBQTJCLGlDQUFqQzs7QUFFQSxNQUFNQyxJQUFJQyxRQUFRLE9BQVIsRUFBaUIsc0NBQWpCLENBQVY7O0FBRUEsSUFBSUMsc0JBQXNCLEtBQTFCOztBQUVBOzs7Ozs7QUFNTyxTQUFTTCx5QkFBVCxDQUFtQ00sWUFBbkMsRUFBaUQ7QUFDdEQsTUFBSUQsbUJBQUosRUFBeUI7O0FBRXpCLE1BQUlFLGVBQWVILFFBQVEsVUFBUixFQUFvQkksTUFBcEIsQ0FBMkJDLFNBQTNCLENBQXFDUiwwQkFBckMsQ0FBbkI7QUFDQSxNQUFJUyxVQUFVTixRQUFRLFVBQVIsRUFBb0JJLE1BQXBCLENBQTJCQyxTQUEzQixDQUFxQ1Asd0JBQXJDLENBQWQ7QUFDQSxNQUFJUyxlQUFlLElBQW5COztBQUVBO0FBQ0E7QUFDQSxNQUFJTCxZQUFKLEVBQWtCO0FBQ2hCSCxNQUFHLG1FQUFrRUksWUFBYSxFQUFsRjs7QUFFQTtBQUNBO0FBQ0FLLFlBQVFDLEdBQVIsQ0FBWUMsUUFBWixHQUF1QixZQUF2QjtBQUNBSCxtQkFBZSx1QkFBYUksbUNBQWIsQ0FBaURSLFlBQWpELEVBQStERyxPQUEvRCxDQUFmO0FBQ0QsR0FQRCxNQU9PO0FBQ0xQLE1BQUcsbUVBQWtFSSxZQUFhLEVBQWxGOztBQURLLG1CQUV1QkgsUUFBUSxpQkFBUixDQUZ2Qjs7QUFBQSxVQUVHWSxlQUZILFlBRUdBLGVBRkg7O0FBR0wsVUFBTUMsc0JBQXNCRCxpQkFBNUI7O0FBRUFMLG1CQUFlLHVCQUFhTywyQkFBYixDQUF5Q1gsWUFBekMsRUFBdURHLE9BQXZELEVBQWdFTyxtQkFBaEUsQ0FBZjtBQUNEOztBQUVEYixVQUFRLGFBQVI7QUFDQUEsVUFBUSxnQkFBUixFQUEwQmUsT0FBMUIsQ0FBa0NSLFlBQWxDO0FBQ0FOLHdCQUFzQixJQUF0QjtBQUNEIiwiZmlsZSI6ImluaXRpYWxpemUtcmVuZGVyZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29tcGlsZXJIb3N0IGZyb20gJy4vY29tcGlsZXItaG9zdCc7XG5cbi8vIE5COiBUaGVzZSBhcmUgZHVwZWQgaW4gcHJvdG9jb2wtaG9vayBzbyB3ZSBjYW4gc2F2ZSBzdGFydHVwIHRpbWUsIG1ha2Vcbi8vIHN1cmUgdG8gcnVuIGJvdGghXG5jb25zdCBtYWdpY0dsb2JhbEZvclJvb3RDYWNoZURpciA9ICdfX2VsZWN0cm9uX2NvbXBpbGVfcm9vdF9jYWNoZV9kaXInO1xuY29uc3QgbWFnaWNHbG9iYWxGb3JBcHBSb290RGlyID0gJ19fZWxlY3Ryb25fY29tcGlsZV9hcHBfcm9vdF9kaXInO1xuXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWcnKSgnZWxlY3Ryb24tY29tcGlsZTppbml0aWFsaXplLXJlbmRlcmVyJyk7XG5cbmxldCByZW5kZXJlckluaXRpYWxpemVkID0gZmFsc2U7XG5cbi8qKlxuICogQ2FsbGVkIGJ5IG91ciByaWdnZWQgc2NyaXB0IGZpbGUgYXQgdGhlIHRvcCBvZiBldmVyeSBIVE1MIGZpbGUgdG8gc2V0IHVwXG4gKiB0aGUgc2FtZSBjb21waWxlcnMgYXMgdGhlIGJyb3dzZXIgcHJvY2VzcyB0aGF0IGNyZWF0ZWQgdXNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZVJlbmRlcmVyUHJvY2VzcyhyZWFkT25seU1vZGUpIHtcbiAgaWYgKHJlbmRlcmVySW5pdGlhbGl6ZWQpIHJldHVybjtcblxuICBsZXQgcm9vdENhY2hlRGlyID0gcmVxdWlyZSgnZWxlY3Ryb24nKS5yZW1vdGUuZ2V0R2xvYmFsKG1hZ2ljR2xvYmFsRm9yUm9vdENhY2hlRGlyKTtcbiAgbGV0IGFwcFJvb3QgPSByZXF1aXJlKCdlbGVjdHJvbicpLnJlbW90ZS5nZXRHbG9iYWwobWFnaWNHbG9iYWxGb3JBcHBSb290RGlyKTtcbiAgbGV0IGNvbXBpbGVySG9zdCA9IG51bGw7XG5cbiAgLy8gTkI6IFRoaXMgaGFzIHRvIGJlIHN5bmNocm9ub3VzIGJlY2F1c2Ugd2UgbmVlZCB0byBibG9jayBIVE1MIHBhcnNpbmdcbiAgLy8gdW50aWwgd2UncmUgc2V0IHVwXG4gIGlmIChyZWFkT25seU1vZGUpIHtcbiAgICBkKGBTZXR0aW5nIHVwIGVsZWN0cm9uLWNvbXBpbGUgaW4gcHJlY29tcGlsZWQgbW9kZSB3aXRoIGNhY2hlIGRpcjogJHtyb290Q2FjaGVEaXJ9YCk7XG5cbiAgICAvLyBOQjogUmVhY3QgY2FyZXMgU1VQRVIgSEFSRCBhYm91dCB0aGlzLCBhbmQgdGhpcyBpcyB0aGUgZWFybGllc3QgcGxhY2UgXG4gICAgLy8gd2UgY2FuIHNldCBpdCB1cCB0byBlbnN1cmUgUmVhY3QgcGlja3MgaXQgdXAgY29ycmVjdGx5XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSAncHJvZHVjdGlvbic7XG4gICAgY29tcGlsZXJIb3N0ID0gQ29tcGlsZXJIb3N0LmNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb25TeW5jKHJvb3RDYWNoZURpciwgYXBwUm9vdCk7XG4gIH0gZWxzZSB7XG4gICAgZChgU2V0dGluZyB1cCBlbGVjdHJvbi1jb21waWxlIGluIGRldmVsb3BtZW50IG1vZGUgd2l0aCBjYWNoZSBkaXI6ICR7cm9vdENhY2hlRGlyfWApO1xuICAgIGNvbnN0IHsgY3JlYXRlQ29tcGlsZXJzIH0gPSByZXF1aXJlKCcuL2NvbmZpZy1wYXJzZXInKTtcbiAgICBjb25zdCBjb21waWxlcnNCeU1pbWVUeXBlID0gY3JlYXRlQ29tcGlsZXJzKCk7XG5cbiAgICBjb21waWxlckhvc3QgPSBDb21waWxlckhvc3QuY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb25TeW5jKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgY29tcGlsZXJzQnlNaW1lVHlwZSk7XG4gIH1cblxuICByZXF1aXJlKCcuL3gtcmVxdWlyZScpO1xuICByZXF1aXJlKCcuL3JlcXVpcmUtaG9vaycpLmRlZmF1bHQoY29tcGlsZXJIb3N0KTtcbiAgcmVuZGVyZXJJbml0aWFsaXplZCA9IHRydWU7XG59XG4iXX0=","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/live-reload.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enableLiveReload = enableLiveReload;\n\nvar _fileChangeCache = require('./file-change-cache');\n\nvar _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);\n\nvar _pathwatcherRx = require('./pathwatcher-rx');\n\nvar _Observable = require('rxjs/Observable');\n\nrequire('./custom-operators');\n\nrequire('rxjs/add/observable/defer');\n\nrequire('rxjs/add/observable/empty');\n\nrequire('rxjs/add/observable/fromPromise');\n\nrequire('rxjs/add/operator/catch');\n\nrequire('rxjs/add/operator/filter');\n\nrequire('rxjs/add/operator/mergeMap');\n\nrequire('rxjs/add/operator/switchMap');\n\nrequire('rxjs/add/operator/timeout');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction enableLiveReload() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let strategy = options.strategy;\n\n\n  if (process.type !== 'browser' || !global.globalCompilerHost) throw new Error(\"Call this from the browser process, right after initializing electron-compile\");\n\n  switch (strategy) {\n    case 'react-hmr':\n      enableReactHMR();\n      break;\n    case 'naive':\n    default:\n      enableLiveReloadNaive();\n  }\n}\n\nlet BrowserWindow;\nif (process.type === 'browser') {\n  BrowserWindow = require('electron').BrowserWindow;\n}\n\nfunction reloadAllWindows() {\n  let ret = BrowserWindow.getAllWindows().map(wnd => {\n    if (!wnd.isVisible()) return Promise.resolve(true);\n\n    return new Promise(res => {\n      wnd.webContents.reloadIgnoringCache();\n      wnd.once('ready-to-show', () => res(true));\n    });\n  });\n\n  return Promise.all(ret);\n}\n\nfunction enableLiveReloadNaive() {\n  let filesWeCareAbout = global.globalCompilerHost.listenToCompileEvents().filter(x => !_fileChangeCache2.default.isInNodeModules(x.filePath));\n\n  let weShouldReload = filesWeCareAbout.mergeMap(x => (0, _pathwatcherRx.watchPath)(x.filePath).map(() => x)).guaranteedThrottle(1 * 1000);\n\n  return weShouldReload.switchMap(() => _Observable.Observable.defer(() => _Observable.Observable.fromPromise(reloadAllWindows()).timeout(5 * 1000).catch(() => _Observable.Observable.empty()))).subscribe(() => console.log(\"Reloaded all windows!\"));\n}\n\nfunction triggerHMRInRenderers() {\n  BrowserWindow.getAllWindows().forEach(window => {\n    window.webContents.send('__electron-compile__HMR');\n  });\n\n  return Promise.resolve(true);\n}\n\nfunction enableReactHMR() {\n  global.__electron_compile_hmr_enabled__ = true;\n\n  let filesWeCareAbout = global.globalCompilerHost.listenToCompileEvents().filter(x => !_fileChangeCache2.default.isInNodeModules(x.filePath));\n\n  let weShouldReload = filesWeCareAbout.mergeMap(x => (0, _pathwatcherRx.watchPath)(x.filePath).map(() => x)).guaranteedThrottle(1 * 1000);\n\n  return weShouldReload.switchMap(() => _Observable.Observable.defer(() => _Observable.Observable.fromPromise(triggerHMRInRenderers()).catch(() => _Observable.Observable.empty()))).subscribe(() => console.log(\"HMR sent to all windows!\"));\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9saXZlLXJlbG9hZC5qcyJdLCJuYW1lcyI6WyJlbmFibGVMaXZlUmVsb2FkIiwib3B0aW9ucyIsInN0cmF0ZWd5IiwicHJvY2VzcyIsInR5cGUiLCJnbG9iYWwiLCJnbG9iYWxDb21waWxlckhvc3QiLCJFcnJvciIsImVuYWJsZVJlYWN0SE1SIiwiZW5hYmxlTGl2ZVJlbG9hZE5haXZlIiwiQnJvd3NlcldpbmRvdyIsInJlcXVpcmUiLCJyZWxvYWRBbGxXaW5kb3dzIiwicmV0IiwiZ2V0QWxsV2luZG93cyIsIm1hcCIsInduZCIsImlzVmlzaWJsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzIiwid2ViQ29udGVudHMiLCJyZWxvYWRJZ25vcmluZ0NhY2hlIiwib25jZSIsImFsbCIsImZpbGVzV2VDYXJlQWJvdXQiLCJsaXN0ZW5Ub0NvbXBpbGVFdmVudHMiLCJmaWx0ZXIiLCJ4IiwiaXNJbk5vZGVNb2R1bGVzIiwiZmlsZVBhdGgiLCJ3ZVNob3VsZFJlbG9hZCIsIm1lcmdlTWFwIiwiZ3VhcmFudGVlZFRocm90dGxlIiwic3dpdGNoTWFwIiwiZGVmZXIiLCJmcm9tUHJvbWlzZSIsInRpbWVvdXQiLCJjYXRjaCIsImVtcHR5Iiwic3Vic2NyaWJlIiwiY29uc29sZSIsImxvZyIsInRyaWdnZXJITVJJblJlbmRlcmVycyIsImZvckVhY2giLCJ3aW5kb3ciLCJzZW5kIiwiX19lbGVjdHJvbl9jb21waWxlX2htcl9lbmFibGVkX18iXSwibWFwcGluZ3MiOiI7Ozs7O1FBZ0JnQkEsZ0IsR0FBQUEsZ0I7O0FBaEJoQjs7OztBQUNBOztBQUNBOztBQUVBOztBQUVBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBRU8sU0FBU0EsZ0JBQVQsR0FBc0M7QUFBQSxNQUFaQyxPQUFZLHVFQUFKLEVBQUk7QUFBQSxNQUNyQ0MsUUFEcUMsR0FDeEJELE9BRHdCLENBQ3JDQyxRQURxQzs7O0FBRzNDLE1BQUlDLFFBQVFDLElB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aWxlIjoibGl2ZS1yZWxvYWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRmlsZUNoYW5nZWRDYWNoZSBmcm9tICcuL2ZpbGUtY2hhbmdlLWNhY2hlJztcbmltcG9ydCB7d2F0Y2hQYXRofSBmcm9tICcuL3BhdGh3YXRjaGVyLXJ4JztcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcblxuaW1wb3J0ICcuL2N1c3RvbS1vcGVyYXRvcnMnO1xuXG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvZGVmZXInO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL2VtcHR5JztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZSc7XG5cbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvY2F0Y2gnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9maWx0ZXInO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tZXJnZU1hcCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaE1hcCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3RpbWVvdXQnO1xuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlTGl2ZVJlbG9hZChvcHRpb25zPXt9KSB7XG4gIGxldCB7IHN0cmF0ZWd5IH0gPSBvcHRpb25zO1xuXG4gIGlmIChwcm9jZXNzLnR5cGUgIT09ICdicm93c2VyJyB8fCAhZ2xvYmFsLmdsb2JhbENvbXBpbGVySG9zdCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbCB0aGlzIGZyb20gdGhlIGJyb3dzZXIgcHJvY2VzcywgcmlnaHQgYWZ0ZXIgaW5pdGlhbGl6aW5nIGVsZWN0cm9uLWNvbXBpbGVcIik7XG5cbiAgc3dpdGNoKHN0cmF0ZWd5KSB7XG4gIGNhc2UgJ3JlYWN0LWhtcic6XG4gICAgZW5hYmxlUmVhY3RITVIoKTtcbiAgICBicmVhaztcbiAgY2FzZSAnbmFpdmUnOlxuICBkZWZhdWx0OlxuICAgIGVuYWJsZUxpdmVSZWxvYWROYWl2ZSgpO1xuICB9XG59XG5cbmxldCBCcm93c2VyV2luZG93O1xuaWYgKHByb2Nlc3MudHlwZSA9PT0gJ2Jyb3dzZXInKSB7XG4gIEJyb3dzZXJXaW5kb3cgPSByZXF1aXJlKCdlbGVjdHJvbicpLkJyb3dzZXJXaW5kb3c7XG59XG5cbmZ1bmN0aW9uIHJlbG9hZEFsbFdpbmRvd3MoKSB7XG4gIGxldCByZXQgPSBCcm93c2VyV2luZG93LmdldEFsbFdpbmRvd3MoKS5tYXAod25kID0+IHtcbiAgICBpZiAoIXduZC5pc1Zpc2libGUoKSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICB3bmQud2ViQ29udGVudHMucmVsb2FkSWdub3JpbmdDYWNoZSgpO1xuICAgICAgd25kLm9uY2UoJ3JlYWR5LXRvLXNob3cnLCAoKSA9PiByZXModHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwocmV0KTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlTGl2ZVJlbG9hZE5haXZlKCkge1xuICBsZXQgZmlsZXNXZUNhcmVBYm91dCA9IGdsb2JhbC5nbG9iYWxDb21waWxlckhvc3QubGlzdGVuVG9Db21waWxlRXZlbnRzKClcbiAgICAuZmlsdGVyKHggPT4gIUZpbGVDaGFuZ2VkQ2FjaGUuaXNJbk5vZGVNb2R1bGVzKHguZmlsZVBhdGgpKTtcblxuICBsZXQgd2VTaG91bGRSZWxvYWQgPSBmaWxlc1dlQ2FyZUFib3V0XG4gICAgLm1lcmdlTWFwKHggPT4gd2F0Y2hQYXRoKHguZmlsZVBhdGgpLm1hcCgoKSA9PiB4KSlcbiAgICAuZ3VhcmFudGVlZFRocm90dGxlKDEqMTAwMCk7XG5cbiAgcmV0dXJuIHdlU2hvdWxkUmVsb2FkXG4gICAgLnN3aXRjaE1hcCgoKSA9PiBPYnNlcnZhYmxlLmRlZmVyKCgpID0+IE9ic2VydmFibGUuZnJvbVByb21pc2UocmVsb2FkQWxsV2luZG93cygpKS50aW1lb3V0KDUqMTAwMCkuY2F0Y2goKCkgPT4gT2JzZXJ2YWJsZS5lbXB0eSgpKSkpXG4gICAgLnN1YnNjcmliZSgoKSA9PiBjb25zb2xlLmxvZyhcIlJlbG9hZGVkIGFsbCB3aW5kb3dzIVwiKSk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJITVJJblJlbmRlcmVycygpIHtcbiAgQnJvd3NlcldpbmRvdy5nZXRBbGxXaW5kb3dzKCkuZm9yRWFjaCgod2luZG93KSA9PiB7XG4gICAgd2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ19fZWxlY3Ryb24tY29tcGlsZV9fSE1SJyk7XG4gIH0pO1xuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGVuYWJsZVJlYWN0SE1SKCkge1xuICBnbG9iYWwuX19lbGVjdHJvbl9jb21waWxlX2htcl9lbmFibGVkX18gPSB0cnVlO1xuXG4gIGxldCBmaWxlc1dlQ2FyZUFib3V0ID0gZ2xvYmFsLmdsb2JhbENvbXBpbGVySG9zdC5saXN0ZW5Ub0NvbXBpbGVFdmVudHMoKVxuICAgIC5maWx0ZXIoeCA9PiAhRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoeC5maWxlUGF0aCkpO1xuXG4gIGxldCB3ZVNob3VsZFJlbG9hZCA9IGZpbGVzV2VDYXJlQWJvdXRcbiAgICAubWVyZ2VNYXAoeCA9PiB3YXRjaFBhdGgoeC5maWxlUGF0aCkubWFwKCgpID0+IHgpKVxuICAgIC5ndWFyYW50ZWVkVGhyb3R0bGUoMSoxMDAwKTtcblxuICByZXR1cm4gd2VTaG91bGRSZWxvYWRcbiAgICAuc3dpdGNoTWFwKCgpID0+IE9ic2VydmFibGUuZGVmZXIoKCkgPT4gT2JzZXJ2YWJsZS5mcm9tUHJvbWlzZSh0cmlnZ2VySE1SSW5SZW5kZXJlcnMoKSkuY2F0Y2goKCkgPT4gT2JzZXJ2YWJsZS5lbXB0eSgpKSkpXG4gICAgLnN1YnNjcmliZSgoKSA9PiBjb25zb2xlLmxvZyhcIkhNUiBzZW50IHRvIGFsbCB3aW5kb3dzIVwiKSk7XG59XG4iXX0=","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/pathwatcher-rx.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.watchPathDirect = watchPathDirect;\nexports.watchPath = watchPath;\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _Observable = require('rxjs/Observable');\n\nvar _Subscription = require('rxjs/Subscription');\n\nvar _lruCache = require('lru-cache');\n\nvar _lruCache2 = _interopRequireDefault(_lruCache);\n\nrequire('rxjs/add/operator/publish');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction watchPathDirect(directory) {\n  return _Observable.Observable.create(subj => {\n    let dead = false;\n\n    const watcher = _fs2.default.watch(directory, {}, (eventType, fileName) => {\n      if (dead) return;\n      subj.next({ eventType, fileName });\n    });\n\n    watcher.on('error', e => {\n      dead = true;\n      subj.error(e);\n    });\n\n    return new _Subscription.Subscription(() => {\n      if (!dead) {\n        watcher.close();\n      }\n    });\n  });\n}\n\nconst pathCache = new _lruCache2.default({ length: 256 });\nfunction watchPath(directory) {\n  let ret = pathCache.get(directory);\n  if (ret) return ret;\n\n  ret = watchPathDirect(directory).publish().refCount();\n  pathCache.set(directory, ret);\n  return ret;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wYXRod2F0Y2hlci1yeC5qcyJdLCJuYW1lcyI6WyJ3YXRjaFBhdGhEaXJlY3QiLCJ3YXRjaFBhdGgiLCJkaXJlY3RvcnkiLCJjcmVhdGUiLCJzdWJqIiwiZGVhZCIsIndhdGNoZXIiLCJ3YXRjaCIsImV2ZW50VHlwZSIsImZpbGVOYW1lIiwibmV4dCIsIm9uIiwiZSIsImVycm9yIiwiY2xvc2UiLCJwYXRoQ2FjaGUiLCJsZW5ndGgiLCJyZXQiLCJnZXQiLCJwdWJsaXNoIiwicmVmQ291bnQiLCJzZXQiXSwibWFwcGluZ3MiOiI7Ozs7O1FBT2dCQSxlLEdBQUFBLGU7UUFtQkFDLFMsR0FBQUEsUzs7QUExQmhCOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQTs7OztBQUVPLFNBQVNELGVBQVQsQ0FBeUJFLFNBQXpCLEVBQW9DO0FBQ3pDLFNBQU8sdUJBQVdDLE1BQVgsQ0FBbUJDLElBQUQsSUFBVTtBQUNqQyxRQUFJQyxPQUFPLEtBQVg7O0FBRUEsVUFBTUMsVUFBVSxhQUFHQyxLQUFILENBQVNMLFNBQVQsRUFBb0IsRUFBcEIsRUFBd0IsQ0FBQ00sU0FBRCxFQUFZQyxRQUFaLEtBQXlCO0FBQy9ELFVBQUlKLElBQUosRUFBVTtBQUNWRCxXQUFLTSxJQUFMLENBQVUsRUFBQ0YsU0FBRCxFQUFZQyxRQUFaLEVBQVY7QUFDRCxLQUhlLENBQWhCOztBQUtBSCxZQUFRSyxFQUFSLENBQVcsT0FBWCxFQUFxQkMsQ0FBRCxJQUFPO0FBQ3pCUCxhQUFPLElBQVA7QUFDQUQsV0FBS1MsS0FBTCxDQUFXRCxDQUFYO0FBQ0QsS0FIRDs7QUFLQSxXQUFPLCtCQUFpQixNQUFNO0FBQUUsVUFBSSxDQUFDUCxJQUFMLEVBQVc7QUFBRUMsZ0JBQVFRLEtBQVI7QUFBa0I7QUFBRSxLQUExRCxDQUFQO0FBQ0QsR0FkTSxDQUFQO0FBZUQ7O0FBRUQsTUFBTUMsWUFBWSx1QkFBUSxFQUFFQyxRQUFRLEdBQVYsRUFBUixDQUFsQjtBQUNPLFNBQVNmLFNBQVQsQ0FBbUJDLFNBQW5CLEVBQThCO0FBQ25DLE1BQUllLE1BQU1GLFVBQVVHLEdBQVYsQ0FBY2hCLFNBQWQsQ0FBVjtBQUNBLE1BQUllLEdBQUosRUFBUyxPQUFPQSxHQUFQOztBQUVUQSxRQUFNakIsZ0JBQWdCRSxTQUFoQixFQUEyQmlCLE9BQTNCLEdBQXFDQyxRQUFyQyxFQUFOO0FBQ0FMLFlBQVVNLEdBQVYsQ0FBY25CLFNBQWQsRUFBeUJlLEdBQXpCO0FBQ0EsU0FBT0EsR0FBUDtBQUNEIiwiZmlsZSI6InBhdGh3YXRjaGVyLXJ4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xyXG5pbXBvcnQge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xyXG5pbXBvcnQgTFJVIGZyb20gJ2xydS1jYWNoZSc7XHJcblxyXG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3B1Ymxpc2gnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHdhdGNoUGF0aERpcmVjdChkaXJlY3RvcnkpIHtcclxuICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKHN1YmopID0+IHtcclxuICAgIGxldCBkZWFkID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3Qgd2F0Y2hlciA9IGZzLndhdGNoKGRpcmVjdG9yeSwge30sIChldmVudFR5cGUsIGZpbGVOYW1lKSA9PiB7XHJcbiAgICAgIGlmIChkZWFkKSByZXR1cm47XHJcbiAgICAgIHN1YmoubmV4dCh7ZXZlbnRUeXBlLCBmaWxlTmFtZX0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgd2F0Y2hlci5vbignZXJyb3InLCAoZSkgPT4ge1xyXG4gICAgICBkZWFkID0gdHJ1ZTtcclxuICAgICAgc3Viai5lcnJvcihlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKCgpID0+IHsgaWYgKCFkZWFkKSB7IHdhdGNoZXIuY2xvc2UoKTsgfSB9KTtcclxuICB9KTtcclxufVxyXG5cclxuY29uc3QgcGF0aENhY2hlID0gbmV3IExSVSh7IGxlbmd0aDogMjU2IH0pO1xyXG5leHBvcnQgZnVuY3Rpb24gd2F0Y2hQYXRoKGRpcmVjdG9yeSkge1xyXG4gIGxldCByZXQgPSBwYXRoQ2FjaGUuZ2V0KGRpcmVjdG9yeSk7XHJcbiAgaWYgKHJldCkgcmV0dXJuIHJldDtcclxuXHJcbiAgcmV0ID0gd2F0Y2hQYXRoRGlyZWN0KGRpcmVjdG9yeSkucHVibGlzaCgpLnJlZkNvdW50KCk7XHJcbiAgcGF0aENhY2hlLnNldChkaXJlY3RvcnksIHJldCk7XHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG4iXX0=","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/packager-cli.js":"#!/usr/bin/env node\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.packagerMain = exports.runAsarArchive = exports.packageDirToResourcesDir = undefined;\n\nlet packageDirToResourcesDir = exports.packageDirToResourcesDir = (() => {\n  var _ref = _asyncToGenerator(function* (packageDir) {\n    let appDir = (yield _promise.pfs.readdir(packageDir)).find(function (x) {\n      return x.match(/\\.app$/i);\n    });\n    if (appDir) {\n      return _path2.default.join(packageDir, appDir, 'Contents', 'Resources', 'app');\n    } else {\n      return _path2.default.join(packageDir, 'resources', 'app');\n    }\n  });\n\n  return function packageDirToResourcesDir(_x) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet copySmallFile = (() => {\n  var _ref2 = _asyncToGenerator(function* (from, to) {\n    d(`Copying ${from} => ${to}`);\n\n    let buf = yield _promise.pfs.readFile(from);\n    yield _promise.pfs.writeFile(to, buf);\n  });\n\n  return function copySmallFile(_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nlet compileAndShim = (() => {\n  var _ref3 = _asyncToGenerator(function* (packageDir) {\n    let appDir = yield packageDirToResourcesDir(packageDir);\n\n    d(`Looking in ${appDir}`);\n    for (let entry of yield _promise.pfs.readdir(appDir)) {\n      if (entry.match(/^(node_modules|bower_components)$/)) continue;\n\n      let fullPath = _path2.default.join(appDir, entry);\n      let stat = yield _promise.pfs.stat(fullPath);\n\n      if (!stat.isDirectory()) continue;\n\n      d(`Executing electron-compile: ${appDir} => ${entry}`);\n      yield (0, _cli.main)(appDir, [fullPath]);\n    }\n\n    d('Copying in es6-shim');\n    let packageJson = JSON.parse((yield _promise.pfs.readFile(_path2.default.join(appDir, 'package.json'), 'utf8')));\n\n    let index = packageJson.main || 'index.js';\n    packageJson.originalMain = index;\n    packageJson.main = 'es6-shim.js';\n\n    yield copySmallFile(_path2.default.join(__dirname, 'es6-shim.js'), _path2.default.join(appDir, 'es6-shim.js'));\n\n    yield _promise.pfs.writeFile(_path2.default.join(appDir, 'package.json'), JSON.stringify(packageJson, null, 2));\n  });\n\n  return function compileAndShim(_x4) {\n    return _ref3.apply(this, arguments);\n  };\n})();\n\nlet runAsarArchive = exports.runAsarArchive = (() => {\n  var _ref4 = _asyncToGenerator(function* (packageDir, asarUnpackDir) {\n    let appDir = yield packageDirToResourcesDir(packageDir);\n\n    let asarArgs = ['pack', 'app', 'app.asar'];\n    if (asarUnpackDir) {\n      asarArgs.push('--unpack-dir', asarUnpackDir);\n    }\n\n    var _findExecutableOrGues = findExecutableOrGuess('asar', asarArgs);\n\n    let cmd = _findExecutableOrGues.cmd,\n        args = _findExecutableOrGues.args;\n\n\n    d(`Running ${cmd} ${JSON.stringify(args)}`);\n    yield (0, _spawnRx.spawnPromise)(cmd, args, { cwd: _path2.default.join(appDir, '..') });\n    _rimraf2.default.sync(_path2.default.join(appDir));\n  });\n\n  return function runAsarArchive(_x5, _x6) {\n    return _ref4.apply(this, arguments);\n  };\n})();\n\nlet packagerMain = exports.packagerMain = (() => {\n  var _ref5 = _asyncToGenerator(function* (argv) {\n    d(`argv: ${JSON.stringify(argv)}`);\n    argv = argv.splice(2);\n\n    var _splitOutAsarArgument = splitOutAsarArguments(argv);\n\n    let packagerArgs = _splitOutAsarArgument.packagerArgs,\n        asarArgs = _splitOutAsarArgument.asarArgs;\n\n    var _findExecutableOrGues2 = findExecutableOrGuess(electronPackager, packagerArgs);\n\n    let cmd = _findExecutableOrGues2.cmd,\n        args = _findExecutableOrGues2.args;\n\n\n    d(`Spawning electron-packager: ${JSON.stringify(args)}`);\n    let packagerOutput = yield (0, _spawnRx.spawnPromise)(cmd, args);\n    let packageDirs = parsePackagerOutput(packagerOutput);\n\n    d(`Starting compilation for ${JSON.stringify(packageDirs)}`);\n    for (let packageDir of packageDirs) {\n      yield compileAndShim(packageDir);\n\n      if (!asarArgs) continue;\n\n      d('Starting ASAR packaging');\n      let asarUnpackDir = null;\n      if (asarArgs.length === 2) {\n        asarUnpackDir = asarArgs[1];\n      }\n\n      yield runAsarArchive(packageDir, asarUnpackDir);\n    }\n  });\n\n  return function packagerMain(_x7) {\n    return _ref5.apply(this, arguments);\n  };\n})();\n\nexports.splitOutAsarArguments = splitOutAsarArguments;\nexports.parsePackagerOutput = parsePackagerOutput;\nexports.findExecutableOrGuess = findExecutableOrGuess;\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _rimraf = require('rimraf');\n\nvar _rimraf2 = _interopRequireDefault(_rimraf);\n\nvar _promise = require('./promise');\n\nvar _cli = require('./cli');\n\nvar _spawnRx = require('spawn-rx');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst d = require('debug')('electron-compile:packager');\nconst electronPackager = 'electron-packager';\n\nfunction splitOutAsarArguments(argv) {\n  if (argv.find(x => x.match(/^--asar-unpack$/))) {\n    throw new Error(\"electron-compile doesn't support --asar-unpack at the moment, use asar-unpack-dir\");\n  }\n\n  // Strip --asar altogether\n  let ret = argv.filter(x => !x.match(/^--asar/));\n\n  if (ret.length === argv.length) {\n    return { packagerArgs: ret, asarArgs: null };\n  }\n\n  let indexOfUnpack = ret.findIndex(x => x.match(/^--asar-unpack-dir$/));\n  if (indexOfUnpack < 0) {\n    return { packagerArgs: ret, asarArgs: [] };\n  }\n\n  let unpackArgs = ret.slice(indexOfUnpack, indexOfUnpack + 1);\n  let notUnpackArgs = ret.slice(0, indexOfUnpack).concat(ret.slice(indexOfUnpack + 2));\n\n  return { packagerArgs: notUnpackArgs, asarArgs: unpackArgs };\n}\n\nfunction parsePackagerOutput(output) {\n  // NB: Yes, this is fragile as fuck. :-/\n  console.log(output);\n  let lines = output.split('\\n');\n\n  let idx = lines.findIndex(x => x.match(/Wrote new app/i));\n  if (idx < 1) throw new Error(`Packager output is invalid: ${output}`);\n  lines = lines.splice(idx);\n\n  // Multi-platform case\n  if (lines[0].match(/Wrote new apps/)) {\n    return lines.splice(1).filter(x => x.length > 1);\n  } else {\n    return [lines[0].replace(/^.*new app to /, '')];\n  }\n}\n\nfunction findExecutableOrGuess(cmdToFind, argsToUse) {\n  var _findActualExecutable = (0, _spawnRx.findActualExecutable)(cmdToFind, argsToUse);\n\n  let cmd = _findActualExecutable.cmd,\n      args = _findActualExecutable.args;\n\n  if (cmd === electronPackager) {\n    d(`Can't find ${cmdToFind}, falling back to where it should be as a guess!`);\n    let cmdSuffix = process.platform === 'win32' ? '.cmd' : '';\n    return (0, _spawnRx.findActualExecutable)(_path2.default.resolve(__dirname, '..', '..', '.bin', `${cmdToFind}${cmdSuffix}`), argsToUse);\n  }\n\n  return { cmd, args };\n}\n\nif (process.mainModule === module) {\n  packagerMain(process.argv).then(() => process.exit(0)).catch(e => {\n    console.error(e.message || e);\n    d(e.stack);\n\n    process.exit(-1);\n  });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wYWNrYWdlci1jbGkuanMiXSwibmFtZXMiOlsicGFja2FnZURpciIsImFwcERpciIsInJlYWRkaXIiLCJmaW5kIiwieCIsIm1hdGNoIiwiam9pbiIsInBhY2thZ2VEaXJUb1Jlc291cmNlc0RpciIsImZyb20iLCJ0byIsImQiLCJidWYiLCJyZWFkRmlsZSIsIndyaXRlRmlsZSIsImNvcHlTbWFsbEZpbGUiLCJlbnRyeSIsImZ1bGxQYXRoIiwic3RhdCIsImlzRGlyZWN0b3J5IiwicGFja2FnZUpzb24iLCJKU09OIiwicGFyc2UiLCJpbmRleCIsIm1haW4iLCJvcmlnaW5hbE1haW4iLCJfX2Rpcm5hbWUiLCJzdHJpbmdpZnkiLCJjb21waWxlQW5kU2hpbSIsImFzYXJVbnBhY2tEaXIiLCJhc2FyQXJncyIsInB1c2giLCJmaW5kRXhlY3V0YWJsZU9yR3Vlc3MiLCJjbWQiLCJhcmdzIiwiY3dkIiwic3luYyIsInJ1bkFzYXJBcmNoaXZlIiwiYXJndiIsInNwbGljZSIsInNwbGl0T3V0QXNhckFyZ3VtZW50cyIsInBhY2thZ2VyQXJncyIsImVsZWN0cm9uUGFja2FnZXIiLCJwYWNrYWdlck91dHB1dCIsInBhY2thZ2VEaXJzIiwicGFyc2VQYWNrYWdlck91dHB1dCIsImxlbmd0aCIsInBhY2thZ2VyTWFpbiIsInJlcXVpcmUiLCJFcnJvciIsInJldCIsImZpbHRlciIsImluZGV4T2ZVbnBhY2siLCJmaW5kSW5kZXgiLCJ1bnBhY2tBcmdzIiwic2xpY2UiLCJub3RVbnBhY2tBcmdzIiwiY29uY2F0Iiwib3V0cHV0IiwiY29uc29sZSIsImxvZyIsImxpbmVzIiwic3BsaXQiLCJpZHgiLCJyZXBsYWNlIiwiY21kVG9GaW5kIiwiYXJnc1RvVXNlIiwiY21kU3VmZml4IiwicHJvY2VzcyIsInBsYXRmb3JtIiwicmVzb2x2ZSIsIm1haW5Nb2R1bGUiLCJtb2R1bGUiLCJ0aGVuIiwiZXhpdCIsImNhdGNoIiwiZSIsImVycm9yIiwibWVzc2FnZSIsInN0YWNr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LG1DQUFxQkQsU0FBckIsRUFBZ0NDLFNBQWhDLENBRHNDOztBQUFBLE1BQ3BEakMsR0FEb0QseUJBQ3BEQSxHQURvRDtBQUFBLE1BQy9DQyxJQUQrQyx5QkFDL0NBLElBRCtDOztBQUUxRCxNQUFJRCxRQUFRUyxnQkFBWixFQUE4QjtBQUM1Qi9CLE1BQUcsY0FBYXNELFNBQVUsa0RBQTFCO0FBQ0EsUUFBSUUsWUFBWUMsUUFBUUMsUUFBUixLQUFxQixPQUFyQixHQUErQixNQUEvQixHQUF3QyxFQUF4RDtBQUNBLFdBQU8sbUNBQXFCLGVBQUtDLE9BQUwsQ0FBYTVDLFNBQWIsRUFBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsTUFBcEMsRUFBNkMsR0FBRXVDLFNBQVUsR0FBRUUsU0FBVSxFQUFyRSxDQUFyQixFQUE4RkQsU0FBOUYsQ0FBUDtBQUNEOztBQUVELFNBQU8sRUFBRWpDLEdBQUYsRUFBT0MsSUFBUCxFQUFQO0FBQ0Q7O0FBNkJELElBQUlrQyxRQUFRRyxVQUFSLEtBQXVCQyxNQUEzQixFQUFtQztBQUNqQ3pCLGVBQWFxQixRQUFROUIsSUFBckIsRUFDR21DLElBREgsQ0FDUSxNQUFNTCxRQUFRTSxJQUFSLENBQWEsQ0FBYixDQURkLEVBRUdDLEtBRkgsQ0FFVUMsQ0FBRCxJQUFPO0FBQ1pqQixZQUFRa0IsS0FBUixDQUFjRCxFQUFFRSxPQUFGLElBQWFGLENBQTNCO0FBQ0FqRSxNQUFFaUUsRUFBRUcsS0FBSjs7QUFFQVgsWUFBUU0sSUFBUixDQUFhLENBQUMsQ0FBZDtBQUNELEdBUEg7QUFRRCIsImZpbGUiOiJwYWNrYWdlci1jbGkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgcmltcmFmIGZyb20gJ3JpbXJhZic7XG5cbmltcG9ydCB7cGZzfSBmcm9tICcuL3Byb21pc2UnO1xuaW1wb3J0IHttYWlufSBmcm9tICcuL2NsaSc7XG5cbmltcG9ydCB7c3Bhd25Qcm9taXNlLCBmaW5kQWN0dWFsRXhlY3V0YWJsZX0gZnJvbSAnc3Bhd24tcngnO1xuXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWcnKSgnZWxlY3Ryb24tY29tcGlsZTpwYWNrYWdlcicpO1xuY29uc3QgZWxlY3Ryb25QYWNrYWdlciA9ICdlbGVjdHJvbi1wYWNrYWdlcic7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYWNrYWdlRGlyVG9SZXNvdXJjZXNEaXIocGFja2FnZURpcikge1xuICBsZXQgYXBwRGlyID0gKGF3YWl0IHBmcy5yZWFkZGlyKHBhY2thZ2VEaXIpKS5maW5kKCh4KSA9PiB4Lm1hdGNoKC9cXC5hcHAkL2kpKTtcbiAgaWYgKGFwcERpcikge1xuICAgIHJldHVybiBwYXRoLmpvaW4ocGFja2FnZURpciwgYXBwRGlyLCAnQ29udGVudHMnLCAnUmVzb3VyY2VzJywgJ2FwcCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXRoLmpvaW4ocGFja2FnZURpciwgJ3Jlc291cmNlcycsICdhcHAnKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb3B5U21hbGxGaWxlKGZyb20sIHRvKSB7XG4gIGQoYENvcHlpbmcgJHtmcm9tfSA9PiAke3RvfWApO1xuXG4gIGxldCBidWYgPSBhd2FpdCBwZnMucmVhZEZpbGUoZnJvbSk7XG4gIGF3YWl0IHBmcy53cml0ZUZpbGUodG8sIGJ1Zik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdE91dEFzYXJBcmd1bWVudHMoYXJndikge1xuICBpZiAoYXJndi5maW5kKCh4KSA9PiB4Lm1hdGNoKC9eLS1hc2FyLXVucGFjayQvKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbGVjdHJvbi1jb21waWxlIGRvZXNuJ3Qgc3VwcG9ydCAtLWFzYXItdW5wYWNrIGF0IHRoZSBtb21lbnQsIHVzZSBhc2FyLXVucGFjay1kaXJcIik7XG4gIH1cblxuICAvLyBTdHJpcCAtLWFzYXIgYWx0b2dldGhlclxuICBsZXQgcmV0ID0gYXJndi5maWx0ZXIoKHgpID0+ICF4Lm1hdGNoKC9eLS1hc2FyLykpO1xuXG4gIGlmIChyZXQubGVuZ3RoID09PSBhcmd2Lmxlbmd0aCkgeyByZXR1cm4geyBwYWNrYWdlckFyZ3M6IHJldCwgYXNhckFyZ3M6IG51bGwgfTsgfVxuXG4gIGxldCBpbmRleE9mVW5wYWNrID0gcmV0LmZpbmRJbmRleCgoeCkgPT4geC5tYXRjaCgvXi0tYXNhci11bnBhY2stZGlyJC8pKTtcbiAgaWYgKGluZGV4T2ZVbnBhY2sgPCAwKSB7XG4gICAgcmV0dXJuIHsgcGFja2FnZXJBcmdzOiByZXQsIGFzYXJBcmdzOiBbXSB9O1xuICB9XG5cbiAgbGV0IHVucGFja0FyZ3MgPSByZXQuc2xpY2UoaW5kZXhPZlVucGFjaywgaW5kZXhPZlVucGFjaysxKTtcbiAgbGV0IG5vdFVucGFja0FyZ3MgPSByZXQuc2xpY2UoMCwgaW5kZXhPZlVucGFjaykuY29uY2F0KHJldC5zbGljZShpbmRleE9mVW5wYWNrKzIpKTtcblxuICByZXR1cm4geyBwYWNrYWdlckFyZ3M6IG5vdFVucGFja0FyZ3MsIGFzYXJBcmdzOiB1bnBhY2tBcmdzIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhY2thZ2VyT3V0cHV0KG91dHB1dCkge1xuICAvLyBOQjogWWVzLCB0aGlzIGlzIGZyYWdpbGUgYXMgZnVjay4gOi0vXG4gIGNvbnNvbGUubG9nKG91dHB1dCk7XG4gIGxldCBsaW5lcyA9IG91dHB1dC5zcGxpdCgnXFxuJyk7XG5cbiAgbGV0IGlkeCA9IGxpbmVzLmZpbmRJbmRleCgoeCkgPT4geC5tYXRjaCgvV3JvdGUgbmV3IGFwcC9pKSk7XG4gIGlmIChpZHggPCAxKSB0aHJvdyBuZXcgRXJyb3IoYFBhY2thZ2VyIG91dHB1dCBpcyBpbnZhbGlkOiAke291dHB1dH1gKTtcbiAgbGluZXMgPSBsaW5lcy5zcGxpY2UoaWR4KTtcblxuICAvLyBNdWx0aS1wbGF0Zm9ybSBjYXNlXG4gIGlmIChsaW5lc1swXS5tYXRjaCgvV3JvdGUgbmV3IGFwcHMvKSkge1xuICAgIHJldHVybiBsaW5lcy5zcGxpY2UoMSkuZmlsdGVyKCh4KSA9PiB4Lmxlbmd0aCA+IDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbbGluZXNbMF0ucmVwbGFjZSgvXi4qbmV3IGFwcCB0byAvLCAnJyldO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbXBpbGVBbmRTaGltKHBhY2thZ2VEaXIpIHtcbiAgbGV0IGFwcERpciA9IGF3YWl0IHBhY2thZ2VEaXJUb1Jlc291cmNlc0RpcihwYWNrYWdlRGlyKTtcblxuICBkKGBMb29raW5nIGluICR7YXBwRGlyfWApO1xuICBmb3IgKGxldCBlbnRyeSBvZiBhd2FpdCBwZnMucmVhZGRpcihhcHBEaXIpKSB7XG4gICAgaWYgKGVudHJ5Lm1hdGNoKC9eKG5vZGVfbW9kdWxlc3xib3dlcl9jb21wb25lbnRzKSQvKSkgY29udGludWU7XG5cbiAgICBsZXQgZnVsbFBhdGggPSBwYXRoLmpvaW4oYXBwRGlyLCBlbnRyeSk7XG4gICAgbGV0IHN0YXQgPSBhd2FpdCBwZnMuc3RhdChmdWxsUGF0aCk7XG5cbiAgICBpZiAoIXN0YXQuaXNEaXJlY3RvcnkoKSkgY29udGludWU7XG5cbiAgICBkKGBFeGVjdXRpbmcgZWxlY3Ryb24tY29tcGlsZTogJHthcHBEaXJ9ID0+ICR7ZW50cnl9YCk7XG4gICAgYXdhaXQgbWFpbihhcHBEaXIsIFtmdWxsUGF0aF0pO1xuICB9XG5cbiAgZCgnQ29weWluZyBpbiBlczYtc2hpbScpO1xuICBsZXQgcGFja2FnZUpzb24gPSBKU09OLnBhcnNlKFxuICAgIGF3YWl0IHBmcy5yZWFkRmlsZShwYXRoLmpvaW4oYXBwRGlyLCAncGFja2FnZS5qc29uJyksICd1dGY4JykpO1xuXG4gIGxldCBpbmRleCA9IHBhY2thZ2VKc29uLm1haW4gfHwgJ2luZGV4LmpzJztcbiAgcGFja2FnZUpzb24ub3JpZ2luYWxNYWluID0gaW5kZXg7XG4gIHBhY2thZ2VKc29uLm1haW4gPSAnZXM2LXNoaW0uanMnO1xuXG4gIGF3YWl0IGNvcHlTbWFsbEZpbGUoXG4gICAgcGF0aC5qb2luKF9fZGlybmFtZSwgJ2VzNi1zaGltLmpzJyksXG4gICAgcGF0aC5qb2luKGFwcERpciwgJ2VzNi1zaGltLmpzJykpO1xuXG4gIGF3YWl0IHBmcy53cml0ZUZpbGUoXG4gICAgcGF0aC5qb2luKGFwcERpciwgJ3BhY2thZ2UuanNvbicpLFxuICAgIEpTT04uc3RyaW5naWZ5KHBhY2thZ2VKc29uLCBudWxsLCAyKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW5Bc2FyQXJjaGl2ZShwYWNrYWdlRGlyLCBhc2FyVW5wYWNrRGlyKSB7XG4gIGxldCBhcHBEaXIgPSBhd2FpdCBwYWNrYWdlRGlyVG9SZXNvdXJjZXNEaXIocGFja2FnZURpcik7XG5cbiAgbGV0IGFzYXJBcmdzID0gWydwYWNrJywgJ2FwcCcsICdhcHAuYXNhciddO1xuICBpZiAoYXNhclVucGFja0Rpcikge1xuICAgIGFzYXJBcmdzLnB1c2goJy0tdW5wYWNrLWRpcicsIGFzYXJVbnBhY2tEaXIpO1xuICB9XG5cbiAgbGV0IHsgY21kLCBhcmdzIH0gPSBmaW5kRXhlY3V0YWJsZU9yR3Vlc3MoJ2FzYXInLCBhc2FyQXJncyk7XG5cbiAgZChgUnVubmluZyAke2NtZH0gJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKTtcbiAgYXdhaXQgc3Bhd25Qcm9taXNlKGNtZCwgYXJncywgeyBjd2Q6IHBhdGguam9pbihhcHBEaXIsICcuLicpIH0pO1xuICByaW1yYWYuc3luYyhwYXRoLmpvaW4oYXBwRGlyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRXhlY3V0YWJsZU9yR3Vlc3MoY21kVG9GaW5kLCBhcmdzVG9Vc2UpIHtcbiAgbGV0IHsgY21kLCBhcmdzIH0gPSBmaW5kQWN0dWFsRXhlY3V0YWJsZShjbWRUb0ZpbmQsIGFyZ3NUb1VzZSk7XG4gIGlmIChjbWQgPT09IGVsZWN0cm9uUGFja2FnZXIpIHtcbiAgICBkKGBDYW4ndCBmaW5kICR7Y21kVG9GaW5kfSwgZmFsbGluZyBiYWNrIHRvIHdoZXJlIGl0IHNob3VsZCBiZSBhcyBhIGd1ZXNzIWApO1xuICAgIGxldCBjbWRTdWZmaXggPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gJy5jbWQnIDogJyc7XG4gICAgcmV0dXJuIGZpbmRBY3R1YWxFeGVjdXRhYmxlKHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLicsICcuLicsICcuYmluJywgYCR7Y21kVG9GaW5kfSR7Y21kU3VmZml4fWApLCBhcmdzVG9Vc2UpO1xuICB9XG5cbiAgcmV0dXJuIHsgY21kLCBhcmdzIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYWNrYWdlck1haW4oYXJndikge1xuICBkKGBhcmd2OiAke0pTT04uc3RyaW5naWZ5KGFyZ3YpfWApO1xuICBhcmd2ID0gYXJndi5zcGxpY2UoMik7XG5cbiAgbGV0IHsgcGFja2FnZXJBcmdzLCBhc2FyQXJncyB9ID0gc3BsaXRPdXRBc2FyQXJndW1lbnRzKGFyZ3YpO1xuICBsZXQgeyBjbWQsIGFyZ3MgfSA9IGZpbmRFeGVjdXRhYmxlT3JHdWVzcyhlbGVjdHJvblBhY2thZ2VyLCBwYWNrYWdlckFyZ3MpO1xuXG4gIGQoYFNwYXduaW5nIGVsZWN0cm9uLXBhY2thZ2VyOiAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWApO1xuICBsZXQgcGFja2FnZXJPdXRwdXQgPSBhd2FpdCBzcGF3blByb21pc2UoY21kLCBhcmdzKTtcbiAgbGV0IHBhY2thZ2VEaXJzID0gcGFyc2VQYWNrYWdlck91dHB1dChwYWNrYWdlck91dHB1dCk7XG5cbiAgZChgU3RhcnRpbmcgY29tcGlsYXRpb24gZm9yICR7SlNPTi5zdHJpbmdpZnkocGFja2FnZURpcnMpfWApO1xuICBmb3IgKGxldCBwYWNrYWdlRGlyIG9mIHBhY2thZ2VEaXJzKSB7XG4gICAgYXdhaXQgY29tcGlsZUFuZFNoaW0ocGFja2FnZURpcik7XG5cbiAgICBpZiAoIWFzYXJBcmdzKSBjb250aW51ZTtcblxuICAgIGQoJ1N0YXJ0aW5nIEFTQVIgcGFja2FnaW5nJyk7XG4gICAgbGV0IGFzYXJVbnBhY2tEaXIgPSBudWxsO1xuICAgIGlmIChhc2FyQXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGFzYXJVbnBhY2tEaXIgPSBhc2FyQXJnc1sxXTtcbiAgICB9XG5cbiAgICBhd2FpdCBydW5Bc2FyQXJjaGl2ZShwYWNrYWdlRGlyLCBhc2FyVW5wYWNrRGlyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5tYWluTW9kdWxlID09PSBtb2R1bGUpIHtcbiAgcGFja2FnZXJNYWluKHByb2Nlc3MuYXJndilcbiAgICAudGhlbigoKSA9PiBwcm9jZXNzLmV4aXQoMCkpXG4gICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSB8fCBlKTtcbiAgICAgIGQoZS5zdGFjayk7XG5cbiAgICAgIHByb2Nlc3MuZXhpdCgtMSk7XG4gICAgfSk7XG59XG4iXX0=","/home/travis/build/npmtest/node-npmtest-electron-compile/node_modules/electron-compile/lib/x-require.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction requireModule(href) {\n  let filePath = href;\n\n  if (filePath.match(/^file:/i)) {\n    let theUrl = _url2.default.parse(filePath);\n    filePath = decodeURIComponent(theUrl.pathname);\n\n    if (process.platform === 'win32') {\n      filePath = filePath.slice(1);\n    }\n  }\n\n  // NB: We don't do any path canonicalization here because we rely on\n  // InlineHtmlCompiler to have already converted any relative paths that\n  // were used with x-require into absolute paths.\n  require(filePath);\n}\n\n/**\r\n * @private\r\n */\n\nexports.default = (() => {\n  if (process.type !== 'renderer' || !window || !window.document) return null;\n\n  let proto = Object.assign(Object.create(HTMLElement.prototype), {\n    createdCallback: function () {\n      let href = this.getAttribute('src');\n      if (href && href.length > 0) {\n        requireModule(href);\n      }\n    },\n    attributeChangedCallback: function (attrName, oldVal, newVal) {\n      if (attrName !== 'src') return;\n      requireModule(newVal);\n    }\n  });\n\n  return document.registerElement('x-require', { prototype: proto });\n})();\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy94LXJlcXVpcmUuanMiXSwibmFtZXMiOlsicmVxdWlyZU1vZHVsZSIsImhyZWYiLCJmaWxlUGF0aCIsIm1hdGNoIiwidGhlVXJsIiwicGFyc2UiLCJkZWNvZGVVUklDb21wb25lbnQiLCJwYXRobmFtZSIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsInNsaWNlIiwicmVxdWlyZSIsInR5cGUiLCJ3aW5kb3ciLCJkb2N1bWVudCIsInByb3RvIiwiT2JqZWN0IiwiYXNzaWduIiwiY3JlYXRlIiwiSFRNTEVsZW1lbnQiLCJwcm90b3R5cGUiLCJjcmVhdGVkQ2FsbGJhY2siLCJnZXRBdHRyaWJ1dGUiLCJsZW5ndGgiLCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2siLCJhdHRyTmFtZSIsIm9sZFZhbCIsIm5ld1ZhbCIsInJlZ2lzdGVyRWxlbWVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7OztBQUVBLFNBQVNBLGFBQVQsQ0FBdUJDLElBQXZCLEVBQTZCO0FBQzNCLE1BQUlDLFdBQVdELElBQWY7O0FBRUEsTUFBSUMsU0FBU0MsS0FBVCxDQUFlLFNBQWYsQ0FBSixFQUErQjtBQUM3QixRQUFJQyxTQUFTLGNBQUlDLEtBQUosQ0FBVUgsUUFBVixDQUFiO0FBQ0FBLGVBQVdJLG1CQUFtQkYsT0FBT0csUUFBMUIsQ0FBWDs7QUFFQSxRQUFJQyxRQUFRQyxRQUFSLEtBQXFCLE9BQXpCLEVBQWtDO0FBQ2hDUCxpQkFBV0EsU0FBU1EsS0FBVCxDQUFlLENBQWYsQ0FBWDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0FDLFVBQVFULFFBQVI7QUFDRDs7QUFFRDs7OztrQkFHZSxDQUFDLE1BQU07QUFDcEIsTUFBSU0sUUFBUUksSUFBUixLQUFpQixVQUFqQixJQUErQixDQUFDQyxNQUFoQyxJQUEwQyxDQUFDQSxPQUFPQyxRQUF0RCxFQUFnRSxPQUFPLElBQVA7O0FBRWhFLE1BQUlDLFFBQVFDLE9BQU9DLE1BQVAsQ0FBY0QsT0FBT0UsTUFBUCxDQUFjQyxZQUFZQyxTQUExQixDQUFkLEVBQW9EO0FBQzlEQyxxQkFBaUIsWUFBVztBQUMxQixVQUFJcEIsT0FBTyxLQUFLcUIsWUFBTCxDQUFrQixLQUFsQixDQUFYO0FBQ0EsVUFBSXJCLFFBQVFBLEtBQUtzQixNQUFMLEdBQWMsQ0FBMUIsRUFBNkI7QUFDM0J2QixzQkFBY0MsSUFBZDtBQUNEO0FBQ0YsS0FONkQ7QUFPOUR1Qiw4QkFBMEIsVUFBU0MsUUFBVCxFQUFtQkMsTUFBbkIsRUFBMkJDLE1BQTNCLEVBQW1DO0FBQzNELFVBQUlGLGFBQWEsS0FBakIsRUFBd0I7QUFDeEJ6QixvQkFBYzJCLE1BQWQ7QUFDRDtBQVY2RCxHQUFwRCxDQUFaOztBQWFBLFNBQU9iLFNBQVNjLGVBQVQsQ0FBeUIsV0FBekIsRUFBc0MsRUFBRVIsV0FBV0wsS0FBYixFQUF0QyxDQUFQO0FBQ0QsQ0FqQmMsRyIsImZpbGUiOiJ4LXJlcXVpcmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdXJsIGZyb20gJ3VybCc7XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlTW9kdWxlKGhyZWYpIHtcclxuICBsZXQgZmlsZVBhdGggPSBocmVmO1xyXG4gIFxyXG4gIGlmIChmaWxlUGF0aC5tYXRjaCgvXmZpbGU6L2kpKSB7XHJcbiAgICBsZXQgdGhlVXJsID0gdXJsLnBhcnNlKGZpbGVQYXRoKTtcclxuICAgIGZpbGVQYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoZVVybC5wYXRobmFtZSk7XHJcblxyXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcclxuICAgICAgZmlsZVBhdGggPSBmaWxlUGF0aC5zbGljZSgxKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gTkI6IFdlIGRvbid0IGRvIGFueSBwYXRoIGNhbm9uaWNhbGl6YXRpb24gaGVyZSBiZWNhdXNlIHdlIHJlbHkgb25cclxuICAvLyBJbmxpbmVIdG1sQ29tcGlsZXIgdG8gaGF2ZSBhbHJlYWR5IGNvbnZlcnRlZCBhbnkgcmVsYXRpdmUgcGF0aHMgdGhhdFxyXG4gIC8vIHdlcmUgdXNlZCB3aXRoIHgtcmVxdWlyZSBpbnRvIGFic29sdXRlIHBhdGhzLlxyXG4gIHJlcXVpcmUoZmlsZVBhdGgpO1xyXG59XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovIFxyXG5leHBvcnQgZGVmYXVsdCAoKCkgPT4ge1xyXG4gIGlmIChwcm9jZXNzLnR5cGUgIT09ICdyZW5kZXJlcicgfHwgIXdpbmRvdyB8fCAhd2luZG93LmRvY3VtZW50KSByZXR1cm4gbnVsbDtcclxuICBcclxuICBsZXQgcHJvdG8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoSFRNTEVsZW1lbnQucHJvdG90eXBlKSwge1xyXG4gICAgY3JlYXRlZENhbGxiYWNrOiBmdW5jdGlvbigpIHtcclxuICAgICAgbGV0IGhyZWYgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3JjJyk7XHJcbiAgICAgIGlmIChocmVmICYmIGhyZWYubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJlcXVpcmVNb2R1bGUoaHJlZik7XHJcbiAgICAgIH1cclxuICAgIH0sIFxyXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiBmdW5jdGlvbihhdHRyTmFtZSwgb2xkVmFsLCBuZXdWYWwpIHtcclxuICAgICAgaWYgKGF0dHJOYW1lICE9PSAnc3JjJykgcmV0dXJuO1xyXG4gICAgICByZXF1aXJlTW9kdWxlKG5ld1ZhbCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ3gtcmVxdWlyZScsIHsgcHJvdG90eXBlOiBwcm90byB9KTtcclxufSkoKTtcclxuIl19"}